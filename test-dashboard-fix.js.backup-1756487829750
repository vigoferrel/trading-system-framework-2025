const axios = require('axios');

// Funci√≥n para verificar que el dashboard est√© funcionando correctamente
async function testDashboardFix() {
    try {
        console.log('üîç Verificando correcci√≥n del dashboard...');
        
        // Obtener datos del endpoint
        const response = await axios.get('http://localhost:4602/api/enhanced-opportunities');
        
        if (response.data && response.data.opportunities) {
            const opportunities = response.data.opportunities;
            
            console.log(`üìä Total oportunidades: ${opportunities.length}`);
            
            // Verificar que los datos est√©n correctos
            const validOpportunities = opportunities.filter(opp => {
                return opp.currentPrice && 
                       !isNaN(opp.currentPrice) && 
                       opp.currentPrice > 0 &&
                       opp.priceChangePercent !== undefined &&
                       opp.volume > 0;
            });
            
            console.log(`‚úÖ Oportunidades v√°lidas: ${validOpportunities.length}`);
            console.log(`‚ùå Oportunidades inv√°lidas: ${opportunities.length - validOpportunities.length}`);
            
            // Mostrar ejemplos de datos v√°lidos
            if (validOpportunities.length > 0) {
                console.log('\nüìä EJEMPLOS DE DATOS V√ÅLIDOS:');
                validOpportunities.slice(0, 5).forEach((opp, index) => {
                    console.log(`${index + 1}. ${opp.symbol}:`);
                    console.log(`   Precio: $${opp.currentPrice.toFixed(4)}`);
                    console.log(`   Cambio: ${opp.priceChange.toFixed(4)} (${opp.priceChangePercent.toFixed(2)}%)`);
                    console.log(`   Volumen: ${opp.volume.toLocaleString()}`);
                    console.log(`   Confianza: ${(opp.confidence * 100).toFixed(1)}%`);
                    console.log('');
                });
            }
            
            // Verificar estructura de datos
            if (opportunities.length > 0) {
                const sample = opportunities[0];
                console.log('üîç ESTRUCTURA DE DATOS:');
                console.log(`- symbol: ${sample.symbol}`);
                console.log(`- currentPrice: ${sample.currentPrice} (${typeof sample.currentPrice})`);
                console.log(`- priceChange: ${sample.priceChange} (${typeof sample.priceChange})`);
                console.log(`- priceChangePercent: ${sample.priceChangePercent} (${typeof sample.priceChangePercent})`);
                console.log(`- volume: ${sample.volume} (${typeof sample.volume})`);
                console.log(`- confidence: ${sample.confidence} (${typeof sample.confidence})`);
            }
            
            // Verificar que no haya NaN
            const nanCount = opportunities.filter(opp => 
                isNaN(opp.currentPrice) || 
                isNaN(opp.priceChange) || 
                isNaN(opp.priceChangePercent) || 
                isNaN(opp.volume)
            ).length;
            
            console.log(`\nüìä VERIFICACI√ìN DE NaN:`);
            console.log(`- Oportunidades con NaN: ${nanCount}`);
            console.log(`- Porcentaje v√°lido: ${((opportunities.length - nanCount) / opportunities.length * 100).toFixed(1)}%`);
            
            if (nanCount === 0) {
                console.log('‚úÖ ¬°EXCELENTE! No se encontraron valores NaN');
            } else {
                console.log('‚ö†Ô∏è Se encontraron valores NaN que necesitan correcci√≥n');
            }
            
            // Verificar rango de precios
            const prices = validOpportunities.map(opp => opp.currentPrice);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            
            console.log(`\nüìä RANGO DE PRECIOS:`);
            console.log(`- Precio m√≠nimo: $${minPrice.toFixed(4)}`);
            console.log(`- Precio m√°ximo: $${maxPrice.toFixed(4)}`);
            console.log(`- Rango v√°lido: ${minPrice > 0 && maxPrice < 1000000 ? '‚úÖ' : '‚ùå'}`);
            
            return {
                total: opportunities.length,
                valid: validOpportunities.length,
                invalid: opportunities.length - validOpportunities.length,
                nanCount: nanCount,
                priceRange: { min: minPrice, max: maxPrice }
            };
        }
    } catch (error) {
        console.error('‚ùå Error verificando dashboard:', error.message);
        return null;
    }
}

// Funci√≥n para simular el frontend
async function simulateFrontend() {
    try {
        console.log('\nüñ•Ô∏è Simulando procesamiento del frontend...');
        
        const response = await axios.get('http://localhost:4602/api/enhanced-opportunities');
        const opportunities = response.data.opportunities || [];
        
        // Simular el procesamiento del frontend
        const processedOpportunities = opportunities.map(opp => {
            const currentPrice = parseFloat(opp.currentPrice || opp.price || 0);
            const priceChange = parseFloat(opp.priceChange || 0);
            const priceChangePercent = parseFloat(opp.priceChangePercent || 0);
            const volume = parseFloat(opp.volume || 0);
            
            return {
                symbol: opp.symbol,
                currentPrice: currentPrice,
                priceChange: priceChange,
                priceChangePercent: priceChangePercent,
                volume: volume,
                isValid: !isNaN(currentPrice) && currentPrice > 0 && !isNaN(priceChangePercent)
            };
        });
        
        const validProcessed = processedOpportunities.filter(opp => opp.isValid);
        
        console.log(`üìä Procesamiento del frontend:`);
        console.log(`- Total procesados: ${processedOpportunities.length}`);
        console.log(`- V√°lidos: ${validProcessed.length}`);
        console.log(`- Inv√°lidos: ${processedOpportunities.length - validProcessed.length}`);
        
        // Mostrar ejemplos de procesamiento
        if (validProcessed.length > 0) {
            console.log('\nüìä EJEMPLOS DE PROCESAMIENTO FRONTEND:');
            validProcessed.slice(0, 3).forEach((opp, index) => {
                console.log(`${index + 1}. ${opp.symbol}: $${opp.currentPrice.toFixed(4)} (${opp.priceChangePercent > 0 ? '+' : ''}${opp.priceChangePercent.toFixed(2)}%)`);
            });
        }
        
        return {
            processed: processedOpportunities.length,
            valid: validProcessed.length,
            invalid: processedOpportunities.length - validProcessed.length
        };
    } catch (error) {
        console.error('‚ùå Error simulando frontend:', error.message);
        return null;
    }
}

// Ejecutar verificaci√≥n completa
async function main() {
    console.log('üöÄ VERIFICANDO CORRECCI√ìN DEL DASHBOARD\n');
    
    const dashboardResult = await testDashboardFix();
    const frontendResult = await simulateFrontend();
    
    if (dashboardResult && frontendResult) {
        console.log('\n‚úÖ VERIFICACI√ìN COMPLETADA');
        console.log(`üìä Backend: ${dashboardResult.valid}/${dashboardResult.total} v√°lidos`);
        console.log(`üìä Frontend: ${frontendResult.valid}/${frontendResult.processed} v√°lidos`);
        
        if (dashboardResult.nanCount === 0 && frontendResult.invalid === 0) {
            console.log('\nüéâ ¬°DASHBOARD CORREGIDO EXITOSAMENTE!');
            console.log('‚úÖ No se encontraron valores NaN');
            console.log('‚úÖ Todos los datos son v√°lidos');
            console.log('‚úÖ El frontend puede procesar correctamente los datos');
        } else {
            console.log('\n‚ö†Ô∏è A√∫n hay problemas que necesitan atenci√≥n');
        }
    }
}

main();
