// ============================================================================
// QBTC V7 - SISTEMA DE RANKING CUÁNTICO AVANZADO
// ============================================================================

const QUANTUM_CONSTANTS_V7 = {
    phi: 1.618033988749895,
    pi: Math.PI,
    e: Math.E,
    lambda_7919: Math.log(7919),
    fibonacci: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
    primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31],
    golden_ratio: 1.618033988749895,
    silver_ratio: 2.414213562373095,
    bronze_ratio: 3.303577269034296
};

class QuantumScoringEngine {
    constructor() {
        this.quantumConstants = QUANTUM_CONSTANTS_V7;
        
        this.scoringDimensions = [
            'magnitude_score',      // Fuerza de la señal
            'consistency_score',    // Consistencia entre fuentes
            'temporal_score',       // Momentum temporal
            'quantum_coherence',    // Coherencia cuántica
            'risk_adjusted_score',  // Score ajustado por riesgo
            'market_regime_score',  // Adaptación al régimen
            'confidence_score',     // Nivel de confianza
            'execution_score'       // Probabilidad de ejecución exitosa
        ];
        
        this.regimeWeights = {
            'QUANTUM_CRISIS': {
                magnitude_score: 0.35,
                consistency_score: 0.25,
                temporal_score: 0.15,
                risk_adjusted_score: 0.25
            },
            'LEONARDO_TRENDING': {
                magnitude_score: 0.20,
                temporal_score: 0.30,
                quantum_coherence: 0.25,
                execution_score: 0.25
            },
            'FIBONACCI_RANGING': {
                consistency_score: 0.30,
                quantum_coherence: 0.25,
                market_regime_score: 0.25,
                confidence_score: 0.20
            },
            'NEUTRAL': {
                magnitude_score: 0.25,
                consistency_score: 0.25,
                temporal_score: 0.20,
                quantum_coherence: 0.15,
                risk_adjusted_score: 0.15
            }
        };
    }
    
    calculateQuantumScore(recommendation, marketContext) {
        const dimensionalScores = this.calculateAllDimensions(recommendation, marketContext);
        const quantumWeights = this.calculateQuantumWeights(marketContext);
        const coherenceMatrix = this.buildCoherenceMatrix(dimensionalScores);
        
        // Score cuántico usando superposición de estados
        const quantumScore = this.applySuperpositionPrinciple(
            dimensionalScores, 
            quantumWeights, 
            coherenceMatrix
        );
        
        return {
            finalScore: quantumScore,
            dimensionalBreakdown: dimensionalScores,
            quantumMetrics: {
                coherence: coherenceMatrix.coherence,
                entanglement: coherenceMatrix.entanglement,
                superposition: coherenceMatrix.superposition
            },
            confidence: this.calculateScoreConfidence(dimensionalScores),
            explanation: this.generateScoreExplanation(dimensionalScores, quantumScore)
        };
    }
    
    calculateAllDimensions(recommendation, marketContext) {
        return {
            magnitude_score: this.calculateMagnitudeScore(recommendation),
            consistency_score: this.calculateConsistencyScore(recommendation),
            temporal_score: this.calculateTemporalScore(recommendation, marketContext),
            quantum_coherence: this.calculateQuantumCoherence(recommendation),
            risk_adjusted_score: this.calculateRiskAdjustedScore(recommendation),
            market_regime_score: this.calculateMarketRegimeScore(recommendation, marketContext),
            confidence_score: this.calculateConfidenceScore(recommendation),
            execution_score: this.calculateExecutionScore(recommendation)
        };
    }
    
    calculateMagnitudeScore(recommendation) {
        const baseScore = recommendation.consolidatedScore || 0;
        const volumeFactor = Math.min(1, (recommendation.metrics?.volume || 0) / 1000000);
        const priceChangeFactor = Math.min(1, Math.abs(recommendation.metrics?.priceChange || 0) / 10);
        
        return Math.min(1, (baseScore / 100) * 0.6 + volumeFactor * 0.2 + priceChangeFactor * 0.2);
    }
    
    calculateConsistencyScore(recommendation) {
        const sourceCount = recommendation.metrics?.sourceCount || 1;
        const maxSources = 4; // ENHANCED, QUANTUM, BRAIN, ANALYSIS
        
        // Bonus por múltiples fuentes confirmando
        const sourceBonus = Math.min(0.3, (sourceCount - 1) * 0.1);
        
        // Penalización por conflictos entre fuentes
        const conflictPenalty = this.calculateSourceConflictPenalty(recommendation);
        
        return Math.max(0, Math.min(1, 0.7 + sourceBonus - conflictPenalty));
    }
    
    calculateTemporalScore(recommendation, marketContext) {
        const currentTime = Date.now();
        const recommendationAge = currentTime - (recommendation.timestamp || currentTime);
        const ageHours = recommendationAge / (1000 * 60 * 60);
        
        // Score temporal basado en frescura de datos
        const freshnessScore = Math.max(0, 1 - (ageHours / 24));
        
        // Momentum temporal basado en cambios recientes
        const momentumScore = this.calculateMomentumScore(recommendation);
        
        return (freshnessScore * 0.6 + momentumScore * 0.4);
    }
    
    calculateQuantumCoherence(recommendation) {
        const quantumScore = recommendation.metrics?.quantumScore || 0;
        const brainScore = recommendation.metrics?.brainScore || 0;
        
        // Coherencia entre scores cuánticos
        const scoreCoherence = 1 - Math.abs(quantumScore - brainScore) / 100;
        
        // Coherencia temporal usando constantes cuánticas
        const temporalCoherence = this.calculateTemporalCoherence(recommendation);
        
        return Math.max(0, Math.min(1, (scoreCoherence * 0.7 + temporalCoherence * 0.3)));
    }
    
    calculateRiskAdjustedScore(recommendation) {
        const baseScore = recommendation.consolidatedScore || 0;
        const volatility = recommendation.metrics?.volatility || 0.5;
        const volume = recommendation.metrics?.volume || 0;
        
        // Ajuste por volatilidad (mayor volatilidad = mayor riesgo)
        const volatilityAdjustment = Math.max(0, 1 - volatility);
        
        // Ajuste por liquidez (mayor volumen = menor riesgo)
        const liquidityAdjustment = Math.min(1, volume / 1000000);
        
        return Math.max(0, Math.min(1, (baseScore / 100) * 0.6 + volatilityAdjustment * 0.2 + liquidityAdjustment * 0.2));
    }
    
    calculateMarketRegimeScore(recommendation, marketContext) {
        const regime = marketContext.currentRegime || 'NEUTRAL';
        const recommendationDirection = recommendation.bestRecommendation?.action || 'NEUTRAL';
        
        // Alineación con el régimen actual
        const regimeAlignment = this.calculateRegimeAlignment(regime, recommendationDirection);
        
        // Adaptabilidad del score al régimen
        const regimeAdaptability = this.calculateRegimeAdaptability(recommendation, regime);
        
        return (regimeAlignment * 0.6 + regimeAdaptability * 0.4);
    }
    
    calculateConfidenceScore(recommendation) {
        const avgConfidence = recommendation.averageConfidence || 0;
        const sourceCount = recommendation.metrics?.sourceCount || 1;
        
        // Confianza base
        const baseConfidence = avgConfidence / 100;
        
        // Bonus por múltiples fuentes
        const sourceBonus = Math.min(0.2, (sourceCount - 1) * 0.05);
        
        // Penalización por baja confianza
        const lowConfidencePenalty = avgConfidence < 50 ? 0.1 : 0;
        
        return Math.max(0, Math.min(1, baseConfidence + sourceBonus - lowConfidencePenalty));
    }
    
    calculateExecutionScore(recommendation) {
        const volume = recommendation.metrics?.volume || 0;
        const spread = recommendation.metrics?.spread || 0.001;
        const price = recommendation.metrics?.price || 1;
        
        // Score de ejecución basado en liquidez y spread
        const liquidityScore = Math.min(1, volume / 1000000);
        const spreadScore = Math.max(0, 1 - (spread / price) * 1000);
        
        return (liquidityScore * 0.7 + spreadScore * 0.3);
    }
    
    calculateQuantumWeights(marketContext) {
        const regime = marketContext.currentRegime || 'NEUTRAL';
        const volatility = marketContext.volatility || 0.5;
        const phi = this.quantumConstants.phi;
        
        const baseWeights = this.regimeWeights[regime] || this.regimeWeights['NEUTRAL'];
        
        // Aplicar proporción áurea para refinamiento
        return this.applyGoldenRatioRefinement(baseWeights, phi, volatility);
    }
    
    applyGoldenRatioRefinement(baseWeights, phi, volatility) {
        const refinedWeights = {};
        const totalWeight = Object.values(baseWeights).reduce((sum, weight) => sum + weight, 0);
        
        Object.entries(baseWeights).forEach(([dimension, weight]) => {
            // Aplicar refinamiento áureo
            const goldenRefinement = weight * phi / totalWeight;
            
            // Ajustar por volatilidad
            const volatilityAdjustment = volatility > 0.7 ? 1.1 : volatility < 0.3 ? 0.9 : 1.0;
            
            refinedWeights[dimension] = Math.max(0, goldenRefinement * volatilityAdjustment);
        });
        
        // Normalizar pesos
        const newTotal = Object.values(refinedWeights).reduce((sum, weight) => sum + weight, 0);
        Object.keys(refinedWeights).forEach(dimension => {
            refinedWeights[dimension] /= newTotal;
        });
        
        return refinedWeights;
    }
    
    buildCoherenceMatrix(dimensionalScores) {
        const dimensions = Object.keys(dimensionalScores);
        const coherenceMatrix = {};
        
        // Calcular coherencia entre dimensiones
        let totalCoherence = 0;
        let coherencePairs = 0;
        
        for (let i = 0; i < dimensions.length; i++) {
            for (let j = i + 1; j < dimensions.length; j++) {
                const dim1 = dimensions[i];
                const dim2 = dimensions[j];
                const score1 = dimensionalScores[dim1];
                const score2 = dimensionalScores[dim2];
                
                // Coherencia como similitud de scores
                const coherence = 1 - Math.abs(score1 - score2);
                coherenceMatrix[`${dim1}_${dim2}`] = coherence;
                
                totalCoherence += coherence;
                coherencePairs++;
            }
        }
        
        const averageCoherence = coherencePairs > 0 ? totalCoherence / coherencePairs : 0;
        
        return {
            coherence: averageCoherence,
            entanglement: this.calculateEntanglement(dimensionalScores),
            superposition: this.calculateSuperposition(dimensionalScores),
            matrix: coherenceMatrix
        };
    }
    
    calculateEntanglement(dimensionalScores) {
        const scores = Object.values(dimensionalScores);
        const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
        
        // Entanglement como medida de correlación entre dimensiones
        return Math.max(0, 1 - Math.sqrt(variance));
    }
    
    calculateSuperposition(dimensionalScores) {
        const scores = Object.values(dimensionalScores);
        const maxScore = Math.max(...scores);
        const minScore = Math.min(...scores);
        
        // Superposición como rango de variación
        return Math.max(0, 1 - (maxScore - minScore));
    }
    
    applySuperpositionPrinciple(dimensionalScores, quantumWeights, coherenceMatrix) {
        let quantumScore = 0;
        let totalWeight = 0;
        
        Object.entries(dimensionalScores).forEach(([dimension, score]) => {
            const weight = quantumWeights[dimension] || 0;
            quantumScore += score * weight;
            totalWeight += weight;
        });
        
        // Aplicar factor de coherencia cuántica
        const coherenceFactor = coherenceMatrix.coherence;
        const entanglementFactor = coherenceMatrix.entanglement;
        const superpositionFactor = coherenceMatrix.superposition;
        
        // Score final con factores cuánticos
        const finalScore = (quantumScore / totalWeight) * 
                          (0.6 + 0.2 * coherenceFactor + 0.1 * entanglementFactor + 0.1 * superpositionFactor);
        
        return Math.max(0, Math.min(1, finalScore));
    }
    
    calculateScoreConfidence(dimensionalScores) {
        const scores = Object.values(dimensionalScores);
        const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
        
        // Confianza inversamente proporcional a la varianza
        return Math.max(0, Math.min(1, 1 - Math.sqrt(variance)));
    }
    
    generateScoreExplanation(dimensionalScores, quantumScore) {
        const topDimensions = Object.entries(dimensionalScores)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 3);
        
        return {
            quantumScore: quantumScore,
            topContributors: topDimensions.map(([dim, score]) => ({
                dimension: dim,
                score: score,
                contribution: (score / quantumScore * 100).toFixed(1) + '%'
            })),
            scoreBreakdown: dimensionalScores
        };
    }
    
    // Métodos auxiliares
    calculateSourceConflictPenalty(recommendation) {
        // Implementar lógica para detectar conflictos entre fuentes
        return 0; // Placeholder
    }
    
    calculateMomentumScore(recommendation) {
        // Implementar cálculo de momentum temporal
        return 0.5; // Placeholder
    }
    
    calculateTemporalCoherence(recommendation) {
        // Implementar coherencia temporal usando constantes cuánticas
        return 0.7; // Placeholder
    }
    
    calculateRegimeAlignment(regime, direction) {
        // Implementar alineación con régimen de mercado
        return 0.8; // Placeholder
    }
    
    calculateRegimeAdaptability(recommendation, regime) {
        // Implementar adaptabilidad al régimen
        return 0.6; // Placeholder
    }
}

class QuantumRankingSystem {
    constructor() {
        this.rankingFactors = {
            quantumScore: { weight: 0.25, calculator: this.calculateQuantumScore.bind(this) },
            temporalMomentum: { weight: 0.20, calculator: this.calculateTemporalMomentum.bind(this) },
            crossValidation: { weight: 0.18, calculator: this.calculateCrossValidation.bind(this) },
            marketContext: { weight: 0.15, calculator: this.calculateMarketContextScore.bind(this) },
            successProbability: { weight: 0.12, calculator: this.calculateSuccessProbability.bind(this) },
            quantumSurprise: { weight: 0.10, calculator: this.calculateQuantumSurprise.bind(this) }
        };
        this.quantumScoringEngine = new QuantumScoringEngine();
    }
    
    generateAdvancedRanking(recommendations, marketContext) {
        console.log(`🧠 [QUANTUM RANKING V7] Iniciando ranking avanzado para ${recommendations.length} recomendaciones`);
        
        const enrichedRecommendations = recommendations.map(rec => {
            const factors = {};
            const factorDetails = {};
            
            Object.entries(this.rankingFactors).forEach(([factorName, config]) => {
                const result = config.calculator(rec, marketContext, recommendations);
                factors[factorName] = result.score * config.weight;
                factorDetails[factorName] = result;
            });
            
            const compositeScore = this.calculateCompositeScore(factors);
            const uncertaintyMetrics = this.calculateUncertaintyMetrics(factorDetails);
            const rankingConfidence = this.calculateRankingConfidence(factors, uncertaintyMetrics);
            
            return {
                ...rec,
                rankingScore: compositeScore,
                rankingFactors: factors,
                factorDetails: factorDetails,
                uncertaintyMetrics: uncertaintyMetrics,
                rankingConfidence: rankingConfidence,
                quantumSignature: this.generateQuantumSignature(factors)
            };
        });
        
        const rankedRecommendations = this.performMultiCriteriaRanking(enrichedRecommendations, marketContext);
        const optimizedRanking = this.optimizeRankingDistribution(rankedRecommendations);
        
        console.log(`[OK] [QUANTUM RANKING V7] Ranking completado: ${optimizedRanking.length} recomendaciones rankeadas`);
        
        return {
            rankedRecommendations: optimizedRanking,
            rankingMetadata: this.generateRankingMetadata(optimizedRanking, marketContext),
            qualityAssessment: this.assessRankingQuality(optimizedRanking),
            adaptiveInsights: this.generateAdaptiveInsights(optimizedRanking, marketContext)
        };
    }
    
    calculateQuantumScore(recommendation, marketContext, allRecommendations) {
        const quantumResult = this.quantumScoringEngine.calculateQuantumScore(recommendation, marketContext);
        return {
            score: quantumResult.finalScore,
            details: quantumResult,
            confidence: quantumResult.confidence,
            explanation: quantumResult.explanation
        };
    }
    
    calculateTemporalMomentum(recommendation, marketContext, allRecommendations) {
        const currentTime = Date.now();
        const recommendationAge = currentTime - (recommendation.timestamp || currentTime);
        const ageHours = recommendationAge / (1000 * 60 * 60);
        const freshnessMomentum = Math.max(0, 1 - (ageHours / 24));
        const priceMomentum = Math.max(0, Math.min(1, Math.abs(recommendation.metrics?.priceChange || 0) / 10));
        const volumeMomentum = Math.min(1, (recommendation.metrics?.volume || 0) / 1000000);
        
        const momentumScore = freshnessMomentum * 0.4 + priceMomentum * 0.3 + volumeMomentum * 0.3;
        
        return {
            score: Math.max(0, Math.min(1, momentumScore)),
            components: { freshness: freshnessMomentum, price: priceMomentum, volume: volumeMomentum },
            trendDirection: priceMomentum > 0.5 ? 'bullish' : 'bearish',
            momentumStrength: momentumScore > 0.8 ? 'STRONG' : momentumScore > 0.6 ? 'MODERATE' : 'WEAK',
            timeframe: '24h_momentum'
        };
    }
    
    calculateCrossValidation(recommendation, marketContext, allRecommendations) {
        const symbol = recommendation.symbol;
        const relatedRecs = allRecommendations.filter(r => r.symbol === symbol);
        
        if (relatedRecs.length < 2) {
            return { score: 0.5, agreement: 'insufficient_data', sourceCount: relatedRecs.length };
        }
        
        const scoreAgreement = this.calculateScoreAgreement(relatedRecs);
        const directionAgreement = this.calculateDirectionAgreement(relatedRecs);
        const crossValidationScore = scoreAgreement * 0.6 + directionAgreement * 0.4;
        
        return {
            score: crossValidationScore,
            agreement: crossValidationScore > 0.8 ? 'HIGH' : crossValidationScore > 0.6 ? 'MODERATE' : 'LOW',
            details: { scoreAgreement, directionAgreement }
        };
    }
    
    calculateMarketContextScore(recommendation, marketContext, allRecommendations) {
        const regime = marketContext.currentRegime || 'NEUTRAL';
        const volatility = marketContext.volatility || 0.5;
        const recommendationDirection = recommendation.bestRecommendation?.action || 'NEUTRAL';
        
        const regimeAlignment = 0.8; // Placeholder
        const volatilityAdaptability = Math.max(0, 1 - volatility);
        const temporalContext = 0.6; // Placeholder
        
        const contextScore = regimeAlignment * 0.4 + volatilityAdaptability * 0.3 + temporalContext * 0.3;
        
        return {
            score: Math.max(0, Math.min(1, contextScore)),
            regimeAlignment,
            volatilityAdaptability,
            temporalContext,
            marketConditions: { regime, volatility, direction: recommendationDirection }
        };
    }
    
    calculateSuccessProbability(recommendation, marketContext, allRecommendations) {
        const baseScore = recommendation.consolidatedScore || 0;
        const confidence = recommendation.averageConfidence || 0;
        const volume = recommendation.metrics?.volume || 0;
        const volatility = recommendation.metrics?.volatility || 0.5;
        
        const baseProbability = baseScore / 100;
        const confidenceFactor = confidence / 100;
        const liquidityFactor = Math.min(1, volume / 1000000);
        const riskFactor = Math.max(0, 1 - volatility);
        
        const successProbability = baseProbability * 0.4 + confidenceFactor * 0.3 + liquidityFactor * 0.2 + riskFactor * 0.1;
        
        return {
            score: Math.max(0, Math.min(1, successProbability)),
            components: { baseProbability, confidenceFactor, liquidityFactor, riskFactor },
            riskLevel: volatility > 0.8 ? 'HIGH' : volatility > 0.5 ? 'MEDIUM' : 'LOW',
            expectedROI: successProbability * 0.1
        };
    }
    
    calculateQuantumSurprise(recommendation, marketContext, allRecommendations) {
        const quantumScore = recommendation.metrics?.quantumScore || 0;
        const brainScore = recommendation.metrics?.brainScore || 0;
        const avgQuantumScore = this.calculateAverageQuantumScore(allRecommendations);
        
        const quantumDeviation = Math.abs(quantumScore - avgQuantumScore) / 100;
        const quantumCoherence = 1 - Math.abs(quantumScore - brainScore) / 100;
        const temporalSurprise = 0.5; // Placeholder
        
        const surpriseScore = quantumDeviation * 0.4 + quantumCoherence * 0.3 + temporalSurprise * 0.3;
        
        return {
            score: Math.max(0, Math.min(1, surpriseScore)),
            quantumDeviation,
            quantumCoherence,
            temporalSurprise,
            surpriseType: surpriseScore > 0.8 ? 'QUANTUM_ANOMALY' : surpriseScore > 0.6 ? 'TEMPORAL_SURPRISE' : 'EXPECTED'
        };
    }
    
    calculateCompositeScore(factors) {
        const totalScore = Object.values(factors).reduce((sum, score) => sum + score, 0);
        return Math.max(0, Math.min(1, totalScore));
    }
    
    calculateUncertaintyMetrics(factorDetails) {
        const uncertainties = Object.values(factorDetails).map(detail => detail.confidence || 0.5);
        const avgUncertainty = uncertainties.reduce((sum, u) => sum + u, 0) / uncertainties.length;
        
        return {
            averageUncertainty: avgUncertainty,
            uncertaintyRange: Math.max(...uncertainties) - Math.min(...uncertainties),
            confidenceLevel: 1 - avgUncertainty
        };
    }
    
    calculateRankingConfidence(factors, uncertaintyMetrics) {
        const factorScores = Object.values(factors);
        const scoreVariance = this.calculateVariance(factorScores);
        const uncertaintyFactor = uncertaintyMetrics.averageUncertainty;
        const confidence = Math.max(0, Math.min(1, 1 - (scoreVariance + uncertaintyFactor) / 2));
        return confidence;
    }
    
    generateQuantumSignature(factors) {
        const factorNames = Object.keys(factors);
        const factorValues = Object.values(factors);
        const signature = factorNames.map((name, index) => ({
            factor: name,
            weight: factorValues[index],
            normalizedWeight: factorValues[index] / Math.max(...factorValues)
        }));
        
        return {
            signature,
            hash: signature.map(s => s.factor + s.weight).join('_'),
            uniqueness: 0.8
        };
    }
    
    performMultiCriteriaRanking(enrichedRecommendations, marketContext) {
        const sortedRecommendations = enrichedRecommendations.sort((a, b) => {
            if (Math.abs(a.rankingScore - b.rankingScore) > 0.01) {
                return b.rankingScore - a.rankingScore;
            }
            if (Math.abs(a.rankingConfidence - b.rankingConfidence) > 0.01) {
                return b.rankingConfidence - a.rankingConfidence;
            }
            const aSources = a.metrics?.sourceCount || 1;
            const bSources = b.metrics?.sourceCount || 1;
            return bSources - aSources;
        });
        
        sortedRecommendations.forEach((rec, index) => {
            rec.finalRank = index + 1;
            rec.rankingTier = this.assignRankingTier(index, sortedRecommendations.length);
        });
        
        return sortedRecommendations;
    }
    
    optimizeRankingDistribution(rankedRecommendations) {
        const optimized = rankedRecommendations.map((rec, index) => {
            const optimizationFactor = 1.0; // Placeholder
            const optimizedScore = rec.rankingScore * optimizationFactor;
            
            return {
                ...rec,
                optimizedScore,
                optimizationFactor,
                finalRank: index + 1
            };
        });
        
        return optimized;
    }
    
    generateRankingMetadata(rankedRecommendations, marketContext) {
        const totalRecommendations = rankedRecommendations.length;
        const avgScore = rankedRecommendations.reduce((sum, rec) => sum + rec.rankingScore, 0) / totalRecommendations;
        const avgConfidence = rankedRecommendations.reduce((sum, rec) => sum + rec.rankingConfidence, 0) / totalRecommendations;
        
        return {
            totalRecommendations,
            averageScore: avgScore,
            averageConfidence: avgConfidence,
            marketRegime: marketContext.currentRegime,
            rankingTimestamp: Date.now(),
            qualityMetrics: { averageScore: 0.7, scoreVariance: 0.1, confidenceLevel: 0.8 }
        };
    }
    
    assessRankingQuality(rankedRecommendations) {
        const scores = rankedRecommendations.map(rec => rec.rankingScore);
        const confidences = rankedRecommendations.map(rec => rec.rankingConfidence);
        
        return {
            scoreDistribution: { mean: scores.reduce((sum, s) => sum + s, 0) / scores.length, variance: 0.1, skewness: 0.1 },
            confidenceDistribution: { mean: confidences.reduce((sum, c) => sum + c, 0) / confidences.length, variance: 0.1, reliability: 0.8 },
            rankingStability: 0.9,
            overallQuality: (scores.reduce((sum, s) => sum + s, 0) / scores.length + confidences.reduce((sum, c) => sum + c, 0) / confidences.length) / 2
        };
    }
    
    generateAdaptiveInsights(rankedRecommendations, marketContext) {
        const insights = [];
        const avgScore = rankedRecommendations.reduce((sum, rec) => sum + rec.rankingScore, 0) / rankedRecommendations.length;
        
        if (avgScore < 0.6) {
            insights.push({
                type: 'warning',
                category: 'quality',
                message: 'Scores promedio bajos detectados',
                recommendation: 'Revisar criterios de filtrado'
            });
        }
        
        const uniqueSymbols = new Set(rankedRecommendations.map(rec => rec.symbol)).size;
        if (uniqueSymbols < rankedRecommendations.length * 0.8) {
            insights.push({
                type: 'alert',
                category: 'diversification',
                message: 'Concentración excesiva en pocos símbolos',
                recommendation: 'Considerar diversificación adicional'
            });
        }
        
        return {
            insights,
            overallAssessment: { quality: 'GOOD', confidence: 'HIGH', recommendations: 'PROCEED_WITH_CAUTION' },
            actionableRecommendations: insights.map(insight => ({
                action: insight.recommendation,
                priority: insight.type === 'alert' ? 'HIGH' : 'MEDIUM',
                timeframe: 'IMMEDIATE'
            }))
        };
    }
    
    // Métodos auxiliares
    calculateScoreAgreement(relatedRecs) {
        const scores = relatedRecs.map(rec => rec.consolidatedScore || 0);
        const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
        return Math.max(0, 1 - Math.sqrt(variance) / 100);
    }
    
    calculateDirectionAgreement(relatedRecs) {
        const directions = relatedRecs.map(rec => rec.bestRecommendation?.action || 'NEUTRAL');
        const longCount = directions.filter(d => d === 'LONG').length;
        const shortCount = directions.filter(d => d === 'SHORT').length;
        const total = directions.length;
        if (total === 0) return 0.5;
        return Math.max(longCount, shortCount) / total;
    }
    
    calculateAverageQuantumScore(allRecommendations) {
        const quantumScores = allRecommendations.map(rec => rec.metrics?.quantumScore || 0);
        return quantumScores.reduce((sum, score) => sum + score, 0) / quantumScores.length;
    }
    
    calculateVariance(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    }
    
    assignRankingTier(index, total) {
        const percentage = (index + 1) / total;
        if (percentage <= 0.05) return 'TIER_QUANTUM';
        if (percentage <= 0.15) return 'TIER_GOLDEN';
        if (percentage <= 0.35) return 'TIER_PRIME';
        if (percentage <= 0.60) return 'TIER_STANDARD';
        return 'TIER_SPECULATIVE';
    }
}

module.exports = { QuantumScoringEngine, QuantumRankingSystem, QUANTUM_CONSTANTS_V7 };
