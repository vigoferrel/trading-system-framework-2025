const axios = require('axios');

console.log('üî¨ PRUEBA DE CACHE CU√ÅNTICA - BANDA 46');
console.log('=' .repeat(60));

// Funci√≥n para verificar m√©tricas cu√°nticas
async function verificarMetricasCuanticas() {
    console.log('\n[DATA] VERIFICANDO M√âTRICAS CU√ÅNTICAS...');
    
    try {
        const response = await axios.get('http://localhost:4602/api/quantum-metrics', { timeout: 5000 });
        
        if (response.data.success) {
            const metrics = response.data.data;
            
            console.log('[OK] M√©tricas cu√°nticas obtenidas:');
            console.log(`   Estados cu√°nticos:`);
            console.log(`     SPOT: ${metrics.quantumStates.spot}`);
            console.log(`     FUTURES: ${metrics.quantumStates.futures}`);
            console.log(`     OPTIONS: ${metrics.quantumStates.options}`);
            
            console.log(`\n   M√©tricas de FUTURES:`);
            console.log(`     Hit Rate: ${metrics.futures.hitRate}`);
            console.log(`     Miss Rate: ${metrics.futures.missRate}`);
            console.log(`     Total Requests: ${metrics.futures.totalRequests}`);
            console.log(`     Rate Limits: ${metrics.futures.rateLimitCount}`);
            
            console.log(`\n   Estado de cach√© FUTURES:`);
            console.log(`     Edad: ${Math.floor(metrics.cacheStatus.futures.cacheAge / 1000)}s`);
            console.log(`     Datos: ${metrics.cacheStatus.futures.dataCount} s√≠mbolos`);
            
            return true;
        }
    } catch (error) {
        console.log('[ERROR] Error obteniendo m√©tricas cu√°nticas:', error.message);
        return false;
    }
}

// Funci√≥n para probar m√∫ltiples llamadas a la API
async function probarLlamadasMultiples() {
    console.log('\n[RELOAD] PROBANDO LLLAMADAS M√öLTIPLES...');
    
    const llamadas = 5;
    console.log(`   Realizando ${llamadas} llamadas consecutivas...`);
    
    for (let i = 1; i <= llamadas; i++) {
        try {
            const startTime = Date.now();
            const response = await axios.get('http://localhost:4602/api/futures-data', { timeout: 5000 });
            const endTime = Date.now();
            
            if (response.data.success) {
                console.log(`   Llamada ${i}: [OK] ${response.data.data.length} s√≠mbolos (${endTime - startTime}ms)`);
            } else {
                console.log(`   Llamada ${i}: [ERROR] Error en respuesta`);
            }
            
            // Peque√±a pausa entre llamadas
            await new Promise(resolve => setTimeout(resolve, 1000));
            
        } catch (error) {
            console.log(`   Llamada ${i}: [ERROR] Error: ${error.message}`);
        }
    }
}

// Funci√≥n para verificar que la cach√© no se limpia autom√°ticamente
async function verificarPersistenciaCache() {
    console.log('\nüíæ VERIFICANDO PERSISTENCIA DE CACHE...');
    
    try {
        // Primera llamada
        const response1 = await axios.get('http://localhost:4602/api/futures-data', { timeout: 5000 });
        
        if (response1.data.success) {
            console.log('[OK] Primera llamada exitosa');
            
            // Segunda llamada inmediata
            const response2 = await axios.get('http://localhost:4602/api/futures-data', { timeout: 5000 });
            
            if (response2.data.success) {
                console.log('[OK] Segunda llamada exitosa');
                
                // Verificar que ambas respuestas son similares (misma cach√©)
                const data1 = response1.data.data;
                const data2 = response2.data.data;
                
                if (data1.length === data2.length) {
                    console.log('[OK] Cache persistente - Misma cantidad de datos');
                    
                    // Verificar m√©tricas para confirmar uso de cach√©
                    const metricsResponse = await axios.get('http://localhost:4602/api/quantum-metrics', { timeout: 5000 });
                    if (metricsResponse.data.success) {
                        const hitRate = metricsResponse.data.data.futures.hitRate;
                        const totalRequests = metricsResponse.data.data.futures.totalRequests;
                        
                        if (hitRate > 0) {
                            console.log(`[OK] Cache funcionando - Hit Rate: ${hitRate}/${totalRequests}`);
                        } else {
                            console.log('[WARNING] Cache no detectada - Verificar implementaci√≥n');
                        }
                    }
                } else {
                    console.log('[ERROR] Cache inconsistente - Diferente cantidad de datos');
                }
            }
        }
    } catch (error) {
        console.log('[ERROR] Error verificando persistencia:', error.message);
    }
}

// Funci√≥n principal
async function pruebaCompleta() {
    console.log('[START] Iniciando prueba completa de cach√© cu√°ntica...\n');
    
    // Verificar que QBTC Core est√© activo
    try {
        await axios.get('http://localhost:4602/health', { timeout: 3000 });
        console.log('[OK] QBTC Core est√° activo');
    } catch (error) {
        console.log('[ERROR] QBTC Core no est√° activo - Ejecutar: node core-system-organized.js');
        return;
    }
    
    // Ejecutar pruebas
    await verificarMetricasCuanticas();
    await probarLlamadasMultiples();
    await verificarPersistenciaCache();
    
    console.log('\n' + '=' .repeat(60));
    console.log('üèÅ PRUEBA COMPLETADA');
    console.log('\nüìù RESULTADOS:');
    console.log('1. Si las m√©tricas muestran hit rate > 0, la cach√© est√° funcionando');
    console.log('2. Si las llamadas m√∫ltiples son r√°pidas, la cach√© est√° activa');
    console.log('3. Si no hay rate limiting, la protecci√≥n est√° funcionando');
}

// Ejecutar prueba
pruebaCompleta().catch(error => {
    console.error('[ERROR] Error durante la prueba:', error.message);
});
