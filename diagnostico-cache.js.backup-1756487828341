const axios = require('axios');

console.log('üîç DIAGN√ìSTICO DE CACHE Y RATE LIMITING - BANDA 46');
console.log('=' .repeat(60));

// Funci√≥n para verificar el estado de la cach√©
async function verificarCache() {
    console.log('\nüìä VERIFICANDO ESTADO DE CACHE...');
    
    try {
        // Verificar QBTC Core
        const qbtcResponse = await axios.get('http://localhost:4602/health', { timeout: 5000 });
        console.log('‚úÖ QBTC Core est√° activo');
        
        // Verificar datos de futuros
        const futuresResponse = await axios.get('http://localhost:4602/api/futures-data', { timeout: 5000 });
        console.log('‚úÖ Datos de futuros disponibles');
        
        // Verificar timestamp de la cach√©
        if (futuresResponse.data && futuresResponse.data.cacheStatus) {
            console.log(`üìÖ Estado de cach√©: ${futuresResponse.data.cacheStatus}`);
        }
        
        return true;
    } catch (error) {
        console.log('‚ùå QBTC Core no est√° activo o no responde');
        return false;
    }
}

// Funci√≥n para verificar rate limiting directo con Binance
async function verificarRateLimiting() {
    console.log('\nüö¶ VERIFICANDO RATE LIMITING CON BINANCE...');
    
    try {
        const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=BTCUSDT', {
            timeout: 10000,
            headers: {
                'User-Agent': 'QBTC-Diagnostic/1.0',
                'Accept': 'application/json'
            }
        });
        
        console.log('‚úÖ Conexi√≥n directa a Binance exitosa');
        console.log(`üìä Datos recibidos: ${response.data.symbol} - Precio: $${response.data.lastPrice}`);
        
        // Verificar headers de rate limiting
        const rateLimitHeaders = {
            'X-MBX-USED-WEIGHT-1M': response.headers['x-mbx-used-weight-1m'],
            'X-MBX-ORDER-COUNT-1M': response.headers['x-mbx-order-count-1m'],
            'Retry-After': response.headers['retry-after']
        };
        
        console.log('üìã Headers de rate limiting:', rateLimitHeaders);
        
        return true;
    } catch (error) {
        if (error.response) {
            console.log(`‚ùå Error de Binance: ${error.response.status} - ${error.response.statusText}`);
            
            if (error.response.status === 418) {
                console.log('üö® RATE LIMITING DETECTADO - Binance est√° bloqueando requests');
                if (error.response.headers['retry-after']) {
                    console.log(`‚è∞ Tiempo de espera sugerido: ${error.response.headers['retry-after']} segundos`);
                }
            }
        } else {
            console.log(`‚ùå Error de conexi√≥n: ${error.message}`);
        }
        return false;
    }
}

// Funci√≥n para verificar el estado de todos los servicios
async function verificarServicios() {
    console.log('\nüîß VERIFICANDO ESTADO DE SERVICIOS...');
    
    const servicios = [
        { nombre: 'QBTC Core', puerto: 4602, endpoint: '/health' },
        { nombre: 'Monitor de Gr√°ficos', puerto: 4606, endpoint: '/health' },
        { nombre: 'SRONA API', puerto: 4601, endpoint: '/health' },
        { nombre: 'Frontend API', puerto: 4603, endpoint: '/health' },
        { nombre: 'Vigo Futures', puerto: 4604, endpoint: '/health' },
        { nombre: 'Dashboard QBTC', puerto: 4605, endpoint: '/health' }
    ];
    
    for (const servicio of servicios) {
        try {
            const response = await axios.get(`http://localhost:${servicio.puerto}${servicio.endpoint}`, { timeout: 3000 });
            console.log(`‚úÖ ${servicio.nombre} (puerto ${servicio.puerto}): ACTIVO`);
        } catch (error) {
            console.log(`‚ùå ${servicio.nombre} (puerto ${servicio.puerto}): NO ACTIVO`);
        }
    }
}

// Funci√≥n para verificar la configuraci√≥n de cach√© en el c√≥digo
function verificarConfiguracionCache() {
    console.log('\n‚öôÔ∏è VERIFICANDO CONFIGURACI√ìN DE CACHE...');
    
    // Simular la configuraci√≥n actual
    const cacheConfig = {
        spot: { cacheTime: 2000 }, // 2 segundos
        futures: { cacheTime: 600000 }, // 10 minutos
        options: { cacheTime: 5000 } // 5 segundos
    };
    
    console.log('üìã Configuraci√≥n actual de cach√©:');
    console.log(`   SPOT: ${cacheConfig.spot.cacheTime}ms (${cacheConfig.spot.cacheTime/1000}s)`);
    console.log(`   FUTURES: ${cacheConfig.futures.cacheTime}ms (${cacheConfig.futures.cacheTime/60000}min)`);
    console.log(`   OPTIONS: ${cacheConfig.options.cacheTime}ms (${cacheConfig.options.cacheTime/1000}s)`);
    
    // Verificar si la configuraci√≥n es apropiada
    if (cacheConfig.futures.cacheTime < 300000) { // Menos de 5 minutos
        console.log('‚ö†Ô∏è ADVERTENCIA: Cache de futuros muy corta, puede causar rate limiting');
    } else {
        console.log('‚úÖ Cache de futuros configurada apropiadamente para evitar rate limiting');
    }
}

// Funci√≥n principal
async function diagnosticoCompleto() {
    console.log('üöÄ Iniciando diagn√≥stico completo...\n');
    
    // Verificar configuraci√≥n
    verificarConfiguracionCache();
    
    // Verificar servicios
    await verificarServicios();
    
    // Verificar rate limiting
    await verificarRateLimiting();
    
    // Verificar cach√©
    await verificarCache();
    
    console.log('\n' + '=' .repeat(60));
    console.log('üèÅ DIAGN√ìSTICO COMPLETADO');
    console.log('\nüìù RECOMENDACIONES:');
    console.log('1. Si QBTC Core no est√° activo, ejecutar: node core-system-organized.js');
    console.log('2. Si hay rate limiting, esperar antes de hacer m√°s requests');
    console.log('3. Verificar que la cach√© est√© funcionando correctamente');
    console.log('4. Si los servicios no est√°n activos, ejecutar: python deploy-banda-46-fixed.py');
}

// Ejecutar diagn√≥stico
diagnosticoCompleto().catch(error => {
    console.error('‚ùå Error durante el diagn√≥stico:', error.message);
});
