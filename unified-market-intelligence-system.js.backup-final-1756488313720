
// Constantes f√≠sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * üß† SISTEMA UNIFICADO DE INTELIGENCIA DE MERCADO
 * üî¨ UNIFIED MARKET INTELLIGENCE SYSTEM
 * ‚öõÔ∏è INTEGRACI√ìN COMPLETA CON QBTC-UNIFIED PRIME QUANTUM SYSTEM
 */

const { AdvancedMarketIntelligenceEngine } = require('./advanced-market-intelligence-engine');
const { QuantumNeuralPriceProjector } = require('./qbtc-unified-prime-quantum-system');
const axios = require('axios'); // Added axios for BinanceRealConnector

// üîó CONECTOR BINANCE REAL
class BinanceRealConnector {
    constructor() {
        this.baseURL = 'https://fapi.binance.com';
        this.rateLimit = { requests: 0, window: Date.now() };
    }

    static getInstance() {
        if (!BinanceRealConnector.instance) {
            BinanceRealConnector.instance = new BinanceRealConnector();
        }
        return BinanceRealConnector.instance;
    }

    async makeRequest(method, endpoint, params = {}) {
        try {
            const url = `${this.baseURL}${endpoint}`;
            const response = await axios({
                method,
                url,
                params,
                timeout: 10000
            });
            return response.data;
        } catch (error) {
            console.error(`[RED] [BINANCE] Error en ${endpoint}:`, error.message);
            return null;
        }
    }

    async getCurrentPrice(symbol) {
        try {
            const response = await this.makeRequest('GET', '/fapi/v1/ticker/price', { symbol });
            return response ? parseFloat(response.price) : null;
        } catch (error) {
            console.error(`[RED] [PRICE] Error obteniendo precio de ${symbol}:`, error.message);
            return null;
        }
    }
}

// üß† SISTEMA UNIFICADO DE INTELIGENCIA DE MERCADO
class UnifiedMarketIntelligenceSystem {
    constructor() {
        this.intelligenceEngine = new AdvancedMarketIntelligenceEngine();
        this.neuralProjector = new QuantumNeuralPriceProjector();
        this.binance = BinanceRealConnector.getInstance();
        
        // M√âTRICAS CU√ÅNTICAS REALES
        this.constants = {
            œÜ: 1.618033988749895,
            œÜ_inv: 0.618033988749895,
            Œª_888: 888,
            ‚Ñô_7919: 7919
        };
        
        // PESOS NEURALES PARA S√çNTESIS MAESTRA
        this.neuralWeights = {
            market_intelligence: 0.40,      // 40% - An√°lisis de mercado
            neural_projection: 0.35,        // 35% - Proyecciones neurales
            regime_analysis: 0.25           // 25% - An√°lisis de r√©gimen
        };
    }

    // AN√ÅLISIS MAESTRO UNIFICADO
    async generateMasterMarketAnalysis(symbol, timeHorizon = '30d') {
        console.log(`üß† [UNIFIED INTELLIGENCE] Generando an√°lisis maestro para ${symbol}...`);
        
        try {
            // OBTENER PRECIO ACTUAL PARA PROYECCIONES NEURALES
            const currentPrice = await this.binance.getCurrentPrice(symbol);
            
            // AN√ÅLISIS PARALELO DE TODOS LOS SISTEMAS
            const [
                marketIntelligence,
                neuralProjection,
                regimeAnalysis
            ] = await Promise.all([
                this.intelligenceEngine.generateCompleteMarketIntelligence(symbol, timeHorizon),
                this.neuralProjector.projectPricesWithTakeProfit(symbol, timeHorizon, currentPrice),
                this.intelligenceEngine.intelligenceSystems.marketRegime.analyze(symbol, timeHorizon)
            ]);

            // S√çNTESIS MAESTRA DE INTELIGENCIAS
            const masterIntelligence = this.synthesizeMasterIntelligence({
                market: marketIntelligence,
                neural: neuralProjection,
                regime: regimeAnalysis
            });

            // DECISI√ìN FINAL MAESTRA
            const finalMasterDecision = this.generateFinalMasterDecision(masterIntelligence, symbol);

            // RESUMEN EJECUTIVO
            const executiveSummary = this.generateExecutiveSummary(masterIntelligence, finalMasterDecision);

            return {
                symbol,
                analysis_timestamp: new Date().toISOString(),
                time_horizon: timeHorizon,
                
                // AN√ÅLISIS DETALLADO POR SISTEMA
                detailed_analysis: {
                    market_intelligence: marketIntelligence,
                    neural_projection: neuralProjection,
                    regime_analysis: regimeAnalysis
                },
                
                // S√çNTESIS MAESTRA
                master_intelligence: masterIntelligence,
                
                // DECISI√ìN FINAL
                final_master_decision: finalMasterDecision,
                
                // RESUMEN EJECUTIVO
                executive_summary: executiveSummary,
                
                // BOTTOM LINE
                bottom_line: this.generateBottomLine(finalMasterDecision, masterIntelligence)
            };
        } catch (error) {
            console.error('[RED] [UNIFIED INTELLIGENCE] Error:', error.message);
            throw error;
        }
    }

    // S√çNTESIS MAESTRA DE INTELIGENCIAS
    synthesizeMasterIntelligence(analysisData) {
        const weights = this.neuralWeights;
        const { œÜ, œÜ_inv } = this.constants;
        
        // EXTRACCI√ìN DE SE√ëALES CLAVE
        const marketSignals = this.extractMarketSignals(analysisData.market);
        const neuralSignals = this.extractNeuralSignals(analysisData.neural);
        const regimeSignals = this.extractRegimeSignals(analysisData.regime);
        
        // S√çNTESIS PONDERADA
        const weightedSynthesis = this.calculateWeightedSynthesis({
            market: { signals: marketSignals, weight: weights.market_intelligence },
            neural: { signals: neuralSignals, weight: weights.neural_projection },
            regime: { signals: regimeSignals, weight: weights.regime_analysis }
        });
        
        // C√ÅLCULO DE SCORES DIRECCIONALES
        const directionalScores = this.calculateDirectionalScores(weightedSynthesis);
        
        // AN√ÅLISIS DE CONFLUENCIA
        const confluenceAnalysis = this.analyzeConfluence(weightedSynthesis);
        
        // FORTALEZA COMPUESTA
        const compositeStrength = this.calculateCompositeStrength(directionalScores, confluenceAnalysis);
        
        // CONSENSO BULLISH/BEARISH
        const marketConsensus = this.calculateMarketConsensus(directionalScores);
        
        return {
            // SE√ëALES EXTRACTADAS
            extracted_signals: {
                market_signals: marketSignals,
                neural_signals: neuralSignals,
                regime_signals: regimeSignals
            },
            
            // S√çNTESIS PONDERADA
            weighted_synthesis: weightedSynthesis,
            
            // SCORES DIRECCIONALES
            directional_scores: directionalScores,
            
            // AN√ÅLISIS DE CONFLUENCIA
            confluence_analysis: confluenceAnalysis,
            
            // FORTALEZA COMPUESTA
            composite_strength: compositeStrength,
            
            // CONSENSO DE MERCADO
            market_consensus: marketConsensus,
            
            // FACTORES DE RIESGO
            risk_factors: this.identifyRiskFactors(analysisData),
            
            // AN√ÅLISIS DE TIMING
            timing_analysis: this.analyzeTiming(analysisData),
            
            // CONFIANZA GENERAL
            overall_confidence: this.calculateOverallConfidence(compositeStrength, confluenceAnalysis)
        };
    }

    // EXTRACCI√ìN DE SE√ëALES DE MERCADO
    extractMarketSignals(marketIntelligence) {
        const signals = [];
        const { œÜ } = this.constants;
        
        // SE√ëALES DE FUNDING
        if (marketIntelligence.detailed_intelligence?.funding_analysis?.funding_signal) {
            signals.push({
                type: 'FUNDING_RATE',
                direction: marketIntelligence.detailed_intelligence.funding_analysis.funding_signal,
                strength: marketIntelligence.detailed_intelligence.funding_analysis.intelligence_score.total_score * œÜ,
                confidence: marketIntelligence.detailed_intelligence.funding_analysis.intelligence_score.confidence
            });
        }
        
        // SE√ëALES DE WHALE
        if (marketIntelligence.detailed_intelligence?.whale_institutional?.whale_signal) {
            signals.push({
                type: 'WHALE_ACTIVITY',
                direction: marketIntelligence.detailed_intelligence.whale_institutional.whale_signal,
                strength: marketIntelligence.detailed_intelligence.whale_institutional.intelligence_score.total_score * œÜ,
                confidence: marketIntelligence.detailed_intelligence.whale_institutional.intelligence_score.confidence
            });
        }
        
        // SE√ëALES ESTACIONALES
        if (marketIntelligence.detailed_intelligence?.seasonal_patterns?.seasonal_signal) {
            signals.push({
                type: 'SEASONAL_PATTERN',
                direction: marketIntelligence.detailed_intelligence.seasonal_patterns.seasonal_signal,
                strength: marketIntelligence.detailed_intelligence.seasonal_patterns.intelligence_score.total_score * œÜ,
                confidence: marketIntelligence.detailed_intelligence.seasonal_patterns.intelligence_score.confidence
            });
        }
        
        return signals;
    }

    // EXTRACCI√ìN DE SE√ëALES NEURALES
    extractNeuralSignals(neuralProjection) {
        const signals = [];
        const { œÜ } = this.constants;
        
        if (neuralProjection.overall_confidence > 0.6) {
            signals.push({
                type: 'NEURAL_PROJECTION',
                direction: neuralProjection.overall_direction || 'NEUTRAL',
                strength: neuralProjection.overall_confidence * œÜ,
                confidence: neuralProjection.overall_confidence,
                timeframe: neuralProjection.analysis_timeframe
            });
        }
        
        return signals;
    }

    // EXTRACCI√ìN DE SE√ëALES DE R√âGIMEN
    extractRegimeSignals(regimeAnalysis) {
        const signals = [];
        const { œÜ } = this.constants;
        
        if (regimeAnalysis.composite_regime?.regime_signature) {
            const signature = regimeAnalysis.composite_regime.regime_signature;
            
            signals.push({
                type: 'MARKET_REGIME',
                direction: this.mapRegimeToDirection(signature),
                strength: regimeAnalysis.composite_regime.regime_strength * œÜ,
                confidence: regimeAnalysis.intelligence_score.confidence,
                regime_type: regimeAnalysis.composite_regime.composite_regime_name
            });
        }
        
        return signals;
    }

    // MAPEO DE R√âGIMEN A DIRECCI√ìN
    mapRegimeToDirection(regimeSignature) {
        const trend = regimeSignature.trend;
        const volatility = regimeSignature.volatility;
        
        if (trend.includes('UPTREND')) return 'LONG';
        if (trend.includes('DOWNTREND')) return 'SHORT';
        if (volatility === 'EXTREME_VOL') return 'AVOID';
        return 'NEUTRAL';
    }

    // C√ÅLCULO DE S√çNTESIS PONDERADA
    calculateWeightedSynthesis(weightedData) {
        const { œÜ } = this.constants;
        let totalLongStrength = 0;
        let totalShortStrength = 0;
        let totalNeutralStrength = 0;
        let totalConfidence = 0;
        
        // PROCESAR SE√ëALES DE MERCADO
        weightedData.market.signals.forEach(signal => {
            const weightedStrength = signal.strength * weightedData.market.weight;
            const weightedConfidence = signal.confidence * weightedData.market.weight;
            
            if (signal.direction === 'LONG') totalLongStrength += weightedStrength;
            else if (signal.direction === 'SHORT') totalShortStrength += weightedStrength;
            else totalNeutralStrength += weightedStrength;
            
            totalConfidence += weightedConfidence;
        });
        
        // PROCESAR SE√ëALES NEURALES
        weightedData.neural.signals.forEach(signal => {
            const weightedStrength = signal.strength * weightedData.neural.weight;
            const weightedConfidence = signal.confidence * weightedData.neural.weight;
            
            if (signal.direction === 'LONG') totalLongStrength += weightedStrength;
            else if (signal.direction === 'SHORT') totalShortStrength += weightedStrength;
            else totalNeutralStrength += weightedStrength;
            
            totalConfidence += weightedConfidence;
        });
        
        // PROCESAR SE√ëALES DE R√âGIMEN
        weightedData.regime.signals.forEach(signal => {
            const weightedStrength = signal.strength * weightedData.regime.weight;
            const weightedConfidence = signal.confidence * weightedData.regime.weight;
            
            if (signal.direction === 'LONG') totalLongStrength += weightedStrength;
            else if (signal.direction === 'SHORT') totalShortStrength += weightedStrength;
            else totalNeutralStrength += weightedStrength;
            
            totalConfidence += weightedConfidence;
        });
        
        return {
            long_strength: totalLongStrength * œÜ,
            short_strength: totalShortStrength * œÜ,
            neutral_strength: totalNeutralStrength,
            total_confidence: totalConfidence,
            dominant_direction: this.determineDominantDirection(totalLongStrength, totalShortStrength, totalNeutralStrength)
        };
    }

    // DETERMINACI√ìN DE DIRECCI√ìN DOMINANTE
    determineDominantDirection(long, short, neutral) {
        const { œÜ } = this.constants;
        const threshold = 0.3 * œÜ;
        
        if (long > short && long > threshold) return 'LONG';
        if (short > long && short > threshold) return 'SHORT';
        return 'NEUTRAL';
    }

    // C√ÅLCULO DE SCORES DIRECCIONALES
    calculateDirectionalScores(weightedSynthesis) {
        const { œÜ, œÜ_inv } = this.constants;
        
        return {
            bullish_score: weightedSynthesis.long_strength * œÜ,
            bearish_score: weightedSynthesis.short_strength * œÜ,
            neutral_score: weightedSynthesis.neutral_strength * œÜ_inv,
            directional_bias: this.calculateDirectionalBias(weightedSynthesis.long_strength, weightedSynthesis.short_strength)
        };
    }

    // C√ÅLCULO DE SESGO DIRECCIONAL
    calculateDirectionalBias(long, short) {
        const { œÜ } = this.constants;
        const total = long + short;
        if (total === 0) return 0;
        return ((long - short) / total) * œÜ;
    }

    // AN√ÅLISIS DE CONFLUENCIA
    analyzeConfluence(weightedSynthesis) {
        const { œÜ } = this.constants;
        const totalSignals = weightedSynthesis.total_confidence;
        const dominantDirection = weightedSynthesis.dominant_direction;
        
        return {
            signal_confluence: totalSignals * œÜ,
            directional_agreement: dominantDirection !== 'NEUTRAL' ? 0.8 * œÜ : 0.3,
            confluence_strength: Math.min(1.0, totalSignals * œÜ),
            confluence_quality: this.assessConfluenceQuality(weightedSynthesis)
        };
    }

    // EVALUACI√ìN DE CALIDAD DE CONFLUENCIA
    assessConfluenceQuality(weightedSynthesis) {
        const { œÜ } = this.constants;
        const strengthDiff = Math.abs(weightedSynthesis.long_strength - weightedSynthesis.short_strength);
        const totalStrength = weightedSynthesis.long_strength + weightedSynthesis.short_strength;
        
        if (totalStrength === 0) return 0.3;
        return Math.min(1.0, (strengthDiff / totalStrength) * œÜ);
    }

    // C√ÅLCULO DE FORTALEZA COMPUESTA
    calculateCompositeStrength(directionalScores, confluenceAnalysis) {
        const { œÜ } = this.constants;
        
        return {
            overall_strength: (directionalScores.bullish_score + directionalScores.bearish_score) * œÜ,
            confidence_level: confluenceAnalysis.confluence_strength,
            conviction_score: Math.min(1.0, confluenceAnalysis.signal_confluence * œÜ),
            reliability_index: confluenceAnalysis.confluence_quality
        };
    }

    // C√ÅLCULO DE CONSENSO DE MERCADO
    calculateMarketConsensus(directionalScores) {
        const { œÜ } = this.constants;
        const total = directionalScores.bullish_score + directionalScores.bearish_score + directionalScores.neutral_score;
        
        if (total === 0) return { consensus: 'NEUTRAL', strength: 0.3 };
        
        const bullishPct = directionalScores.bullish_score / total;
        const bearishPct = directionalScores.bearish_score / total;
        
        if (bullishPct > 0.6) return { consensus: 'BULLISH', strength: bullishPct * œÜ };
        if (bearishPct > 0.6) return { consensus: 'BEARISH', strength: bearishPct * œÜ };
        return { consensus: 'NEUTRAL', strength: 0.5 };
    }

    // IDENTIFICACI√ìN DE FACTORES DE RIESGO
    identifyRiskFactors(analysisData) {
        const risks = [];
        const { œÜ } = this.constants;
        
        // RIESGOS DE VOLATILIDAD
        if (analysisData.regime.individual_regimes?.volatility?.volatility_regime === 'EXTREME_VOL') {
            risks.push({
                type: 'EXTREME_VOLATILITY',
                severity: 'HIGH',
                impact: 'REDUCE_POSITION_SIZES',
                probability: 0.8 * œÜ
            });
        }
        
        // RIESGOS DE LIQUIDEZ
        if (analysisData.regime.individual_regimes?.liquidity?.liquidity_regime === 'ILLIQUID') {
            risks.push({
                type: 'LOW_LIQUIDITY',
                severity: 'MEDIUM',
                impact: 'AVOID_MARKET_ORDERS',
                probability: 0.6 * œÜ
            });
        }
        
        // RIESGOS DE CAMBIO DE R√âGIMEN
        if (analysisData.regime.regime_change_analysis?.regime_change_probability > 0.6) {
            risks.push({
                type: 'REGIME_CHANGE',
                severity: 'HIGH',
                impact: 'PREPARE_FOR_TRANSITION',
                probability: analysisData.regime.regime_change_analysis.regime_change_probability
            });
        }
        
        return risks;
    }

    // AN√ÅLISIS DE TIMING
    analyzeTiming(analysisData) {
        const { œÜ } = this.constants;
        
        return {
            optimal_entry_timing: this.determineOptimalTiming(analysisData),
            urgency_level: this.calculateUrgencyLevel(analysisData),
            patience_score: this.calculatePatienceScore(analysisData),
            timing_confidence: 0.7 * œÜ
        };
    }

    // DETERMINACI√ìN DE TIMING √ìPTIMO
    determineOptimalTiming(analysisData) {
        const regimeChange = analysisData.regime.regime_change_analysis;
        
        if (regimeChange?.regime_change_probability > 0.7) {
            return 'WAIT_FOR_REGIME_STABILIZATION';
        }
        
        return 'IMMEDIATE_OPPORTUNITY';
    }

    // C√ÅLCULO DE NIVEL DE URGENCIA
    calculateUrgencyLevel(analysisData) {
        const { œÜ } = this.constants;
        const neuralConfidence = analysisData.neural.overall_confidence;
        const regimeStability = analysisData.regime.composite_regime?.regime_stability;
        
        if (neuralConfidence > 0.8 && regimeStability > 0.7) {
            return 'HIGH_URGENCY';
        } else if (neuralConfidence > 0.6 && regimeStability > 0.5) {
            return 'MODERATE_URGENCY';
        }
        return 'LOW_URGENCY';
    }

    // C√ÅLCULO DE SCORE DE PACIENCIA
    calculatePatienceScore(analysisData) {
        const { œÜ_inv } = this.constants;
        const regimeChangeProb = analysisData.regime.regime_change_analysis?.regime_change_probability || 0;
        
        return Math.max(0.3, 1 - regimeChangeProb) * œÜ_inv;
    }

    // C√ÅLCULO DE CONFIANZA GENERAL
    calculateOverallConfidence(compositeStrength, confluenceAnalysis) {
        const { œÜ } = this.constants;
        return Math.min(0.95, (compositeStrength.confidence_level + confluenceAnalysis.confluence_quality) * œÜ);
    }

    // GENERACI√ìN DE DECISI√ìN FINAL MAESTRA
    generateFinalMasterDecision(masterIntelligence, symbol) {
        const { œÜ } = this.constants;
        const consensus = masterIntelligence.market_consensus;
        const strength = masterIntelligence.composite_strength;
        const risks = masterIntelligence.risk_factors;
        const timing = masterIntelligence.timing_analysis;
        
        // DETERMINAR ACCI√ìN PRINCIPAL
        let action = 'HOLD';
        let confidence = 0.5;
        let rationale = '';
        
        if (consensus.consensus === 'BULLISH' && consensus.strength > 0.6) {
            action = 'LONG';
            confidence = Math.min(0.9, consensus.strength * œÜ);
            rationale = `Strong bullish consensus with ${(consensus.strength * 100).toFixed(1)}% confidence`;
        } else if (consensus.consensus === 'BEARISH' && consensus.strength > 0.6) {
            action = 'SHORT';
            confidence = Math.min(0.9, consensus.strength * œÜ);
            rationale = `Strong bearish consensus with ${(consensus.strength * 100).toFixed(1)}% confidence`;
        }
        
        // AJUSTAR POR RIESGOS
        const riskAdjustment = this.calculateRiskAdjustment(risks);
        confidence = Math.max(0.3, confidence * riskAdjustment);
        
        // CALCULAR POSICI√ìN Y GESTI√ìN DE RIESGO
        const positionSize = this.calculatePositionSize(confidence, strength, risks);
        const stopLoss = this.calculateStopLoss(confidence, action, risks);
        const takeProfit = this.calculateTakeProfit(confidence, action, strength);
        
        return {
            action: action,
            confidence: confidence,
            rationale: rationale,
            risk_level: this.assessRiskLevel(risks),
            position_size: positionSize,
            stop_loss: stopLoss,
            take_profit: takeProfit,
            timing: timing.optimal_entry_timing,
            urgency: timing.urgency_level,
            patience_required: timing.patience_score > 0.7
        };
    }

    // C√ÅLCULO DE AJUSTE POR RIESGOS
    calculateRiskAdjustment(risks) {
        const { œÜ_inv } = this.constants;
        let adjustment = 1.0;
        
        risks.forEach(risk => {
            if (risk.severity === 'HIGH') adjustment *= 0.8;
            else if (risk.severity === 'MEDIUM') adjustment *= 0.9;
        });
        
        return Math.max(0.3, adjustment * œÜ_inv);
    }

    // EVALUACI√ìN DE NIVEL DE RIESGO
    assessRiskLevel(risks) {
        const highRisks = risks.filter(r => r.severity === 'HIGH').length;
        const mediumRisks = risks.filter(r => r.severity === 'MEDIUM').length;
        
        if (highRisks > 0) return 'HIGH';
        if (mediumRisks > 1) return 'MEDIUM';
        return 'LOW';
    }

    // C√ÅLCULO DE TAMA√ëO DE POSICI√ìN
    calculatePositionSize(confidence, strength, risks) {
        const { œÜ } = this.constants;
        const baseSize = 0.1; // 10% base
        const riskFactor = risks.length > 0 ? 0.7 : 1.0;
        
        return Math.min(0.5, baseSize * confidence * strength.overall_strength * riskFactor * œÜ);
    }

    // C√ÅLCULO DE STOP LOSS
    calculateStopLoss(confidence, action, risks) {
        const { œÜ_inv } = this.constants;
        const baseStop = 0.05; // 5% base
        const riskMultiplier = risks.some(r => r.severity === 'HIGH') ? 1.5 : 1.0;
        
        return action === 'HOLD' ? 0 : (baseStop / confidence) * riskMultiplier * œÜ_inv;
    }

    // C√ÅLCULO DE TAKE PROFIT
    calculateTakeProfit(confidence, action, strength) {
        const { œÜ } = this.constants;
        const baseProfit = 0.15; // 15% base
        
        return action === 'HOLD' ? 0 : baseProfit * confidence * strength.overall_strength * œÜ;
    }

    // GENERACI√ìN DE RESUMEN EJECUTIVO
    generateExecutiveSummary(masterIntelligence, finalDecision) {
        const { œÜ } = this.constants;
        
        return {
            market_situation: this.describeMarketSituation(masterIntelligence),
            key_insights: this.extractKeyInsights(masterIntelligence),
            recommended_action: {
                action: finalDecision.action,
                confidence: finalDecision.confidence,
                rationale: finalDecision.rationale,
                urgency: finalDecision.urgency
            },
            risk_assessment: {
                overall_risk: finalDecision.risk_level,
                key_risks: masterIntelligence.risk_factors.map(r => r.type),
                risk_mitigation: this.generateRiskMitigation(finalDecision.risk_level)
            },
            execution_guidance: {
                position_sizing: finalDecision.position_size,
                entry_timing: finalDecision.timing,
                stop_loss: finalDecision.stop_loss,
                take_profit: finalDecision.take_profit,
                patience_required: finalDecision.patience_required
            },
            market_context: {
                regime: masterIntelligence.extracted_signals.regime_signals[0]?.regime_type || 'UNKNOWN',
                consensus: masterIntelligence.market_consensus.consensus,
                strength: masterIntelligence.composite_strength.overall_strength
            }
        };
    }

    // DESCRIPCI√ìN DE SITUACI√ìN DE MERCADO
    describeMarketSituation(masterIntelligence) {
        const consensus = masterIntelligence.market_consensus;
        const strength = masterIntelligence.composite_strength;
        
        if (consensus.consensus === 'BULLISH' && strength.overall_strength > 0.7) {
            return 'Strong bullish momentum with high conviction signals across multiple timeframes';
        } else if (consensus.consensus === 'BEARISH' && strength.overall_strength > 0.7) {
            return 'Strong bearish pressure with multiple confirming signals';
        } else if (consensus.consensus === 'NEUTRAL') {
            return 'Mixed signals with no clear directional bias - range-bound conditions likely';
        }
        
        return 'Moderate directional bias with mixed confirmation signals';
    }

    // EXTRACCI√ìN DE INSIGHTS CLAVE
    extractKeyInsights(masterIntelligence) {
        const insights = [];
        
        // INSIGHT DE CONFLUENCIA
        if (masterIntelligence.confluence_analysis.confluence_strength > 0.7) {
            insights.push('High signal confluence across multiple intelligence systems');
        }
        
        // INSIGHT DE R√âGIMEN
        const regimeSignal = masterIntelligence.extracted_signals.regime_signals[0];
        if (regimeSignal) {
            insights.push(`Market operating in ${regimeSignal.regime_type} regime`);
        }
        
        // INSIGHT DE RIESGO
        if (masterIntelligence.risk_factors.length > 0) {
            insights.push(`${masterIntelligence.risk_factors.length} significant risk factors identified`);
        }
        
        return insights;
    }

    // GENERACI√ìN DE MITIGACI√ìN DE RIESGOS
    generateRiskMitigation(riskLevel) {
        switch (riskLevel) {
            case 'HIGH':
                return ['Reduce position sizes by 50%', 'Use wider stop losses', 'Avoid market orders'];
            case 'MEDIUM':
                return ['Moderate position sizing', 'Standard risk management', 'Monitor closely'];
            case 'LOW':
                return ['Normal position sizing', 'Standard execution', 'Regular monitoring'];
            default:
                return ['Standard risk management procedures'];
        }
    }

    // GENERACI√ìN DE BOTTOM LINE
    generateBottomLine(finalDecision, masterIntelligence) {
        const { œÜ } = this.constants;
        
        return {
            one_sentence_summary: this.createOneSentenceSummary(finalDecision, masterIntelligence),
            action_required: finalDecision.action !== 'HOLD',
            confidence_level: finalDecision.confidence > 0.7 ? 'HIGH' : finalDecision.confidence > 0.5 ? 'MEDIUM' : 'LOW',
            risk_reward_ratio: this.calculateRiskRewardRatio(finalDecision),
            time_horizon: '24-48 hours',
            success_probability: Math.min(0.9, finalDecision.confidence * œÜ)
        };
    }

    // CREACI√ìN DE RESUMEN EN UNA FRASE
    createOneSentenceSummary(finalDecision, masterIntelligence) {
        const consensus = masterIntelligence.market_consensus.consensus;
        const strength = masterIntelligence.composite_strength.overall_strength;
        const confidence = finalDecision.confidence;
        
        if (finalDecision.action === 'LONG') {
            return `Strong ${consensus} signals with ${(confidence * 100).toFixed(0)}% confidence suggest LONG position with ${(strength * 100).toFixed(0)}% conviction.`;
        } else if (finalDecision.action === 'SHORT') {
            return `Strong ${consensus} signals with ${(confidence * 100).toFixed(0)}% confidence suggest SHORT position with ${(strength * 100).toFixed(0)}% conviction.`;
        } else {
            return `Mixed signals with ${(confidence * 100).toFixed(0)}% confidence suggest HOLDING with ${(strength * 100).toFixed(0)}% conviction.`;
        }
    }

    // C√ÅLCULO DE RATIO RIESGO/BENEFICIO
    calculateRiskRewardRatio(finalDecision) {
        if (finalDecision.action === 'HOLD') return 0;
        
        const risk = finalDecision.stop_loss;
        const reward = finalDecision.take_profit;
        
        if (risk === 0) return 0;
        return reward / risk;
    }
}

module.exports = {
    UnifiedMarketIntelligenceSystem
};
