/**
 * üß† N√öCLEO DECISIONAL ORQUESTADOR
 * ================================
 * 
 * Orquestador central que coordina todos los componentes del n√∫cleo decisional
 * Integra an√°lisis psicol√≥gico y tasas de cambio de patrones fundamentales
 */

const { NucleoPsicologicoTasasCambio } = require('./nucleo-psicologico-tasas-cambio.js');

class NucleoDecisionalOrquestador {
    constructor() {
        // üß† N√öCLEO PSICOL√ìGICO (COMPONENTE PRINCIPAL)
        this.nucleoPsicologico = new NucleoPsicologicoTasasCambio();
        
        // üîÑ COMPONENTES DEL N√öCLEO DECISIONAL
        this.universosParalelos = null;
        this.superposicionMultiActivo = null;
        this.resonanciaSimbolos = null;
        this.feynmanOptimizer = null;
        
        // üìä ESTADO GLOBAL DEL SISTEMA
        this.estadoGlobal = {
            ultimaActualizacion: Date.now(),
            estadoPsicologico: null,
            tasasCambio: null,
            decisionesPendientes: [],
            performanceHistorica: new Map()
        };
        
        // ‚öôÔ∏è CONFIGURACI√ìN
        this.config = {
            intervaloActualizacion: 5000, // 5 segundos
            maxDecisionesPendientes: 10,
            umbralConfianza: 0.7,
            modoAdaptativo: true
        };
        
        // üöÄ INICIALIZAR COMPONENTES
        this.inicializarComponentes();
        
        // üîÑ INICIAR ACTUALIZACI√ìN AUTOM√ÅTICA
        this.iniciarActualizacionAutomatica();
    }
    
    /**
     * üöÄ INICIALIZAR COMPONENTES DEL N√öCLEO DECISIONAL
     */
    async inicializarComponentes() {
        console.log('üß† [ORQUESTADOR] Inicializando componentes del n√∫cleo decisional...');
        
        try {
            // UNIVERSOS PARALELOS
            try {
                const { UniversosParalelos } = require('./UniversosParalelos.js');
                this.universosParalelos = new UniversosParalelos();
                console.log('‚úÖ [ORQUESTADOR] Universos Paralelos inicializado');
            } catch (error) {
                console.warn('‚ö†Ô∏è [ORQUESTADOR] Universos Paralelos no disponible, usando cache QBTC');
                this.universosParalelos = this.crearComponenteCache('universos');
            }
            
            // SUPERPOSICI√ìN MULTI-ACTIVO
            try {
                const { SuperposicionMultiActivo } = require('./SuperposicionMultiActivo.js');
                this.superposicionMultiActivo = new SuperposicionMultiActivo();
                console.log('‚úÖ [ORQUESTADOR] Superposici√≥n Multi-Activo inicializado');
            } catch (error) {
                console.warn('‚ö†Ô∏è [ORQUESTADOR] Superposici√≥n Multi-Activo no disponible, usando cache QBTC');
                this.superposicionMultiActivo = this.crearComponenteCache('superposicion');
            }
            
            // RESONANCIA S√çMBOLOS
            try {
                const { ResonanciaSimbolos } = require('./ResonanciaSimbolos.js');
                this.resonanciaSimbolos = new ResonanciaSimbolos();
                console.log('‚úÖ [ORQUESTADOR] Resonancia S√≠mbolos inicializado');
            } catch (error) {
                console.warn('‚ö†Ô∏è [ORQUESTADOR] Resonancia S√≠mbolos no disponible, usando cache QBTC');
                this.resonanciaSimbolos = this.crearComponenteCache('resonancia');
            }
            
            // FEYNMAN QUANTUM OPTIMIZER
            try {
                const { FeynmanQuantumOptimizer } = require('./FeynmanQuantumOptimizer.js');
                this.feynmanOptimizer = new FeynmanQuantumOptimizer();
                console.log('‚úÖ [ORQUESTADOR] Feynman Quantum Optimizer inicializado');
            } catch (error) {
                console.warn('‚ö†Ô∏è [ORQUESTADOR] Feynman Quantum Optimizer no disponible, usando cache QBTC');
                this.feynmanOptimizer = this.crearComponenteCache('feynman');
            }
            
            console.log('üéØ [ORQUESTADOR] Todos los componentes inicializados correctamente');
            
        } catch (error) {
            console.error('‚ùå [ORQUESTADOR] Error inicializando componentes:', error.message);
        }
    }
    
    /**
     * üß† TOMAR DECISI√ìN INTEGRAL
     */
    async tomarDecision(symbol, currentPrice, timeHorizon = '30d') {
        console.log(`üß† [ORQUESTADOR] Tomando decisi√≥n para ${symbol} a $${currentPrice}...`);
        
        try {
            // üìä 1. AN√ÅLISIS PSICOL√ìGICO COMPLETO
            const estadoPsicologico = await this.nucleoPsicologico.analisisCompleto(symbol, currentPrice, timeHorizon);
            this.estadoGlobal.estadoPsicologico = estadoPsicologico;
            
            console.log(`üß† [PSICOL√ìGICO] Estado: ${estadoPsicologico.estado_psicologico.estado} (${estadoPsicologico.estado_psicologico.puntuacion.toFixed(3)})`);
            
            // üìà 2. OBTENER TASAS DE CAMBIO
            const tasasCambio = await this.nucleoPsicologico.analizarTasasCambio(symbol, currentPrice, timeHorizon);
            this.estadoGlobal.tasasCambio = tasasCambio;
            
            // üîÑ 3. ALIMENTAR TODOS LOS COMPONENTES
            await this.alimentarComponentes(estadoPsicologico, tasasCambio);
            
            // üéØ 4. EJECUTAR COMPONENTES CON ESTADO PSICOL√ìGICO
            const resultados = await this.ejecutarComponentes(symbol, currentPrice, estadoPsicologico);
            
            // üß† 5. SINTETIZAR DECISI√ìN FINAL
            const decisionFinal = await this.sintetizarDecisionFinal(symbol, currentPrice, resultados, estadoPsicologico, tasasCambio);
            
            // üìä 6. REGISTRAR DECISI√ìN
            this.registrarDecision(decisionFinal);
            
            console.log(`‚úÖ [ORQUESTADOR] Decisi√≥n tomada: ${decisionFinal.accion} (Confianza: ${decisionFinal.confianza.toFixed(3)})`);
            
            return decisionFinal;
            
        } catch (error) {
            console.error('‚ùå [ORQUESTADOR] Error tomando decisi√≥n:', error.message);
            return this.crearDecisionFallback(symbol, currentPrice, error.message);
        }
    }
    
    /**
     * üîÑ ALIMENTAR COMPONENTES CON ESTADO PSICOL√ìGICO
     */
    async alimentarComponentes(estadoPsicologico, tasasCambio) {
        console.log('üîÑ [ORQUESTADOR] Alimentando componentes con estado psicol√≥gico...');
        
        try {
            // UNIVERSOS PARALELOS
            if (this.universosParalelos && this.universosParalelos.actualizarEstadoPsicologico) {
                await this.universosParalelos.actualizarEstadoPsicologico(estadoPsicologico, tasasCambio);
            }
            
            // SUPERPOSICI√ìN MULTI-ACTIVO
            if (this.superposicionMultiActivo && this.superposicionMultiActivo.actualizarEstadoPsicologico) {
                await this.superposicionMultiActivo.actualizarEstadoPsicologico(estadoPsicologico, tasasCambio);
            }
            
            // RESONANCIA S√çMBOLOS
            if (this.resonanciaSimbolos && this.resonanciaSimbolos.actualizarEstadoPsicologico) {
                await this.resonanciaSimbolos.actualizarEstadoPsicologico(estadoPsicologico, tasasCambio);
            }
            
            // FEYNMAN OPTIMIZER
            if (this.feynmanOptimizer && this.feynmanOptimizer.actualizarEstadoPsicologico) {
                await this.feynmanOptimizer.actualizarEstadoPsicologico(estadoPsicologico, tasasCambio);
            }
            
            console.log('‚úÖ [ORQUESTADOR] Componentes alimentados correctamente');
            
        } catch (error) {
            console.error('‚ùå [ORQUESTADOR] Error alimentando componentes:', error.message);
        }
    }
    
    /**
     * üéØ EJECUTAR COMPONENTES CON ESTADO PSICOL√ìGICO
     */
    async ejecutarComponentes(symbol, currentPrice, estadoPsicologico) {
        console.log('üéØ [ORQUESTADOR] Ejecutando componentes...');
        
        const resultados = {};
        
        try {
            // UNIVERSOS PARALELOS
            if (this.universosParalelos) {
                try {
                    resultados.universosParalelos = await this.universosParalelos.realizarPrediccion(symbol, estadoPsicologico);
                    console.log('‚úÖ [UNIVERSOS] Predicci√≥n realizada');
                } catch (error) {
                    console.error('‚ùå [UNIVERSOS] Error:', error.message);
                    resultados.universosParalelos = this.crearResultadoFallback('universos');
                }
            }
            
            // SUPERPOSICI√ìN MULTI-ACTIVO
            if (this.superposicionMultiActivo) {
                try {
                    resultados.superposicionMultiActivo = await this.superposicionMultiActivo.calcularSuperposicion(symbol, estadoPsicologico);
                    console.log('‚úÖ [SUPERPOSICI√ìN] C√°lculo realizado');
                } catch (error) {
                    console.error('‚ùå [SUPERPOSICI√ìN] Error:', error.message);
                    resultados.superposicionMultiActivo = this.crearResultadoFallback('superposicion');
                }
            }
            
            // RESONANCIA S√çMBOLOS
            if (this.resonanciaSimbolos) {
                try {
                    resultados.resonanciaSimbolos = await this.resonanciaSimbolos.amplificarSe√±al(symbol, estadoPsicologico);
                    console.log('‚úÖ [RESONANCIA] Se√±al amplificada');
                } catch (error) {
                    console.error('‚ùå [RESONANCIA] Error:', error.message);
                    resultados.resonanciaSimbolos = this.crearResultadoFallback('resonancia');
                }
            }
            
            // FEYNMAN OPTIMIZER
            if (this.feynmanOptimizer) {
                try {
                    resultados.feynmanOptimizer = await this.feynmanOptimizer.optimizar(symbol, estadoPsicologico);
                    console.log('‚úÖ [FEYNMAN] Optimizaci√≥n realizada');
                } catch (error) {
                    console.error('‚ùå [FEYNMAN] Error:', error.message);
                    resultados.feynmanOptimizer = this.crearResultadoFallback('feynman');
                }
            }
            
            console.log('‚úÖ [ORQUESTADOR] Todos los componentes ejecutados');
            return resultados;
            
        } catch (error) {
            console.error('‚ùå [ORQUESTADOR] Error ejecutando componentes:', error.message);
            return this.crearResultadosFallback();
        }
    }
    
    /**
     * üß† SINTETIZAR DECISI√ìN FINAL
     */
    async sintetizarDecisionFinal(symbol, currentPrice, resultados, estadoPsicologico, tasasCambio) {
        console.log('üß† [ORQUESTADOR] Sintetizando decisi√≥n final...');
        
        try {
            // üìä CALCULAR PESOS BASADOS EN ESTADO PSICOL√ìGICO
            const pesos = this.calcularPesosPsicologicos(estadoPsicologico);
            
            // üéØ SINTETIZAR RESULTADOS
            let decisionFinal = {
                symbol,
                currentPrice,
                timestamp: new Date().toISOString(),
                accion: 'ESPERAR',
                confianza: 0.5,
                razon: 'An√°lisis en progreso',
                detalles: {},
                componentes: {}
            };
            
            // üìä PROCESAR RESULTADOS DE CADA COMPONENTE
            if (resultados.universosParalelos) {
                const peso = pesos.universosParalelos || 0.25;
                decisionFinal = this.procesarResultadoUniversos(resultados.universosParalelos, decisionFinal, peso);
            }
            
            if (resultados.superposicionMultiActivo) {
                const peso = pesos.superposicionMultiActivo || 0.25;
                decisionFinal = this.procesarResultadoSuperposicion(resultados.superposicionMultiActivo, decisionFinal, peso);
            }
            
            if (resultados.resonanciaSimbolos) {
                const peso = pesos.resonanciaSimbolos || 0.25;
                decisionFinal = this.procesarResultadoResonancia(resultados.resonanciaSimbolos, decisionFinal, peso);
            }
            
            if (resultados.feynmanOptimizer) {
                const peso = pesos.feynmanOptimizer || 0.25;
                decisionFinal = this.procesarResultadoFeynman(resultados.feynmanOptimizer, decisionFinal, peso);
            }
            
            // üß† APLICAR AJUSTES PSICOL√ìGICOS
            decisionFinal = this.aplicarAjustesPsicologicos(decisionFinal, estadoPsicologico, tasasCambio);
            
            // üìä NORMALIZAR CONFIANZA
            decisionFinal.confianza = Math.max(0.1, Math.min(1.0, decisionFinal.confianza));
            
            // üéØ DETERMINAR ACCI√ìN FINAL
            decisionFinal.accion = this.determinarAccionFinal(decisionFinal.confianza, estadoPsicologico);
            
            console.log(`‚úÖ [ORQUESTADOR] Decisi√≥n sintetizada: ${decisionFinal.accion} (${decisionFinal.confianza.toFixed(3)})`);
            
            return decisionFinal;
            
        } catch (error) {
            console.error('‚ùå [ORQUESTADOR] Error sintetizando decisi√≥n:', error.message);
            return this.crearDecisionFallback(symbol, currentPrice, error.message);
        }
    }
    
    /**
     * üìä CALCULAR PESOS PSICOL√ìGICOS
     */
    calcularPesosPsicologicos(estadoPsicologico) {
        const { estado, puntuacion } = estadoPsicologico.estado_psicologico;
        
        // PESOS BASE
        const pesosBase = {
            universosParalelos: 0.25,
            superposicionMultiActivo: 0.25,
            resonanciaSimbolos: 0.25,
            feynmanOptimizer: 0.25
        };
        
        // AJUSTES BASADOS EN ESTADO PSICOL√ìGICO
        const ajustes = {
            'EUPHORIA': { universosParalelos: 0.4, superposicionMultiActivo: 0.3, resonanciaSimbolos: 0.2, feynmanOptimizer: 0.1 },
            'OPTIMISMO': { universosParalelos: 0.35, superposicionMultiActivo: 0.3, resonanciaSimbolos: 0.2, feynmanOptimizer: 0.15 },
            'NEUTRAL': { universosParalelos: 0.25, superposicionMultiActivo: 0.25, resonanciaSimbolos: 0.25, feynmanOptimizer: 0.25 },
            'PESIMISMO': { universosParalelos: 0.15, superposicionMultiActivo: 0.2, resonanciaSimbolos: 0.3, feynmanOptimizer: 0.35 },
            'PANICO': { universosParalelos: 0.1, superposicionMultiActivo: 0.2, resonanciaSimbolos: 0.4, feynmanOptimizer: 0.3 }
        };
        
        const ajuste = ajustes[estado] || ajustes.NEUTRAL;
        
        // APLICAR AJUSTES
        Object.keys(pesosBase).forEach(componente => {
            pesosBase[componente] = ajuste[componente] || pesosBase[componente];
        });
        
        return pesosBase;
    }
    
    /**
     * üéØ DETERMINAR ACCI√ìN FINAL
     */
    determinarAccionFinal(confianza, estadoPsicologico) {
        const { estado, puntuacion } = estadoPsicologico.estado_psicologico;
        
        // L√ìGICA BASADA EN CONFIANZA Y ESTADO PSICOL√ìGICO
        if (confianza >= 0.8) {
            if (estado === 'EUPHORIA') return 'VENDER'; // Contrario en euforia
            if (estado === 'PANICO') return 'COMPRAR'; // Contrario en p√°nico
            return 'COMPRAR'; // Alta confianza
        } else if (confianza >= 0.6) {
            if (estado === 'OPTIMISMO') return 'COMPRAR';
            if (estado === 'PESIMISMO') return 'VENDER';
            return 'COMPRAR'; // Confianza moderada
        } else if (confianza >= 0.4) {
            return 'ESPERAR'; // Confianza baja
        } else {
            return 'ESPERAR'; // Confianza muy baja
        }
    }
    
    /**
     * üîÑ INICIAR ACTUALIZACI√ìN AUTOM√ÅTICA
     */
    iniciarActualizacionAutomatica() {
        setInterval(async () => {
            try {
                this.estadoGlobal.ultimaActualizacion = Date.now();
                
                // ACTUALIZAR ESTADO PSICOL√ìGICO GLOBAL
                if (this.estadoGlobal.estadoPsicologico) {
                    const symbol = this.estadoGlobal.estadoPsicologico.symbol;
                    const currentPrice = this.estadoGlobal.estadoPsicologico.current_price;
                    
                    const nuevoEstado = await this.nucleoPsicologico.analisisCompleto(symbol, currentPrice);
                    this.estadoGlobal.estadoPsicologico = nuevoEstado;
                }
                
            } catch (error) {
                console.error('‚ùå [ORQUESTADOR] Error en actualizaci√≥n autom√°tica:', error.message);
            }
        }, this.config.intervaloActualizacion);
        
        console.log(`üîÑ [ORQUESTADOR] Actualizaci√≥n autom√°tica iniciada (${this.config.intervaloActualizacion}ms)`);
    }
    
    /**
     * üìä REGISTRAR DECISI√ìN
     */
    registrarDecision(decision) {
        this.estadoGlobal.decisionesPendientes.push({
            ...decision,
            timestamp: Date.now()
        });
        
        // MANTENER SOLO LAS √öLTIMAS DECISIONES
        if (this.estadoGlobal.decisionesPendientes.length > this.config.maxDecisionesPendientes) {
            this.estadoGlobal.decisionesPendientes = this.estadoGlobal.decisionesPendientes.slice(-this.config.maxDecisionesPendientes);
        }
    }
    
    /**
     * üìä OBTENER ESTADO GLOBAL
     */
    obtenerEstadoGlobal() {
        return {
            ...this.estadoGlobal,
            config: this.config,
            componentesActivos: {
                nucleoPsicologico: !!this.nucleoPsicologico,
                universosParalelos: !!this.universosParalelos,
                superposicionMultiActivo: !!this.superposicionMultiActivo,
                resonanciaSimbolos: !!this.resonanciaSimbolos,
                feynmanOptimizer: !!this.feynmanOptimizer
            }
        };
    }
    
    // üõ†Ô∏è M√âTODOS AUXILIARES Y MOCKS
    
    crearMockUniversosParalelos() {
        return {
            async realizarPrediccion(symbol, estadoPsicologico) {
                return {
                    symbol,
                    prediccion: {
                        direction: 'NEUTRAL',
                        targetPrice: 65000,
                        expectedChange: 0,
                        strength: 0.7,
                        confidence: 0.8
                    },
                    universoPrincipal: 2,
                    coherencia: 0.95,
                    timestamp: Date.now()
                };
            }
        };
    }
    
    crearMockSuperposicionMultiActivo() {
        return {
            async calcularSuperposicion(symbol, estadoPsicologico) {
                return {
                    symbol,
                    estrategias: [],
                    probabilidadTotal: 0.7,
                    rendimientoEsperado: 0.05,
                    timestamp: Date.now()
                };
            }
        };
    }
    
    crearMockResonanciaSimbolos() {
        return {
            async amplificarSe√±al(symbol, estadoPsicologico) {
                return {
                    symbol,
                    se√±alAmplificada: {
                        strength: 0.8,
                        confidence: 0.75,
                        factorAmplificacion: 1.2
                    },
                    timestamp: Date.now()
                };
            }
        };
    }
    
    crearMockFeynmanOptimizer() {
        return {
            async optimizar(symbol, estadoPsicologico) {
                return {
                    symbol,
                    optimizacion: {
                        efficiency: 0.9,
                        zOptimal: { real: 9, imaginary: 16 },
                        ventajaTemporal: -3000
                    },
                    timestamp: Date.now()
                };
            }
        };
    }
    
    crearResultadoFallback(componente) {
        return {
            componente,
            error: true,
            timestamp: Date.now()
        };
    }
    
    crearResultadosFallback() {
        return {
            universosParalelos: this.crearResultadoFallback('universos'),
            superposicionMultiActivo: this.crearResultadoFallback('superposicion'),
            resonanciaSimbolos: this.crearResultadoFallback('resonancia'),
            feynmanOptimizer: this.crearResultadoFallback('feynman')
        };
    }
    
    crearDecisionFallback(symbol, currentPrice, error) {
        return {
            symbol,
            currentPrice,
            timestamp: new Date().toISOString(),
            accion: 'ESPERAR',
            confianza: 0.3,
            razon: `Error: ${error}`,
            detalles: {},
            componentes: {}
        };
    }
    
    procesarResultadoUniversos(resultado, decision, peso) {
        if (resultado.error) return decision;
        
        const prediccion = resultado.prediccion;
        decision.confianza += prediccion.confidence * peso;
        decision.componentes.universosParalelos = prediccion;
        
        return decision;
    }
    
    procesarResultadoSuperposicion(resultado, decision, peso) {
        if (resultado.error) return decision;
        
        decision.confianza += resultado.probabilidadTotal * peso;
        decision.componentes.superposicionMultiActivo = resultado;
        
        return decision;
    }
    
    procesarResultadoResonancia(resultado, decision, peso) {
        if (resultado.error) return decision;
        
        const se√±al = resultado.se√±alAmplificada;
        decision.confianza += se√±al.confidence * peso;
        decision.componentes.resonanciaSimbolos = resultado;
        
        return decision;
    }
    
    procesarResultadoFeynman(resultado, decision, peso) {
        if (resultado.error) return decision;
        
        const optimizacion = resultado.optimizacion;
        decision.confianza += optimizacion.efficiency * peso;
        decision.componentes.feynmanOptimizer = resultado;
        
        return decision;
    }
    
    aplicarAjustesPsicologicos(decision, estadoPsicologico, tasasCambio) {
        const { estado, puntuacion } = estadoPsicologico.estado_psicologico;
        
        // AJUSTES BASADOS EN ESTADO PSICOL√ìGICO
        const ajustes = {
            'EUPHORIA': { multiplicador: 0.8, razon: 'Mercado en euforia - precauci√≥n' },
            'OPTIMISMO': { multiplicador: 1.1, razon: 'Optimismo moderado - favorable' },
            'NEUTRAL': { multiplicador: 1.0, razon: 'Estado neutral' },
            'PESIMISMO': { multiplicador: 0.9, razon: 'Pesimismo - ajuste conservador' },
            'PANICO': { multiplicador: 1.2, razon: 'P√°nico - oportunidad contraria' }
        };
        
        const ajuste = ajustes[estado] || ajustes.NEUTRAL;
        
        decision.confianza *= ajuste.multiplicador;
        decision.razon = `${decision.razon} | ${ajuste.razon}`;
        
        return decision;
    }
}

module.exports = { NucleoDecisionalOrquestador };
