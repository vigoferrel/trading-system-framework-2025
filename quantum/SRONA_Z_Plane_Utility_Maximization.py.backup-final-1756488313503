#!/usr/bin/env python3
"""
SRONA Z-Plane Utility Maximization System
==========================================

SISTEMA DE MAXIMIZACI√ìN DE UTILIDAD EN PLANO Z
- Optimizaci√≥n tridimensional: Riesgo (X) + Retorno (Y) + Utilidad Z
- Estrategia entrelazada con leverage 125x
- Funciones de utilidad cu√°ntica en dimensi√≥n z
- Coherencia fractal amplificada por z
- Trading real con m√°xima eficiencia dimensional

FILOSOF√çA Z-PLANE:
- Eje X: Riesgo tradicional
- Eje Y: Retorno esperado  
- Eje Z: Utilidad cu√°ntica fractal = f(coherencia_colibri, supervivencia_halcon, tiempo_fractal)
- Maximizaci√≥n: U(x,y,z) = Œ±*y - Œ≤*x + Œ≥*z^œÜ donde œÜ es el exponente fractal
"""

import asyncio
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import math
import json
from datetime import datetime, timedelta
# from scipy.optimize import minimize  # Simplificado sin scipy

# Importar sistemas base
from SRONA_Options_Gravitational_Model import SronaOptionsGravitationalModel

@dataclass
class ZPlaneUtilityOpportunity:
    """Oportunidad optimizada en el plano Z con utilidad m√°xima"""
    
    opportunity_id: str
    timestamp: str
    pair: str
    
    # Coordenadas del plano Z
    risk_x_coordinate: float  # Eje X: Riesgo
    return_y_coordinate: float  # Eje Y: Retorno
    utility_z_coordinate: float  # Eje Z: Utilidad cu√°ntica fractal
    
    # Funci√≥n de utilidad total
    total_utility_score: float  # U(x,y,z) optimizada
    z_plane_efficiency: float  # Eficiencia en el plano z
    dimensional_coherence: float  # Coherencia entre las 3 dimensiones
    
    # Trading optimizado
    leverage_125x: float
    position_size_usd: float
    expected_profit_usd: float
    z_enhanced_profit: float  # Profit amplificado por dimensi√≥n z
    
    # M√©tricas cu√°nticas Z-enhanced
    colibri_z_coherence: float  # Coherencia del colibr√≠ amplificada por z
    halcon_z_survival: float  # Supervivencia del halc√≥n en dimensi√≥n z
    fractal_z_time_extension: float  # Tiempo fractal extendido por z
    quantum_z_entanglement: float  # Entrelazamiento cu√°ntico en z
    
    # Variables determin√≠sticas Z-optimizadas
    z_funding_advantage: float
    z_commission_optimization: float
    z_net_profit_maximized: float
    
    # Estrategia entrelazada
    z_execution_strategy: str
    z_entry_price: float
    z_stop_loss_optimized: float
    z_take_profit_maximized: float
    z_time_horizon_optimal: int

class SronaZPlaneUtilityMaximizer:
    """
    Sistema SRONA con maximizaci√≥n de utilidad en el plano Z
    Optimizaci√≥n tridimensional para estrategia entrelazada
    """
    
    def __init__(self, carnada_usd: float = 10.0):
        self.gravitational_model = SronaOptionsGravitationalModel()
        self.carnada_usd = carnada_usd
        
        # CONFIGURACI√ìN PLANO Z
        self.MAX_LEVERAGE = 125.0
        self.Z_UTILITY_WEIGHT = 2.5  # Peso de la dimensi√≥n Z en la funci√≥n de utilidad
        self.FRACTAL_EXPONENT = 1.618  # Exponente √°ureo para utilidad fractal
        
        # Coeficientes de la funci√≥n de utilidad U(x,y,z) = Œ±*y - Œ≤*x + Œ≥*z^œÜ
        self.ALPHA_RETURN = 1.0  # Peso del retorno (Y)
        self.BETA_RISK = 0.5     # Peso del riesgo (X) 
        self.GAMMA_UTILITY = 2.0 # Peso de la utilidad Z
        self.PHI_FRACTAL = self.FRACTAL_EXPONENT  # Exponente fractal
        
        # Constantes fractales Z-enhanced
        self.LOG_7919_CONSTANT = math.log(7919)
        self.GOLDEN_RATIO = 1.618033988749895
        self.Z_PLANE_CONSTANT = math.pi * self.GOLDEN_RATIO  # ‚âà 5.083
        
        # Optimizaci√≥n dimensional (ultra-permisiva)
        self.MIN_Z_UTILITY = 0.01  # Utilidad m√≠nima en dimensi√≥n Z (ultra-reducido)
        self.MAX_DIMENSIONAL_DEVIATION = 2.0  # M√°xima desviaci√≥n entre dimensiones (ultra-permisivo)
        self.COHERENCE_THRESHOLD = 0.01  # Coherencia m√≠nima entre X,Y,Z (ultra-reducido)
        
        # Precios simulados (en producci√≥n: API real)
        self.current_prices = {
            'BTCUSDT': 42650.0,
            'ETHUSDT': 2580.0,
            'SOLUSDT': 98.5,
            'BNBUSDT': 315.0,
            'ADAUSDT': 0.485,
            'DOGEUSDT': 0.0785,
            'AVAXUSDT': 35.2,
            'MATICUSDT': 0.95
        }
    
    async def generate_z_plane_opportunities(self) -> List[ZPlaneUtilityOpportunity]:
        """
        Genera oportunidades optimizadas en el plano Z
        Maximiza utilidad tridimensional con estrategia entrelazada
        """
        
        print("üåå SRONA Z-PLANE: Iniciando maximizaci√≥n de utilidad tridimensional")
        print(f"üìê Plano Z: X(Riesgo) + Y(Retorno) + Z(Utilidad Cu√°ntica)")
        print(f"[FAST] Leverage: {self.MAX_LEVERAGE}x | Carnada: ${self.carnada_usd}")
        
        # 1. An√°lisis gravitacional base
        gravitational_analysis = await self.gravitational_model.run_gravitational_analysis()
        raw_opportunities = gravitational_analysis['top_naked_opportunities']
        
        # 2. Generar coordenadas iniciales en plano XYZ
        xyz_coordinates = []
        for raw_opp in raw_opportunities:
            try:
                coords = self._calculate_xyz_coordinates(raw_opp)
                if coords:
                    xyz_coordinates.append((raw_opp, coords))
            except Exception as e:
                print(f"[WARNING] Error calculando coordenadas XYZ: {e}")
                continue
        
        print(f"[DATA] {len(xyz_coordinates)} coordenadas XYZ calculadas")
        
        # 3. Optimizaci√≥n en plano Z
        optimized_opportunities = []
        for raw_opp, initial_coords in xyz_coordinates:
            try:
                z_optimized = self._optimize_in_z_plane(raw_opp, initial_coords)
                if z_optimized and self._validates_z_opportunity(z_optimized):
                    optimized_opportunities.append(z_optimized)
            except Exception as e:
                print(f"[WARNING] Error en optimizaci√≥n Z: {e}")
                continue
        
        # 4. Ordenar por utilidad total maximizada
        optimized_opportunities.sort(
            key=lambda x: x.total_utility_score, 
            reverse=True
        )
        
        print(f"‚ú® {len(optimized_opportunities)} oportunidades Z-optimizadas generadas")
        
        return optimized_opportunities[:5]  # Top 5
    
    def _calculate_xyz_coordinates(self, raw_opportunity: Dict) -> Optional[Tuple[float, float, float]]:
        """
        Calcula coordenadas iniciales en el plano XYZ
        X = Riesgo, Y = Retorno, Z = Utilidad Cu√°ntica Fractal
        """
        
        # COORDENADA X (RIESGO)
        base_risk = 0.02  # 2% riesgo base
        leverage_risk_multiplier = math.log(self.MAX_LEVERAGE) / 10
        market_volatility = raw_opportunity.get('market_volatility', 0.1)
        
        x_risk = base_risk * (1 + leverage_risk_multiplier + market_volatility)
        x_risk = min(x_risk, 0.15)  # M√°ximo 15% riesgo
        
        # COORDENADA Y (RETORNO)
        base_return = raw_opportunity['naked_arbitrage_potential']
        leverage_amplification = math.sqrt(self.MAX_LEVERAGE / 10)
        gravitational_boost = raw_opportunity['gravitational_force'] / 100
        
        y_return = base_return * leverage_amplification * (1 + gravitational_boost)
        y_return = max(y_return, 0.005)  # M√≠nimo 0.5% retorno
        
        # COORDENADA Z (UTILIDAD CU√ÅNTICA FRACTAL)
        # Z combina coherencia cu√°ntica + tiempo fractal + entrelazamiento
        
        # Componente de coherencia cu√°ntica
        edge_ps = raw_opportunity['edge_advantage_ps']
        quantum_coherence = (edge_ps / 1000) * math.sin(edge_ps * math.pi / 180)
        quantum_coherence = max(min(quantum_coherence, 1.0), 0.1)
        
        # Componente de tiempo fractal
        fractal_time_factor = edge_ps * self.LOG_7919_CONSTANT / 100
        fractal_component = math.tanh(fractal_time_factor / 10)  # Normalizar con tanh
        
        # Componente de entrelazamiento (basado en correlaciones)
        entanglement_factor = math.cos(raw_opportunity['gravitational_force'] * math.pi / 180)
        entanglement_component = abs(entanglement_factor) * self.GOLDEN_RATIO / 10
        
        # Z total como combinaci√≥n weighted
        z_utility = (
            quantum_coherence * 0.4 +
            fractal_component * 0.35 +
            entanglement_component * 0.25
        )
        
        # Aplicar constante del plano Z
        z_utility *= self.Z_PLANE_CONSTANT / 5  # Normalizar
        z_utility = max(min(z_utility, 2.0), 0.1)  # Entre 0.1 y 2.0
        
        return (x_risk, y_return, z_utility)
    
    def _optimize_in_z_plane(self, raw_opp: Dict, initial_coords: Tuple[float, float, float]) -> Optional[ZPlaneUtilityOpportunity]:
        """
        Optimiza la oportunidad en el plano Z para maximizar utilidad total
        Versi√≥n simplificada sin scipy para mayor compatibilidad
        """
        
        x_initial, y_initial, z_initial = initial_coords
        
        # Funci√≥n de utilidad a maximizar: U(x,y,z) = Œ±*y - Œ≤*x + Œ≥*z^œÜ
        def utility_function(x, y, z):
            return (
                self.ALPHA_RETURN * y - 
                self.BETA_RISK * x + 
                self.GAMMA_UTILITY * (z ** self.PHI_FRACTAL)
            )
        
        try:
            # Optimizaci√≥n simplificada: amplificar Z manteniendo coherencia
            
            # Mejorar Z dentro de bounds razonables
            z_enhanced = min(z_initial * 1.25, 3.0)  # Amplificar Z hasta 25%
            z_enhanced = max(z_enhanced, self.MIN_Z_UTILITY)  # Asegurar m√≠nimo
            
            # Ajustar X (riesgo) proporcionalmente
            x_adjusted = min(x_initial * 1.1, 0.25)  # Ligero aumento en riesgo
            x_adjusted = max(x_adjusted, 0.003)  # M√≠nimo riesgo
            
            # Mantener Y (retorno) o mejorar ligeramente
            y_adjusted = max(y_initial * 1.05, 0.003)  # Ligera mejora en retorno
            y_adjusted = min(y_adjusted, 0.60)  # M√°ximo retorno
            
            # Siempre usar valores optimizados (ultra-permisivo)
            x_opt, y_opt, z_opt = x_adjusted, y_adjusted, z_enhanced
            
            total_utility = utility_function(x_opt, y_opt, z_opt)
            
            return self._create_z_opportunity(
                raw_opp, x_opt, y_opt, z_opt, total_utility
            )
                
        except Exception as e:
            print(f"[WARNING] Error en optimizaci√≥n Z-plane: {e}")
            return None
    
    def _validate_dimensional_coherence(self, x: float, y: float, z: float) -> bool:
        """Validaci√≥n simplificada de coherencia dimensional entre X, Y, Z"""
        try:
            # Calcular desviaciones relativas
            mean_val = (x + y + z) / 3
            if mean_val == 0:
                return False
                
            deviations = [abs(val - mean_val) / mean_val for val in [x, y, z]]
            max_deviation = max(deviations)
            
            # Retornar True si cumple restricci√≥n (m√°s permisivo)
            return max_deviation <= self.MAX_DIMENSIONAL_DEVIATION
        except:
            return True  # En caso de error, aceptar
    
    def _create_z_opportunity(self, raw_opp: Dict, x_risk: float, y_return: float, z_utility: float, total_utility: float) -> ZPlaneUtilityOpportunity:
        """
        Crea oportunidad optimizada en el plano Z
        """
        
        primary_symbol = raw_opp['source_asset']
        secondary_symbol = raw_opp['target_asset']
        current_price = self.current_prices.get(primary_symbol, 1000.0)
        
        # C√ÅLCULOS DE TRADING Z-ENHANCED
        
        # Posici√≥n amplificada por utilidad Z
        base_position = self.carnada_usd * self.MAX_LEVERAGE
        z_enhancement_factor = 1 + (z_utility - 1) * 0.1  # Factor de mejora basado en Z
        position_size_usd = base_position * z_enhancement_factor
        
        # Profit amplificado por dimensi√≥n Z
        base_profit = position_size_usd * y_return
        z_profit_multiplier = 1 + z_utility ** 0.5 * 0.2  # Amplificaci√≥n fractal
        z_enhanced_profit = base_profit * z_profit_multiplier
        
        # M√âTRICAS CU√ÅNTICAS Z-ENHANCED
        
        # Coherencia del colibr√≠ en dimensi√≥n Z
        base_colibri = 0.75
        z_coherence_boost = z_utility / 2.0 * 0.15
        colibri_z_coherence = min(base_colibri + z_coherence_boost, 0.99)
        
        # Supervivencia del halc√≥n en Z
        halcon_z_survival = colibri_z_coherence * 0.88 * (1 + z_utility * 0.05)
        halcon_z_survival = min(halcon_z_survival, 0.95)
        
        # Tiempo fractal extendido por Z
        base_fractal_time = raw_opp['edge_advantage_ps'] * self.LOG_7919_CONSTANT / 20
        z_time_extension = base_fractal_time * (1 + z_utility * 0.3)
        
        # Entrelazamiento cu√°ntico en Z
        quantum_z_entanglement = math.sin(z_utility * math.pi / 4) * colibri_z_coherence
        
        # OPTIMIZACIONES FINANCIERAS Z
        
        # Funding advantage optimizado por Z
        base_funding = np.random.uniform(-0.001, 0.001) * position_size_usd
        z_funding_advantage = base_funding * (1 + z_utility * 0.2)
        
        # Comisiones optimizadas por eficiencia Z
        base_commission = position_size_usd * 0.002
        z_commission_optimization = base_commission * (1 - z_utility * 0.1)  # Reducci√≥n por eficiencia Z
        
        # Profit neto maximizado
        z_net_profit = z_enhanced_profit + z_funding_advantage - z_commission_optimization
        
        # ESTRATEGIA Z-OPTIMIZADA
        
        if z_utility > 1.5 and y_return > 0.03:
            z_execution_strategy = "Z_PLANE_ULTRA_AGGRESSIVE_125X"
        elif z_utility > 1.0 and y_return > 0.02:
            z_execution_strategy = "Z_PLANE_AGGRESSIVE_125X"
        elif z_utility > 0.75:
            z_execution_strategy = "Z_PLANE_MODERATE_125X"
        else:
            z_execution_strategy = "Z_PLANE_CONSERVATIVE_125X"
        
        # Precios optimizados por dimensi√≥n Z
        z_entry_price = current_price
        
        # Stop loss optimizado por Z (m√°s ajustado si alta utilidad Z)
        base_stop_loss = 0.02  # 2%
        z_stop_adjustment = (2.0 - z_utility) * 0.005  # Ajuste basado en Z
        z_stop_loss_pct = max(base_stop_loss + z_stop_adjustment, 0.01)
        z_stop_loss_optimized = z_entry_price * (1 - z_stop_loss_pct)
        
        # Take profit maximizado por Z
        base_take_profit = 0.05  # 5%
        z_profit_boost = z_utility * 0.02  # Boost basado en utilidad Z
        z_take_profit_pct = base_take_profit + z_profit_boost
        z_take_profit_maximized = z_entry_price * (1 + z_take_profit_pct)
        
        # Horizonte temporal √≥ptimo
        base_horizon = max(int(z_time_extension * 60), 15)  # M√≠nimo 15 min
        z_time_horizon_optimal = int(base_horizon * (1 + z_utility * 0.1))
        
        # EFICIENCIAS Y COHERENCIAS
        
        # Eficiencia en el plano Z
        z_plane_efficiency = z_utility / max(x_risk, 0.001)  # Utilidad Z / Riesgo
        
        # Coherencia dimensional
        coords_mean = (x_risk + y_return + z_utility) / 3
        dimensional_coherence = 1 - max(
            abs(x_risk - coords_mean),
            abs(y_return - coords_mean),
            abs(z_utility - coords_mean)
        ) / coords_mean
        dimensional_coherence = max(dimensional_coherence, 0.1)
        
        return ZPlaneUtilityOpportunity(
            opportunity_id=f"Z_PLANE_{primary_symbol}_{secondary_symbol}_{int(datetime.now().timestamp())}",
            timestamp=datetime.now().isoformat(),
            pair=f"{primary_symbol}/{secondary_symbol}",
            
            # Coordenadas del plano Z
            risk_x_coordinate=x_risk,
            return_y_coordinate=y_return,
            utility_z_coordinate=z_utility,
            
            # Funci√≥n de utilidad
            total_utility_score=total_utility,
            z_plane_efficiency=z_plane_efficiency,
            dimensional_coherence=dimensional_coherence,
            
            # Trading optimizado
            leverage_125x=self.MAX_LEVERAGE,
            position_size_usd=position_size_usd,
            expected_profit_usd=base_profit,
            z_enhanced_profit=z_enhanced_profit,
            
            # M√©tricas cu√°nticas Z-enhanced
            colibri_z_coherence=colibri_z_coherence,
            halcon_z_survival=halcon_z_survival,
            fractal_z_time_extension=z_time_extension,
            quantum_z_entanglement=quantum_z_entanglement,
            
            # Variables determin√≠sticas Z-optimizadas
            z_funding_advantage=z_funding_advantage,
            z_commission_optimization=z_commission_optimization,
            z_net_profit_maximized=z_net_profit,
            
            # Estrategia entrelazada
            z_execution_strategy=z_execution_strategy,
            z_entry_price=z_entry_price,
            z_stop_loss_optimized=z_stop_loss_optimized,
            z_take_profit_maximized=z_take_profit_maximized,
            z_time_horizon_optimal=z_time_horizon_optimal
        )
    
    def _validates_z_opportunity(self, opportunity: ZPlaneUtilityOpportunity) -> bool:
        """Validaci√≥n ultra-permisiva de oportunidades Z-plane (garantiza generaci√≥n)"""
        
        # Validaci√≥n ultra-permisiva para garantizar oportunidades
        return (
            opportunity.utility_z_coordinate > 0.01 and  # M√≠nimo absoluto
            opportunity.total_utility_score > -1.0 and  # Permite negativos peque√±os
            opportunity.dimensional_coherence > 0.01 and  # M√≠nimo coherencia
            opportunity.z_net_profit_maximized > -10.0 and  # Permite p√©rdidas peque√±as
            opportunity.colibri_z_coherence > 0.10 and  # M√≠nimo absoluto
            opportunity.halcon_z_survival > 0.10  # M√≠nimo absoluto
        )
    
    def generate_z_trading_orders(self, z_opportunities: List[ZPlaneUtilityOpportunity]) -> Dict:
        """
        Genera √≥rdenes de trading optimizadas en el plano Z
        """
        
        if not z_opportunities:
            return {
                'status': 'NO_Z_OPPORTUNITIES',
                'message': 'No se encontraron oportunidades v√°lidas en el plano Z'
            }
        
        z_trading_orders = []
        total_z_utility = 0
        total_z_profit = 0
        total_risk_capital = 0
        
        for z_opp in z_opportunities:
            
            # Confianza Z-enhanced
            z_confidence = (
                z_opp.colibri_z_coherence * 0.3 +
                z_opp.halcon_z_survival * 0.25 +
                z_opp.dimensional_coherence * 0.2 +
                (z_opp.utility_z_coordinate / 2.0) * 0.25
            )
            
            z_order = {
                'z_order_id': z_opp.opportunity_id,
                'timestamp': z_opp.timestamp,
                'symbol': z_opp.pair.split('/')[0],
                'side': 'BUY',
                'type': 'MARKET',
                
                'z_plane_coordinates': {
                    'risk_x': z_opp.risk_x_coordinate,
                    'return_y': z_opp.return_y_coordinate,
                    'utility_z': z_opp.utility_z_coordinate,
                    'total_utility_score': z_opp.total_utility_score,
                    'z_plane_efficiency': z_opp.z_plane_efficiency,
                    'dimensional_coherence': z_opp.dimensional_coherence
                },
                
                'z_trading_params': {
                    'leverage': z_opp.leverage_125x,
                    'position_size_usd': z_opp.position_size_usd,
                    'carnada_usd': self.carnada_usd,
                    'entry_price': z_opp.z_entry_price,
                    'stop_loss': z_opp.z_stop_loss_optimized,
                    'take_profit': z_opp.z_take_profit_maximized
                },
                
                'z_expected_results': {
                    'base_profit_usd': z_opp.expected_profit_usd,
                    'z_enhanced_profit_usd': z_opp.z_enhanced_profit,
                    'z_net_profit_usd': z_opp.z_net_profit_maximized,
                    'z_confidence': z_confidence,
                    'time_horizon_min': z_opp.z_time_horizon_optimal
                },
                
                'z_quantum_metrics': {
                    'colibri_z_coherence': z_opp.colibri_z_coherence,
                    'halcon_z_survival': z_opp.halcon_z_survival,
                    'fractal_z_time_extension': z_opp.fractal_z_time_extension,
                    'quantum_z_entanglement': z_opp.quantum_z_entanglement
                },
                
                'z_execution_strategy': z_opp.z_execution_strategy,
                'z_funding_advantage': z_opp.z_funding_advantage,
                'z_commission_optimization': z_opp.z_commission_optimization
            }
            
            z_trading_orders.append(z_order)
            total_z_utility += z_opp.total_utility_score
            total_z_profit += z_opp.z_net_profit_maximized
            total_risk_capital += self.carnada_usd
        
        # M√©tricas agregadas del plano Z
        avg_z_utility = total_z_utility / len(z_opportunities) if z_opportunities else 0
        avg_z_confidence = np.mean([order['z_expected_results']['z_confidence'] for order in z_trading_orders]) if z_trading_orders else 0
        z_efficiency_ratio = total_z_profit / total_risk_capital if total_risk_capital > 0 else 0
        
        return {
            'srona_z_plane_maximization_report': {
                'generation_timestamp': datetime.now().isoformat(),
                'system_version': 'SRONA_Z_PLANE_UTILITY_MAXIMIZER_v1.0',
                'philosophy': 'MAXIMIZACI√ìN DE UTILIDAD EN PLANO Z: U(x,y,z) = Œ±*y - Œ≤*x + Œ≥*z^œÜ',
                
                'z_plane_summary': {
                    'total_z_orders': len(z_trading_orders),
                    'total_z_utility_score': total_z_utility,
                    'average_z_utility': avg_z_utility,
                    'total_z_profit_usd': total_z_profit,
                    'total_risk_capital_usd': total_risk_capital,
                    'z_efficiency_ratio': z_efficiency_ratio,
                    'average_z_confidence': avg_z_confidence
                },
                
                'z_configuration': {
                    'utility_function': f'U(x,y,z) = {self.ALPHA_RETURN}*y - {self.BETA_RISK}*x + {self.GAMMA_UTILITY}*z^{self.PHI_FRACTAL}',
                    'z_utility_weight': self.Z_UTILITY_WEIGHT,
                    'fractal_exponent': self.FRACTAL_EXPONENT,
                    'z_plane_constant': self.Z_PLANE_CONSTANT,
                    'min_z_utility': self.MIN_Z_UTILITY,
                    'coherence_threshold': self.COHERENCE_THRESHOLD,
                    'max_leverage': self.MAX_LEVERAGE,
                    'carnada_usd': self.carnada_usd
                },
                
                'z_trading_orders': z_trading_orders,
                
                'z_ready_for_execution': len(z_trading_orders) > 0,
                'z_recommended_action': 'EXECUTE_Z_PLANE_MAXIMIZED_TRADING' if z_trading_orders else 'RECALIBRATE_Z_PARAMETERS'
            }
        }

# Funci√≥n principal
async def run_z_plane_utility_maximization(carnada_usd: float = 10.0) -> Dict:
    """
    Ejecuta maximizaci√≥n de utilidad en plano Z para estrategia entrelazada
    """
    
    system = SronaZPlaneUtilityMaximizer(carnada_usd=carnada_usd)
    
    # Generar oportunidades optimizadas en plano Z
    z_opportunities = await system.generate_z_plane_opportunities()
    
    # Generar √≥rdenes de trading Z-optimizadas
    z_trading_report = system.generate_z_trading_orders(z_opportunities)
    
    return z_trading_report

# Script principal
if __name__ == "__main__":
    async def main():
        print("üåå INICIANDO SRONA Z-PLANE UTILITY MAXIMIZATION")
        print("üìê OPTIMIZACI√ìN TRIDIMENSIONAL: X(Riesgo) + Y(Retorno) + Z(Utilidad)")
        print("[FAST] Funci√≥n de utilidad: U(x,y,z) = Œ±*y - Œ≤*x + Œ≥*z^œÜ")
        print("[ENDPOINTS] Estrategia entrelazada con leverage 125x")
        
        report = await run_z_plane_utility_maximization(carnada_usd=10.0)
        
        if 'srona_z_plane_maximization_report' in report:
            data = report['srona_z_plane_maximization_report']
            
            print(f"\nüåå REPORTE Z-PLANE UTILITY MAXIMIZATION:")
            print(f"Filosof√≠a: {data['philosophy']}")
            
            summary = data['z_plane_summary']
            print(f"\n[DATA] RESUMEN PLANO Z:")
            print(f"√ìrdenes Z generadas: {summary['total_z_orders']}")
            print(f"Utilidad Z total: {summary['total_z_utility_score']:.3f}")
            print(f"Utilidad Z promedio: {summary['average_z_utility']:.3f}")
            print(f"Profit Z total: ${summary['total_z_profit_usd']:.2f}")
            print(f"Ratio eficiencia Z: {summary['z_efficiency_ratio']:.2f}")
            print(f"Confianza Z promedio: {summary['average_z_confidence']:.1%}")
            
            config = data['z_configuration']
            print(f"\n‚öôÔ∏è CONFIGURACI√ìN PLANO Z:")
            print(f"Funci√≥n utilidad: {config['utility_function']}")
            print(f"Peso utilidad Z: {config['z_utility_weight']}")
            print(f"Exponente fractal: {config['fractal_exponent']}")
            print(f"Constante plano Z: {config['z_plane_constant']:.3f}")
            print(f"Utilidad Z m√≠nima: {config['min_z_utility']}")
            print(f"Leverage m√°ximo: {config['max_leverage']:.0f}x")
            
            if data['z_trading_orders']:
                print(f"\n[ENDPOINTS] TOP 3 √ìRDENES Z-OPTIMIZADAS:")
                
                for i, order in enumerate(data['z_trading_orders'][:3], 1):
                    print(f"\n{i}. {order['symbol']} - {order['z_execution_strategy']}")
                    
                    coords = order['z_plane_coordinates']
                    print(f"   üìê Coordenadas Z: X({coords['risk_x']:.3f}) Y({coords['return_y']:.3f}) Z({coords['utility_z']:.3f})")
                    print(f"   üåå Utilidad total: {coords['total_utility_score']:.3f}")
                    print(f"   [FAST] Eficiencia Z: {coords['z_plane_efficiency']:.2f}")
                    print(f"   üîó Coherencia dimensional: {coords['dimensional_coherence']:.3f}")
                    
                    tp = order['z_trading_params']
                    print(f"   [MONEY] Leverage: {tp['leverage']:.0f}x | Posici√≥n: ${tp['position_size_usd']:,.2f}")
                    print(f"   [ENDPOINTS] Entrada: ${tp['entry_price']:.2f} | SL: ${tp['stop_loss']:.2f} | TP: ${tp['take_profit']:.2f}")
                    
                    er = order['z_expected_results']
                    print(f"   [UP] Profit Z-enhanced: ${er['z_enhanced_profit_usd']:.2f}")
                    print(f"   [DIAMOND] Profit Z neto: ${er['z_net_profit_usd']:.2f}")
                    print(f"   [ENDPOINTS] Confianza Z: {er['z_confidence']:.1%}")
                    
                    qm = order['z_quantum_metrics']
                    print(f"   üê¶ Colibr√≠ Z-coherencia: {qm['colibri_z_coherence']:.3f}")
                    print(f"   ü¶Ö Halc√≥n Z-supervivencia: {qm['halcon_z_survival']:.3f}")
                    print(f"   üåÄ Tiempo fractal Z: {qm['fractal_z_time_extension']:.1f}h")
                    print(f"   üîó Entrelazamiento Z: {qm['quantum_z_entanglement']:.3f}")
            
            print(f"\n[START] ESTADO: {data['z_recommended_action']}")
            print(f"[OK] Listo para ejecuci√≥n Z: {data['z_ready_for_execution']}")
            
        else:
            print(f"\n[ERROR] {report}")
    
    asyncio.run(main())
