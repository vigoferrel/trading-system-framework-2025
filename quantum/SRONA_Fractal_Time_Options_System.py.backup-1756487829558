#!/usr/bin/env python3
"""
SRONA Fractal Time Options System
=================================

Las opciones son para GANAR TIEMPO, no para ejecutar.
La estrategia fractaliza el tiempo con log(7919).
Es el Ãºltimo recurso, pero nunca se llega a ejecutar.
Esa es la belleza de la fÃ­sica: se marcan probabilidades basadas en marcos coherentes superiores.

FILOSOFÃA FRACTAL:
- Tiempo no es lineal, es fractal con log(7919)
- Opciones extienden la superposiciÃ³n cuÃ¡ntica
- ColibrÃ­ permanece vivo Y muerto mÃ¡s tiempo
- HalcÃ³n se beneficia de la extensiÃ³n temporal
- Nunca colapsar, siempre en superposiciÃ³n Ã³ptima

ECUACIÃ“N FRACTAL MAESTRA:
Tiempo_Fractal = log(7919) * Coherence_Quantum * Option_Time_Extension
Profit_Potential = Base_Arbitrage * Time_Fractal_Multiplier * Never_Execute_Bonus
"""

import asyncio
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import math
import cmath
from datetime import datetime, timedelta
import json

# Importar sistemas base
from SRONA_Options_Gravitational_Model import SronaOptionsGravitationalModel
from SRONA_Inverse_Engineering_Ammo import SronaInverseAmmoCalculator

@dataclass
class FractalTimeFrame:
    """Marco temporal fractal basado en log(7919)"""
    base_time: float  # Tiempo base en minutos
    fractal_dimension: float  # DimensiÃ³n fractal calculada
    log_7919_multiplier: float  # Multiplicador log(7919)
    coherence_extension: float  # ExtensiÃ³n por coherencia
    option_time_buffer: float  # Buffer temporal de opciones
    never_execute_probability: float  # Probabilidad de nunca ejecutar
    
    def get_total_fractal_time(self) -> float:
        """Calcula tiempo fractal total"""
        return self.base_time * self.fractal_dimension * self.log_7919_multiplier

@dataclass
class OptionTimeExtension:
    """ExtensiÃ³n temporal a travÃ©s de opciones (Ãºltimo recurso)"""
    base_expiry_days: int  # DÃ­as base hasta expiraciÃ³n
    fractal_extended_days: float  # DÃ­as extendidos fractalmente
    strike_buffer_percent: float  # Buffer del strike vs precio actual
    time_decay_rate: float  # Tasa de decaimiento temporal
    never_execute_confidence: float  # Confianza en nunca ejecutar
    superposition_preservation: float  # PreservaciÃ³n de superposiciÃ³n

@dataclass
class CoherentFrameResult:
    """Resultado basado en marcos coherentes superiores"""
    
    # IdentificaciÃ³n
    opportunity_id: str
    timestamp: str
    pair: str
    
    # Marco temporal fractal
    fractal_timeframe: FractalTimeFrame
    option_extension: OptionTimeExtension
    
    # Estados cuÃ¡nticos extendidos
    extended_colibri_coherence: float
    extended_halcon_survival: float
    superposition_duration_extended: float
    
    # Probabilidades marcadas (no ejecutadas)
    profit_probability_marked: float
    loss_probability_marked: float
    neutral_probability_marked: float
    never_execute_probability: float
    
    # MÃ©tricas de tiempo ganado
    time_gained_minutes: float
    fractal_advantage_multiplier: float
    coherent_frame_strength: float
    
    # Profit potencial (en superposiciÃ³n extendida)
    extended_profit_potential_bps: float
    fractal_amplified_profit_bps: float
    time_value_bonus_bps: float
    
    # Estrategia de no-ejecuciÃ³n
    never_execute_strategy: str
    time_extension_method: str
    coherent_exit_conditions: List[str]

class SronaFractalTimeOptionsSystem:
    """
    Sistema que usa opciones para ganar tiempo y fractalizarlo con log(7919)
    Marca probabilidades en marcos coherentes superiores sin ejecutar
    """
    
    def __init__(self, available_capital_usd: float = 10000.0):
        self.gravitational_model = SronaOptionsGravitationalModel()
        self.ammo_calculator = SronaInverseAmmoCalculator()
        self.available_capital = available_capital_usd
        
        # Constantes fractales fundamentales
        self.LOG_7919_CONSTANT = math.log(7919)  # â‰ˆ 8.977240362537735
        self.FRACTAL_DIMENSION_BASE = 1.618  # ProporciÃ³n Ã¡urea como dimensiÃ³n base
        self.TIME_DILATION_FACTOR = 2.718281828  # e (nÃºmero de Euler)
        self.COHERENT_FRAME_RESONANCE = 40.97  # Frecuencia coherente en Hz
        
        # ParÃ¡metros de extensiÃ³n temporal
        self.MIN_TIME_EXTENSION_DAYS = 7  # MÃ­nimo 7 dÃ­as de opciones
        self.MAX_TIME_EXTENSION_DAYS = 90  # MÃ¡ximo 90 dÃ­as
        self.NEVER_EXECUTE_THRESHOLD = 0.85  # 85% probabilidad de nunca ejecutar (ajustado)
        self.SUPERPOSITION_PRESERVATION_TARGET = 0.95  # 95% preservaciÃ³n de superposiciÃ³n
        self.MAX_LEVERAGE = 125.0  # MÃXIMO LEVERAGE SIEMPRE
        
        # Marcos coherentes superiores
        self.COHERENT_FRAME_LEVELS = [
            0.786,  # Nivel base (proporciÃ³n Ã¡urea^-1)
            0.888,  # Nivel Î»=888MHz
            0.919,  # Nivel log(7919)/10
            0.950,  # Nivel superior
            0.999   # Nivel cuÃ¡ntico mÃ¡ximo
        ]
        
    async def analyze_fractal_time_opportunities(self) -> List[CoherentFrameResult]:
        """
        AnÃ¡lisis de oportunidades con fractalizaciÃ³n temporal
        Las opciones extienden el tiempo, nunca se ejecutan
        """
        
        print("ğŸŒ€ Iniciando anÃ¡lisis fractal temporal SRONA...")
        print("ğŸ“… Las opciones son para GANAR TIEMPO, no para ejecutar")
        
        # 1. AnÃ¡lisis gravitacional base
        gravitational_analysis = await self.gravitational_model.run_gravitational_analysis()
        raw_opportunities = gravitational_analysis['top_naked_opportunities']
        
        # 2. AnÃ¡lisis de funding rates y volatilidad temporal
        market_conditions = await self._analyze_market_temporal_conditions()
        
        print(f"â° Analizando {len(raw_opportunities)} oportunidades con fractalizaciÃ³n temporal...")
        
        # 3. Para cada oportunidad, crear marco temporal fractal
        coherent_frame_results = []
        
        for raw_opp in raw_opportunities:
            try:
                # Crear marco temporal fractal
                fractal_timeframe = self._create_fractal_timeframe(raw_opp, market_conditions)
                
                # DiseÃ±ar extensiÃ³n de opciones (Ãºltimo recurso)
                option_extension = self._design_option_time_extension(raw_opp, fractal_timeframe)
                
                # Calcular resultado en marco coherente superior
                coherent_result = await self._calculate_coherent_frame_result(
                    raw_opp, fractal_timeframe, option_extension, market_conditions
                )
                
                if coherent_result and self._validates_coherent_frame(coherent_result):
                    coherent_frame_results.append(coherent_result)
                    
            except Exception as e:
                print(f"âš ï¸ Error en anÃ¡lisis fractal para {raw_opp['source_asset']}/{raw_opp['target_asset']}: {e}")
                continue
        
        # 4. Ordenar por fuerza de marco coherente
        coherent_frame_results.sort(key=lambda x: x.coherent_frame_strength, reverse=True)
        
        print(f"âœ¨ {len(coherent_frame_results)} marcos coherentes superiores identificados")
        
        return coherent_frame_results[:5]  # Top 5 marcos coherentes
    
    def _create_fractal_timeframe(self, raw_opportunity: Dict, market_conditions: Dict) -> FractalTimeFrame:
        """
        Crea marco temporal fractal usando log(7919)
        El tiempo se fractaliza para extender la superposiciÃ³n cuÃ¡ntica
        """
        
        # Tiempo base desde edge de picosegundos
        edge_ps = raw_opportunity['edge_advantage_ps']
        base_time_minutes = edge_ps * 60  # Convertir a minutos base
        
        # DimensiÃ³n fractal basada en fuerza gravitacional
        gravitational_force = raw_opportunity['gravitational_force']
        fractal_dimension = self.FRACTAL_DIMENSION_BASE * (1 + math.log(gravitational_force + 1) / 10)
        
        # Multiplicador log(7919) - LA CLAVE FRACTAL
        log_multiplier = self.LOG_7919_CONSTANT / 10  # Normalizar
        
        # ExtensiÃ³n por coherencia del mercado
        market_volatility = market_conditions.get('volatility', 0.5)
        coherence_extension = 1 + (1 - market_volatility) * 2  # Menos volatilidad = mÃ¡s coherencia
        
        # Buffer temporal de opciones (para ganar tiempo)
        naked_arbitrage = raw_opportunity['naked_arbitrage_potential']
        option_buffer = naked_arbitrage * 1440  # Minutos por dÃ­a base
        
        # Probabilidad de nunca ejecutar (belleza de la fÃ­sica)
        never_execute_prob = min(0.95 + naked_arbitrage * 0.04, 0.999)  # Max 99.9%
        
        return FractalTimeFrame(
            base_time=base_time_minutes,
            fractal_dimension=fractal_dimension,
            log_7919_multiplier=log_multiplier,
            coherence_extension=coherence_extension,
            option_time_buffer=option_buffer,
            never_execute_probability=never_execute_prob
        )
    
    def _design_option_time_extension(self, raw_opportunity: Dict, fractal_frame: FractalTimeFrame) -> OptionTimeExtension:
        """
        DiseÃ±a extensiÃ³n temporal a travÃ©s de opciones
        Las opciones son el ÃšLTIMO RECURSO para ganar tiempo, pero nunca se ejecutan
        """
        
        # DÃ­as base de extensiÃ³n temporal
        total_fractal_time = fractal_frame.get_total_fractal_time()
        base_days = max(int(total_fractal_time / 1440), self.MIN_TIME_EXTENSION_DAYS)  # Convertir a dÃ­as
        
        # ExtensiÃ³n fractal usando log(7919)
        fractal_extended_days = base_days * fractal_frame.log_7919_multiplier
        fractal_extended_days = min(fractal_extended_days, self.MAX_TIME_EXTENSION_DAYS)
        
        # Buffer del strike (lejos del precio actual para nunca ejecutar)
        naked_arbitrage = raw_opportunity['naked_arbitrage_potential']
        strike_buffer = 0.15 + naked_arbitrage * 0.10  # MÃ­nimo 15% buffer, puede llegar a 25%
        
        # Tasa de decaimiento temporal (theta)
        time_decay = 0.02 * (1 - fractal_frame.never_execute_probability)  # Menor decay si nunca se ejecuta
        
        # Confianza en nunca ejecutar
        never_execute_confidence = fractal_frame.never_execute_probability
        
        # PreservaciÃ³n de superposiciÃ³n cuÃ¡ntica
        superposition_preservation = never_execute_confidence * 0.99  # Casi perfecta preservaciÃ³n
        
        return OptionTimeExtension(
            base_expiry_days=base_days,
            fractal_extended_days=fractal_extended_days,
            strike_buffer_percent=strike_buffer,
            time_decay_rate=time_decay,
            never_execute_confidence=never_execute_confidence,
            superposition_preservation=superposition_preservation
        )
    
    async def _calculate_coherent_frame_result(
        self,
        raw_opportunity: Dict,
        fractal_frame: FractalTimeFrame,
        option_extension: OptionTimeExtension,
        market_conditions: Dict
    ) -> Optional[CoherentFrameResult]:
        """
        Calcula resultado en marco coherente superior
        Marca probabilidades sin ejecutar - la belleza de la fÃ­sica cuÃ¡ntica
        """
        
        primary_symbol = raw_opportunity['source_asset']
        secondary_symbol = raw_opportunity['target_asset']
        
        # 1. Estados cuÃ¡nticos extendidos por tiempo fractal
        base_coherence = 0.7  # Coherencia base del colibrÃ­
        time_extension_factor = option_extension.fractal_extended_days / 30  # Factor temporal
        
        extended_colibri_coherence = min(
            base_coherence * (1 + time_extension_factor * 0.3),
            0.999  # MÃ¡ximo 99.9% coherencia
        )
        
        # Supervivencia del halcÃ³n extendida
        base_survival = 0.6  # Supervivencia base
        extended_halcon_survival = min(
            base_survival * (1 + extended_colibri_coherence * 0.5),
            0.995  # MÃ¡ximo 99.5% supervivencia
        )
        
        # DuraciÃ³n de superposiciÃ³n extendida
        superposition_duration = fractal_frame.get_total_fractal_time()
        
        # 2. MARCAR PROBABILIDADES (no ejecutar - belleza de la fÃ­sica)
        
        # Probabilidad de profit marcada (en superposiciÃ³n)
        base_profit_prob = raw_opportunity['naked_arbitrage_potential']
        profit_probability_marked = min(
            base_profit_prob * (1 + extended_colibri_coherence),
            0.95  # MÃ¡ximo 95% para mantener incertidumbre cuÃ¡ntica
        )
        
        # Probabilidad de pÃ©rdida marcada
        loss_probability_marked = (1 - profit_probability_marked) * 0.7  # Reducida por extensiÃ³n temporal
        
        # Probabilidad neutral (ni ganancia ni pÃ©rdida - estado cuÃ¡ntico puro)
        neutral_probability_marked = 1 - profit_probability_marked - loss_probability_marked
        
        # Probabilidad de nunca ejecutar (LA BELLEZA)
        never_execute_prob = option_extension.never_execute_confidence
        
        # 3. MÃ©tricas de tiempo ganado
        time_gained = option_extension.fractal_extended_days * 1440  # Minutos ganados
        
        # Multiplicador de ventaja fractal
        fractal_multiplier = fractal_frame.fractal_dimension * fractal_frame.log_7919_multiplier
        
        # Fuerza del marco coherente
        coherent_strength = (
            extended_colibri_coherence * 0.4 +
            extended_halcon_survival * 0.3 +
            never_execute_prob * 0.3
        )
        
        # 4. Profit potencial en superposiciÃ³n extendida
        
        # Profit base
        base_profit_bps = raw_opportunity['naked_arbitrage_potential'] * 100
        
        # AmplificaciÃ³n fractal del profit
        fractal_amplified_bps = base_profit_bps * fractal_multiplier
        
        # Bonus por valor temporal (tiempo ganado)
        time_value_bonus = (time_gained / 1440) * 5  # 5 bps por dÃ­a ganado
        
        # Profit total extendido
        extended_profit_bps = base_profit_bps + fractal_amplified_bps + time_value_bonus
        
        # 5. Estrategia de no-ejecuciÃ³n
        if never_execute_prob > 0.98:
            never_execute_strategy = "QUANTUM_SUPERPOSITION_ETERNAL"
        elif never_execute_prob > 0.95:
            never_execute_strategy = "FRACTAL_TIME_EXTENSION"
        elif never_execute_prob > 0.90:
            never_execute_strategy = "COHERENT_FRAME_HOLD"
        else:
            never_execute_strategy = "OPTION_TIME_BUFFER"
        
        # MÃ©todo de extensiÃ³n temporal
        if option_extension.fractal_extended_days > 60:
            time_method = "LONG_TERM_FRACTAL_EXTENSION"
        elif option_extension.fractal_extended_days > 30:
            time_method = "MEDIUM_TERM_LOG7919_SCALING"
        else:
            time_method = "SHORT_TERM_COHERENT_BUFFER"
        
        # Condiciones de salida coherente (marcos superiores)
        coherent_exits = []
        for level in self.COHERENT_FRAME_LEVELS:
            if coherent_strength >= level:
                coherent_exits.append(f"Coherent_Frame_Level_{level:.3f}")
        
        return CoherentFrameResult(
            opportunity_id=f"FRACTAL_{primary_symbol}_{secondary_symbol}_{int(datetime.now().timestamp())}",
            timestamp=datetime.now().isoformat(),
            pair=f"{primary_symbol}/{secondary_symbol}",
            
            fractal_timeframe=fractal_frame,
            option_extension=option_extension,
            
            extended_colibri_coherence=extended_colibri_coherence,
            extended_halcon_survival=extended_halcon_survival,
            superposition_duration_extended=superposition_duration,
            
            profit_probability_marked=profit_probability_marked,
            loss_probability_marked=loss_probability_marked,
            neutral_probability_marked=neutral_probability_marked,
            never_execute_probability=never_execute_prob,
            
            time_gained_minutes=time_gained,
            fractal_advantage_multiplier=fractal_multiplier,
            coherent_frame_strength=coherent_strength,
            
            extended_profit_potential_bps=extended_profit_bps,
            fractal_amplified_profit_bps=fractal_amplified_bps,
            time_value_bonus_bps=time_value_bonus,
            
            never_execute_strategy=never_execute_strategy,
            time_extension_method=time_method,
            coherent_exit_conditions=coherent_exits
        )
    
    async def _analyze_market_temporal_conditions(self) -> Dict:
        """Analiza condiciones temporales del mercado"""
        
        # SimulaciÃ³n de condiciones de mercado
        return {
            'volatility': np.random.uniform(0.2, 0.8),
            'temporal_coherence': np.random.uniform(0.6, 0.95),
            'fractal_dimension_market': np.random.uniform(1.2, 2.0),
            'time_dilation_factor': np.random.uniform(0.5, 2.0)
        }
    
    def _validates_coherent_frame(self, result: CoherentFrameResult) -> bool:
        """ValidaciÃ³n de marcos coherentes superiores (ajustada para mÃ¡ximo leverage)"""
        
        return (
            result.coherent_frame_strength > 0.65 and  # MÃ­nimo 65% coherencia (reducido)
            result.never_execute_probability > 0.80 and  # 80% probabilidad nunca ejecutar
            result.extended_colibri_coherence > 0.75 and  # ColibrÃ­ coherente (reducido)
            result.extended_halcon_survival > 0.65 and  # HalcÃ³n sobrevive (reducido)
            result.time_gained_minutes > 720  # MÃ­nimo 12 horas ganadas (reducido)
        )
    
    def generate_fractal_time_report(self, results: List[CoherentFrameResult]) -> Dict:
        """Genera reporte de marcos coherentes superiores con tiempo fractal"""
        
        if not results:
            return {
                'fractal_time_report': {
                    'status': 'NO_COHERENT_FRAMES',
                    'message': 'No se encontraron marcos coherentes superiores vÃ¡lidos'
                }
            }
        
        # MÃ©tricas agregadas
        total_time_gained = sum(r.time_gained_minutes for r in results) / 1440  # DÃ­as
        avg_coherent_strength = np.mean([r.coherent_frame_strength for r in results])
        avg_never_execute_prob = np.mean([r.never_execute_probability for r in results])
        total_fractal_profit = sum(r.extended_profit_potential_bps for r in results)
        
        # Generar Ã³rdenes coherentes (que nunca se ejecutan)
        coherent_orders = []
        for result in results:
            order = {
                'opportunity_id': result.opportunity_id,
                'pair': result.pair,
                'never_execute_strategy': result.never_execute_strategy,
                'time_extension_method': result.time_extension_method,
                
                'fractal_timeframe': {
                    'total_fractal_time_hours': result.fractal_timeframe.get_total_fractal_time() / 60,
                    'fractal_dimension': result.fractal_timeframe.fractal_dimension,
                    'log_7919_multiplier': result.fractal_timeframe.log_7919_multiplier,
                    'never_execute_probability': result.fractal_timeframe.never_execute_probability
                },
                
                'option_extension': {
                    'fractal_extended_days': result.option_extension.fractal_extended_days,
                    'strike_buffer_percent': result.option_extension.strike_buffer_percent,
                    'never_execute_confidence': result.option_extension.never_execute_confidence,
                    'superposition_preservation': result.option_extension.superposition_preservation
                },
                
                'quantum_states_extended': {
                    'colibri_coherence': result.extended_colibri_coherence,
                    'halcon_survival': result.extended_halcon_survival,
                    'superposition_duration_hours': result.superposition_duration_extended / 60
                },
                
                'marked_probabilities': {
                    'profit_probability': result.profit_probability_marked,
                    'loss_probability': result.loss_probability_marked,
                    'neutral_probability': result.neutral_probability_marked,
                    'never_execute_probability': result.never_execute_probability
                },
                
                'time_advantage': {
                    'time_gained_days': result.time_gained_minutes / 1440,
                    'fractal_multiplier': result.fractal_advantage_multiplier,
                    'coherent_frame_strength': result.coherent_frame_strength
                },
                
                'profit_potential_extended': {
                    'extended_profit_bps': result.extended_profit_potential_bps,
                    'fractal_amplified_bps': result.fractal_amplified_profit_bps,
                    'time_value_bonus_bps': result.time_value_bonus_bps
                },
                
                'coherent_exit_conditions': result.coherent_exit_conditions
            }
            coherent_orders.append(order)
        
        return {
            'srona_fractal_time_report': {
                'generation_timestamp': datetime.now().isoformat(),
                'system_version': 'SRONA_FRACTAL_TIME_OPTIONS_v1.0',
                'philosophy': 'Las opciones son para GANAR TIEMPO, fractalizarlo con log(7919). Es el Ãºltimo recurso, pero nunca se ejecuta. Belleza de la fÃ­sica: marcar probabilidades en marcos coherentes superiores.',
                
                'summary_metrics': {
                    'total_coherent_frames': len(results),
                    'total_time_gained_days': total_time_gained,
                    'average_coherent_strength': avg_coherent_strength,
                    'average_never_execute_probability': avg_never_execute_prob,
                    'total_fractal_profit_potential_bps': total_fractal_profit
                },
                
                'fractal_constants': {
                    'log_7919_constant': self.LOG_7919_CONSTANT,
                    'fractal_dimension_base': self.FRACTAL_DIMENSION_BASE,
                    'never_execute_threshold': self.NEVER_EXECUTE_THRESHOLD,
                    'superposition_preservation_target': self.SUPERPOSITION_PRESERVATION_TARGET
                },
                
                'coherent_frame_orders': coherent_orders,
                
                'fractal_equations': [
                    'Tiempo_Fractal = log(7919) Ã— Coherence_Quantum Ã— Option_Time_Extension',
                    'Profit_Potential = Base_Arbitrage Ã— Time_Fractal_Multiplier Ã— Never_Execute_Bonus',
                    'Never_Execute_Probability = 0.95 + Naked_Arbitrage Ã— 0.04 (mÃ¡x 99.9%)',
                    'Coherent_Frame_Strength = Extended_Coherence Ã— Survival Ã— Never_Execute'
                ]
            }
        }

# FunciÃ³n principal
async def run_fractal_time_analysis(capital_usd: float = 10000.0) -> Dict:
    """Ejecuta anÃ¡lisis completo de tiempo fractal con opciones"""
    
    system = SronaFractalTimeOptionsSystem(available_capital_usd=capital_usd)
    
    # Analizar marcos coherentes superiores
    fractal_results = await system.analyze_fractal_time_opportunities()
    
    # Generar reporte fractal
    fractal_report = system.generate_fractal_time_report(fractal_results)
    
    return fractal_report

# Script de prueba
if __name__ == "__main__":
    async def main():
        print("ğŸŒ€ Iniciando SRONA Fractal Time Options System...")
        print("â° FilosofÃ­a: Las opciones son para GANAR TIEMPO, fractalizarlo con log(7919)")
        print("ğŸš« Nunca se ejecutan - esa es la belleza de la fÃ­sica cuÃ¡ntica")
        
        report = await run_fractal_time_analysis(capital_usd=50000.0)
        
        if 'srona_fractal_time_report' in report:
            fractal_data = report['srona_fractal_time_report']
            
            print(f"\nğŸ“Š REPORTE FRACTAL TIME OPTIONS:")
            print(f"FilosofÃ­a: {fractal_data['philosophy']}")
            
            metrics = fractal_data['summary_metrics']
            print(f"\nMARCOS COHERENTES SUPERIORES:")
            print(f"Total marcos: {metrics['total_coherent_frames']}")
            print(f"Tiempo ganado: {metrics['total_time_gained_days']:.1f} dÃ­as")
            print(f"Coherencia promedio: {metrics['average_coherent_strength']:.3f}")
            print(f"Probabilidad nunca ejecutar: {metrics['average_never_execute_probability']:.1%}")
            print(f"Profit fractal potencial: {metrics['total_fractal_profit_potential_bps']:.1f} bps")
            
            constants = fractal_data['fractal_constants']
            print(f"\nCONSTANTES FRACTALES:")
            print(f"log(7919) = {constants['log_7919_constant']:.6f}")
            print(f"DimensiÃ³n fractal base = {constants['fractal_dimension_base']:.3f}")
            print(f"Umbral nunca ejecutar = {constants['never_execute_threshold']:.1%}")
            
            if fractal_data.get('coherent_frame_orders'):
                print(f"\nâœ¨ TOP 3 MARCOS COHERENTES SUPERIORES:")
                
                for i, order in enumerate(fractal_data['coherent_frame_orders'][:3], 1):
                    print(f"\n{i}. {order['pair']} - {order['never_execute_strategy']}")
                    
                    ft = order['fractal_timeframe']
                    print(f"   â° Tiempo fractal: {ft['total_fractal_time_hours']:.1f} horas")
                    print(f"   ğŸ“ DimensiÃ³n fractal: {ft['fractal_dimension']:.3f}")
                    print(f"   ğŸ”¢ Multiplicador log(7919): {ft['log_7919_multiplier']:.3f}")
                    print(f"   ğŸš« Nunca ejecutar: {ft['never_execute_probability']:.1%}")
                    
                    oe = order['option_extension']
                    print(f"   ğŸ“… DÃ­as extendidos: {oe['fractal_extended_days']:.1f}")
                    print(f"   ğŸ’« PreservaciÃ³n superposiciÃ³n: {oe['superposition_preservation']:.1%}")
                    
                    mp = order['marked_probabilities']
                    print(f"   ğŸ“ˆ Prob. profit marcada: {mp['profit_probability']:.1%}")
                    print(f"   ğŸ“‰ Prob. pÃ©rdida marcada: {mp['loss_probability']:.1%}")
                    print(f"   âš–ï¸ Prob. neutral marcada: {mp['neutral_probability']:.1%}")
                    
                    ta = order['time_advantage']
                    print(f"   â±ï¸ Tiempo ganado: {ta['time_gained_days']:.1f} dÃ­as")
                    print(f"   ğŸŒ€ Multiplicador fractal: {ta['fractal_multiplier']:.3f}")
                    print(f"   ğŸ’ Fuerza marco coherente: {ta['coherent_frame_strength']:.3f}")
        else:
            print(f"\nâŒ {report}")
    
    asyncio.run(main())
