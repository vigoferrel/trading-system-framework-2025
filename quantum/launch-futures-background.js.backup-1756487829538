
// Constantes físicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * LAUNCH FUTURES BOT BACKGROUND
 * =============================
 * Launcher para ejecutar el bot de Futuros (UM) en segundo plano con manejo de PID y logs.
 * Ejecuta: quantum/integrated-system.js
 */

require('dotenv').config({ path: '../.env' });
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const CONFIG = {
  scriptPath: path.join(__dirname, 'integrated-system.js'),
  logsDir: path.join(__dirname, '../logs'),
  logFile: path.join(__dirname, '../logs/futures-launch.log'),
  pidFile: path.join(__dirname, '../logs/futures-launch.pid'),
  nodeArgs: [],
};

class FuturesLauncher {
  constructor(cfg) {
    this.config = cfg;
    this.childProcess = null;
    this.ensureDirectories();
  }

  ensureDirectories() {
    try {
      if (!fs.existsSync(this.config.logsDir)) {
        fs.mkdirSync(this.config.logsDir, { recursive: true });
      }
    } catch (e) {
      console.error('Error creando directorios de log:', e?.message || e);
    }
  }

  checkEnv() {
    const required = ['BINANCE_API_KEY', 'BINANCE_API_SECRET'];
    const missing = required.filter((k) => !process.env[k]);
    if (missing.length) {
      throw new Error(`Faltan variables de entorno: ${missing.join(', ')}`);
    }
  }

  isProcessRunning() {
    try {
      if (fs.existsSync(this.config.pidFile)) {
        const pid = parseInt(fs.readFileSync(this.config.pidFile, 'utf8'));
        if (!pid || Number.isNaN(pid)) return false;
        try {
          process.kill(pid, 0);
          return true;
        } catch (_) {
          try { fs.unlinkSync(this.config.pidFile); } catch {}
          return false;
        }
      }
      return false;
    } catch (e) {
      console.warn('Aviso verificando proceso:', e?.message || e);
      return false;
    }
  }

  async start() {
    try {
      console.log('🚀 Lanzando FUTURES BOT en segundo plano...');
      this.checkEnv();

      if (this.isProcessRunning()) {
        const pid = fs.readFileSync(this.config.pidFile, 'utf8');
        console.warn(`⚠️ Ya existe un proceso ejecutándose (PID ${pid})`);
        return false;
      }

      const child = spawn('node', [this.config.scriptPath, ...this.config.nodeArgs], {
        detached: true,
        stdio: ['ignore', 'pipe', 'pipe'],
        env: process.env,
      });

      this.childProcess = child;

      const out = fs.createWriteStream(this.config.logFile, { flags: 'a' });
      const err = fs.createWriteStream(this.config.logFile, { flags: 'a' });
      child.stdout.pipe(out);
      child.stderr.pipe(err);

      fs.writeFileSync(this.config.pidFile, String(child.pid));

      child.unref();

      console.log('✅ Proceso iniciado');
      console.log(`📊 PID: ${child.pid}`);
      console.log(`📝 Log: ${this.config.logFile}`);
      return true;
    } catch (e) {
      console.error('❌ Error al iniciar:', e?.message || e);
      return false;
    }
  }

  async stop() {
    try {
      if (!fs.existsSync(this.config.pidFile)) {
        console.log('⚠️ No hay proceso en ejecución');
        return false;
      }
      const pid = parseInt(fs.readFileSync(this.config.pidFile, 'utf8'));
      console.log(`🛑 Deteniendo proceso PID=${pid} ...`);

      try {
        process.kill(pid, 'SIGTERM');
      } catch (e) {
        console.warn('Aviso enviando SIGTERM:', e?.message || e);
      }

      await new Promise((r) => setTimeout(r, 3000));

      // Verificar si sigue vivo
      try {
        process.kill(pid, 0);
        console.log('🚨 Proceso aún activo, forzando SIGKILL...');
        try {
          process.kill(pid, 'SIGKILL');
        } catch (e) {
          console.warn('Aviso enviando SIGKILL:', e?.message || e);
        }
      } catch {
        // Ya no existe
      }

      try { fs.unlinkSync(this.config.pidFile); } catch {}

      console.log('✅ Proceso detenido');
      return true;
    } catch (e) {
      console.error('❌ Error deteniendo proceso:', e?.message || e);
      return false;
    }
  }

  status() {
    try {
      const running = this.isProcessRunning();
      const pid = running ? parseInt(fs.readFileSync(this.config.pidFile, 'utf8')) : null;
      const status = {
        running,
        pid,
        pidFile: this.config.pidFile,
        logFile: this.config.logFile,
      };
      console.log('📊 Estado del FUTURES BOT:');
      console.log(JSON.stringify(status, null, 2));
      return status;
    } catch (e) {
      const status = { running: false, error: e?.message || e };
      console.log('📊 Estado del FUTURES BOT:');
      console.log(JSON.stringify(status, null, 2));
      return status;
    }
  }

  logs(lines = 100) {
    try {
      if (!fs.existsSync(this.config.logFile)) {
        console.log('⚠️ Aún no existe archivo de logs');
        return;
      }
      const content = fs.readFileSync(this.config.logFile, 'utf8');
      const arr = content.split('\n');
      const slice = arr.slice(-Math.max(1, lines));
      console.log(`📝 Últimas ${Math.min(lines, arr.length)} líneas de ${this.config.logFile}:`);
      console.log('='.repeat(60));
      slice.forEach((line) => line.trim() && console.log(line));
    } catch (e) {
      console.error('❌ Error leyendo logs:', e?.message || e);
    }
  }
}

async function main() {
  const args = process.argv.slice(2);
  const cmd = (args[0] || 'start').toLowerCase();
  const launcher = new FuturesLauncher(CONFIG);

  switch (cmd) {
    case 'start': {
      const ok = await launcher.start();
      process.exit(ok ? 0 : 1);
    }
    case 'stop': {
      const ok = await launcher.stop();
      process.exit(ok ? 0 : 1);
    }
    case 'status': {
      launcher.status();
      process.exit(0);
    }
    case 'logs': {
      const n = parseInt(args[1] || '100', 10);
      launcher.logs(Number.isFinite(n) ? n : 100);
      process.exit(0);
    }
    default: {
      console.log('Uso: node quantum/launch-futures-background.js [start|stop|status|logs] [lines]');
      process.exit(1);
    }
  }
}

if (require.main === module) {
  main().catch((e) => {
    console.error('Error fatal:', e?.message || e);
    process.exit(1);
  });
}

module.exports = { FuturesLauncher: FuturesLauncher, CONFIG };