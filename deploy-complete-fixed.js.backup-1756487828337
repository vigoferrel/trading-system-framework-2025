const { spawn } = require('child_process');
const fs = require('fs');

console.log('üöÄ DESPLIEGUE COMPLETO - SISTEMA CORREGIDO');
console.log('=' .repeat(60));

// Funci√≥n para limpiar puertos
function cleanPorts() {
    console.log('\nüßπ LIMPIANDO PUERTOS...');
    
    const ports = [4601, 4602, 4603, 4604, 4605, 4606];
    
    ports.forEach(port => {
        try {
            // En Windows, usar taskkill para matar procesos en puertos
            const cmd = `netstat -ano | findstr :${port}`;
            const result = require('child_process').execSync(cmd, { encoding: 'utf8' });
            
            if (result) {
                const lines = result.split('\n');
                lines.forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length > 4) {
                        const pid = parts[4];
                        if (pid && pid !== 'PID') {
                            try {
                                require('child_process').execSync(`taskkill /F /PID ${pid}`, { stdio: 'ignore' });
                                console.log(`‚úÖ Puerto ${port} liberado (PID: ${pid})`);
                            } catch (e) {
                                // Ignorar errores si el proceso ya no existe
                            }
                        }
                    }
                });
            }
        } catch (e) {
            // Puerto libre
        }
    });
}

// Funci√≥n para verificar que los archivos corregidos existen
function verifyFiles() {
    console.log('\nüìã VERIFICANDO ARCHIVOS CORREGIDOS...');
    
    const requiredFiles = [
        'core-system-organized.js',
        'qbtc-binance-integration.js',
        'monitor-graficos-server-simple.py',
        'deploy-banda-46-fixed.py'
    ];
    
    let allFilesExist = true;
    
    requiredFiles.forEach(file => {
        if (fs.existsSync(file)) {
            console.log(`‚úÖ ${file} encontrado`);
        } else {
            console.log(`‚ùå ${file} no encontrado`);
            allFilesExist = false;
        }
    });
    
    return allFilesExist;
}

// Funci√≥n para iniciar servicios
function startServices() {
    console.log('\nüöÄ INICIANDO SERVICIOS...');
    
    const services = [
        {
            name: 'QBTC Core',
            command: 'node',
            args: ['core-system-organized.js'],
            port: 4602
        },
        {
            name: 'Monitor de Gr√°ficos',
            command: 'python',
            args: ['monitor-graficos-server-simple.py'],
            port: 4606
        }
    ];
    
    const processes = [];
    
    services.forEach(service => {
        console.log(`\nüìä Iniciando ${service.name} en puerto ${service.port}...`);
        
        const process = spawn(service.command, service.args, {
            stdio: 'pipe',
            shell: true,
            windowsHide: true
        });
        
        process.stdout.on('data', (data) => {
            console.log(`[${service.name}] ${data.toString().trim()}`);
        });
        
        process.stderr.on('data', (data) => {
            console.log(`[${service.name} ERROR] ${data.toString().trim()}`);
        });
        
        process.on('close', (code) => {
            console.log(`[${service.name}] Proceso terminado con c√≥digo ${code}`);
        });
        
        processes.push(process);
        
        // Esperar un poco antes de iniciar el siguiente servicio
        setTimeout(() => {}, 2000);
    });
    
    return processes;
}

// Funci√≥n para verificar que los servicios est√°n funcionando
function verifyServices() {
    console.log('\nüîç VERIFICANDO SERVICIOS...');
    
    const axios = require('axios');
    const services = [
        { name: 'QBTC Core', url: 'http://localhost:4602/health' },
        { name: 'Monitor de Gr√°ficos', url: 'http://localhost:4606/health' }
    ];
    
    services.forEach(async (service) => {
        try {
            const response = await axios.get(service.url, { timeout: 5000 });
            if (response.status === 200) {
                console.log(`‚úÖ ${service.name} est√° funcionando`);
            } else {
                console.log(`‚ùå ${service.name} no responde correctamente`);
            }
        } catch (error) {
            console.log(`‚ùå ${service.name} no est√° disponible: ${error.message}`);
        }
    });
}

// Funci√≥n principal
async function deployComplete() {
    try {
        // 1. Limpiar puertos
        cleanPorts();
        
        // 2. Verificar archivos
        if (!verifyFiles()) {
            console.log('‚ùå Faltan archivos requeridos');
            return;
        }
        
        // 3. Iniciar servicios
        const processes = startServices();
        
        // 4. Esperar un poco para que los servicios se inicien
        console.log('\n‚è∞ Esperando que los servicios se inicien...');
        await new Promise(resolve => setTimeout(resolve, 10000));
        
        // 5. Verificar servicios
        verifyServices();
        
        console.log('\nüéâ DESPLIEGUE COMPLETADO');
        console.log('\nüìä SERVICIOS DISPONIBLES:');
        console.log('‚Ä¢ QBTC Core: http://localhost:4602');
        console.log('‚Ä¢ Monitor de Gr√°ficos: http://localhost:4606');
        console.log('\nüîí SISTEMA PROTEGIDO CONTRA RATE LIMITING');
        console.log('üìà CACHE CU√ÅNTICA ACTIVA');
        console.log('‚úÖ RESPETA EL TRABAJO PREVIO DEL EQUIPO');
        
        // Mantener el script ejecut√°ndose
        console.log('\n‚èπÔ∏è Presiona Ctrl+C para detener los servicios');
        
        process.on('SIGINT', () => {
            console.log('\nüõë Deteniendo servicios...');
            processes.forEach(process => {
                process.kill();
            });
            process.exit(0);
        });
        
    } catch (error) {
        console.error('‚ùå Error durante el despliegue:', error.message);
    }
}

// Ejecutar despliegue
deployComplete();
