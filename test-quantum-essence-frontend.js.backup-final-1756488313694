
// Constantes f√≠sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

const axios = require('axios');

class QuantumEssenceFrontendTester {
    constructor() {
        this.coreUrl = 'http://localhost:4601';
        this.frontendUrl = 'http://localhost:4603';
        this.testResults = [];
    }

    async testEndpoint(url, description, timeout = 5000) {
        try {
            console.log(`[SEARCH] ${description}...`);
            const response = await axios.get(url, { timeout });
            
            if (response.status === 200) {
                console.log(`[OK] ${description}: OK (${response.status})`);
                this.testResults.push({ test: description, status: 'PASS', data: response.data });
                return true;
            } else {
                console.log(`[ERROR] ${description}: Error (${response.status})`);
                this.testResults.push({ test: description, status: 'FAIL', error: `HTTP ${response.status}` });
                return false;
            }
        } catch (error) {
            console.log(`[ERROR] ${description}: ${error.message}`);
            this.testResults.push({ test: description, status: 'FAIL', error: error.message });
            return false;
        }
    }

    async testCoreSystem() {
        console.log('\n[NIGHT] === PRUEBA DEL SISTEMA CORE ===');
        
        await this.testEndpoint(
            `${this.coreUrl}/health`,
            'Test 1: Health Check del Core'
        );

        await this.testEndpoint(
            `${this.coreUrl}/api/opportunities`,
            'Test 2: Oportunidades del Core',
            10000
        );

        await this.testEndpoint(
            `${this.coreUrl}/api/neural-context`,
            'Test 3: Contexto Neural'
        );

        await this.testEndpoint(
            `${this.coreUrl}/api/market-health`,
            'Test 4: Salud del Mercado'
        );
    }

    async testFrontendSystem() {
        console.log('\nüåä === PRUEBA DEL FRONTEND ===');
        
        await this.testEndpoint(
            `${this.frontendUrl}/`,
            'Test 5: P√°gina Principal del Frontend'
        );

        await this.testEndpoint(
            `${this.frontendUrl}/api/market-sparkline?symbol=BTCUSDT&interval=5m&limit=60`,
            'Test 6: Sparkline BTCUSDT'
        );

        await this.testEndpoint(
            `${this.frontendUrl}/api/orderbook?symbol=ETHUSDT`,
            'Test 7: Orderbook ETHUSDT'
        );

        await this.testEndpoint(
            `${this.frontendUrl}/api/klines?symbol=SOLUSDT&interval=1h&limit=24`,
            'Test 8: Klines SOLUSDT'
        );
    }

    async testQuantumEssenceFeatures() {
        console.log('\n‚öõÔ∏è === PRUEBA DE CARACTER√çSTICAS CU√ÅNTICAS ===');
        
        // Verificar que el frontend puede acceder a los datos del core
        try {
            console.log('[SEARCH] Verificando integraci√≥n cu√°ntica...');
            const opportunitiesResponse = await axios.get(`${this.coreUrl}/api/opportunities`, { timeout: 10000 });
            
            if (opportunitiesResponse.data) {
                const data = opportunitiesResponse.data;
                
                console.log(`[OK] Oportunidades encontradas: ${data.opportunities?.length || 0}`);
                
                if (data.quantum) {
                    console.log('[OK] M√©tricas cu√°nticas disponibles:');
                    Object.entries(data.quantum).forEach(([key, value]) => {
                        console.log(`   ${key}: ${(value * 100).toFixed(1)}%`);
                    });
                }
                
                if (data.neural) {
                    console.log('[OK] Contexto neural disponible');
                }
                
                this.testResults.push({ 
                    test: 'Integraci√≥n Cu√°ntica', 
                    status: 'PASS', 
                    opportunities: data.opportunities?.length || 0,
                    hasQuantum: !!data.quantum,
                    hasNeural: !!data.neural
                });
            }
        } catch (error) {
            console.log(`[ERROR] Error en integraci√≥n cu√°ntica: ${error.message}`);
            this.testResults.push({ test: 'Integraci√≥n Cu√°ntica', status: 'FAIL', error: error.message });
        }
    }

    async runCompleteTest() {
        console.log('[START] === INICIANDO PRUEBA COMPLETA DEL FRONTEND CU√ÅNTICO ===\n');
        
        await this.testCoreSystem();
        await this.testFrontendSystem();
        await this.testQuantumEssenceFeatures();
        
        this.generateReport();
    }

    generateReport() {
        console.log('\n[DATA] === REPORTE FINAL ===');
        
        const totalTests = this.testResults.length;
        const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
        const failedTests = totalTests - passedTests;
        
        console.log(`\n[UP] Resumen:`);
        console.log(`   Total de pruebas: ${totalTests}`);
        console.log(`   Exitosas: ${passedTests}`);
        console.log(`   Fallidas: ${failedTests}`);
        console.log(`   Tasa de √©xito: ${((passedTests / totalTests) * 100).toFixed(1)}%`);
        
        console.log(`\n[OK] Pruebas exitosas:`);
        this.testResults.filter(r => r.status === 'PASS').forEach(result => {
            console.log(`   ‚Ä¢ ${result.test}`);
        });
        
        if (failedTests > 0) {
            console.log(`\n[ERROR] Pruebas fallidas:`);
            this.testResults.filter(r => r.status === 'FAIL').forEach(result => {
                console.log(`   ‚Ä¢ ${result.test}: ${result.error}`);
            });
        }
        
        console.log(`\n[NIGHT] Estado del Sistema:`);
        if (passedTests >= totalTests * 0.8) {
            console.log(`   [GREEN] SISTEMA OPERATIVO - El frontend cu√°ntico est√° funcionando correctamente`);
        } else if (passedTests >= totalTests * 0.6) {
            console.log(`   [YELLOW] SISTEMA PARCIAL - Algunas funciones est√°n operativas`);
        } else {
            console.log(`   [RED] SISTEMA CR√çTICO - Requiere atenci√≥n inmediata`);
        }
        
        console.log(`\n[ENDPOINTS] Pr√≥ximos pasos:`);
        if (failedTests === 0) {
            console.log(`   ‚Ä¢ El frontend est√° listo para capturar la esencia del mercado`);
            console.log(`   ‚Ä¢ Accede a http://localhost:4603 para ver la interfaz`);
            console.log(`   ‚Ä¢ El sistema se actualiza autom√°ticamente cada 5 segundos`);
        } else {
            console.log(`   ‚Ä¢ Revisar los errores reportados`);
            console.log(`   ‚Ä¢ Verificar que ambos sistemas (core y frontend) est√©n ejecut√°ndose`);
            console.log(`   ‚Ä¢ Comprobar la conectividad de red`);
        }
    }
}

// Ejecutar la prueba
async function main() {
    const tester = new QuantumEssenceFrontendTester();
    await tester.runCompleteTest();
}

main().catch(console.error);
