/**
 * üîó INTEGRACI√ìN N√öCLEO PSICOL√ìGICO CON SISTEMA QBTC
 * ==================================================
 * 
 * Integra el n√∫cleo psicol√≥gico con tasas de cambio en el sistema QBTC existente
 */

const { NucleoPsicologicoTasasCambio } = require('./nucleo-psicologico-tasas-cambio.js');
const { QuantumOrchestratorEnhanced } = require('./quantum-orchestrator-enhanced.js');

class IntegracionNucleoPsicologico {
    constructor() {
        // üß† N√öCLEO PSICOL√ìGICO
        this.nucleoPsicologico = new NucleoPsicologicoTasasCambio();
        
        // üß† ORQUESTADOR CU√ÅNTICO ENHANCED
        this.quantumOrchestrator = new QuantumOrchestratorEnhanced();
        
        // üìä ESTADO GLOBAL DEL SISTEMA
        this.estadoGlobal = {
            ultimaActualizacion: null,
            estadoPsicologicoActual: null,
            oportunidadesDetectadas: [],
            alertasPsicologicas: [],
            metricasGlobales: {}
        };
        
        // ‚öôÔ∏è CONFIGURACI√ìN
        this.config = {
            intervaloActualizacion: 30000, // 30 segundos
            umbralAlertaPsicologica: 0.8,
            maxOportunidades: 10,
            activarLogs: true
        };
        
        // üöÄ INICIALIZAR INTEGRACI√ìN
        this.inicializarIntegracion();
    }
    
    /**
     * üöÄ INICIALIZAR INTEGRACI√ìN
     */
    async inicializarIntegracion() {
        console.log('üîó [INTEGRACI√ìN N√öCLEO PSICOL√ìGICO] Inicializando integraci√≥n...');
        
        try {
            // üìä CARGAR DATOS INICIALES
            await this.cargarDatosIniciales();
            
            // üß† ANALIZAR ESTADO PSICOL√ìGICO INICIAL
            await this.analizarEstadoPsicologicoInicial();
            
            // üîÑ INICIAR MONITOREO CONTINUO
            this.iniciarMonitoreoContinuo();
            
            console.log('‚úÖ [INTEGRACI√ìN N√öCLEO PSICOL√ìGICO] Integraci√≥n inicializada correctamente');
            
        } catch (error) {
            console.error('‚ùå [INTEGRACI√ìN N√öCLEO PSICOL√ìGICO] Error en inicializaci√≥n:', error.message);
        }
    }
    
    /**
     * üìä CARGAR DATOS INICIALES
     */
    async cargarDatosIniciales() {
        try {
            // üîç OBTENER DATOS DEL CACHE QBTC
            const response = await fetch('http://localhost:4602/api/market-data');
            if (response.ok) {
                const qbtcData = await response.json();
                this.qbtcData = qbtcData;
                console.log('‚úÖ [DATOS INICIALES] Cache QBTC cargado correctamente');
            } else {
                console.warn('‚ö†Ô∏è [DATOS INICIALES] No se pudo cargar cache QBTC');
                this.qbtcData = null;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è [DATOS INICIALES] Error cargando datos:', error.message);
            this.qbtcData = null;
        }
    }
    
    /**
     * üß† ANALIZAR ESTADO PSICOL√ìGICO INICIAL
     */
    async analizarEstadoPsicologicoInicial() {
        try {
            // üéØ ANALIZAR S√çMBOLOS PRINCIPALES
            const simbolosPrincipales = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
            
            for (const symbol of simbolosPrincipales) {
                const symbolData = this.obtenerDatosSimbolo(symbol);
                if (symbolData) {
                    const estadoPsicologico = await this.nucleoPsicologico.analizarEstadoPsicologico(
                        symbol,
                        symbolData.price || 0,
                        symbolData
                    );
                    
                    if (this.config.activarLogs) {
                        console.log(`üß† [ESTADO INICIAL] ${symbol}: ${estadoPsicologico.estado_psicologico.emocion} (${estadoPsicologico.estado_psicologico.puntuacion.toFixed(3)})`);
                    }
                }
            }
            
        } catch (error) {
            console.error('‚ùå [ESTADO INICIAL] Error:', error.message);
        }
    }
    
    /**
     * üîÑ INICIAR MONITOREO CONTINUO
     */
    iniciarMonitoreoContinuo() {
        setInterval(async () => {
            await this.ejecutarCicloMonitoreo();
        }, this.config.intervaloActualizacion);
        
        console.log(`üîÑ [MONITOREO] Monitoreo continuo iniciado (${this.config.intervaloActualizacion/1000}s)`);
    }
    
    /**
     * üîÑ EJECUTAR CICLO DE MONITOREO
     */
    async ejecutarCicloMonitoreo() {
        try {
            // üìä 1. ACTUALIZAR DATOS
            await this.actualizarDatos();
            
            // üß† 2. ANALIZAR ESTADO PSICOL√ìGICO GLOBAL
            const estadoPsicologicoGlobal = await this.analizarEstadoPsicologicoGlobal();
            
            // üéØ 3. DETECTAR OPORTUNIDADES
            const oportunidades = await this.detectarOportunidades(estadoPsicologicoGlobal);
            
            // üö® 4. VERIFICAR ALERTAS
            const alertas = this.verificarAlertas(estadoPsicologicoGlobal);
            
            // üìä 5. ACTUALIZAR ESTADO GLOBAL
            this.actualizarEstadoGlobal(estadoPsicologicoGlobal, oportunidades, alertas);
            
            // üìà 6. REGISTRAR M√âTRICAS
            this.registrarMetricas(estadoPsicologicoGlobal, oportunidades, alertas);
            
        } catch (error) {
            console.error('‚ùå [CICLO MONITOREO] Error:', error.message);
        }
    }
    
    /**
     * üìä ACTUALIZAR DATOS
     */
    async actualizarDatos() {
        try {
            const response = await fetch('http://localhost:4602/api/market-data');
            if (response.ok) {
                this.qbtcData = await response.json();
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è [ACTUALIZAR DATOS] Error:', error.message);
        }
    }
    
    /**
     * üß† ANALIZAR ESTADO PSICOL√ìGICO GLOBAL
     */
    async analizarEstadoPsicologicoGlobal() {
        try {
            console.log('üß† [AN√ÅLISIS GLOBAL] Iniciando an√°lisis de estado psicol√≥gico global...');
            
            const simbolosAnalizar = this.obtenerSimbolosParaAnalizar();
            console.log(`üìä [AN√ÅLISIS GLOBAL] S√≠mbolos a analizar: ${simbolosAnalizar.length}`);
            
            const estadosPsicologicos = [];
            let simbolosAnalizados = 0;
            
            for (const symbol of simbolosAnalizar) {
                console.log(`üîç [AN√ÅLISIS GLOBAL] Analizando ${symbol}...`);
                
                const symbolData = this.obtenerDatosSimbolo(symbol);
                if (symbolData) {
                    console.log(`‚úÖ [AN√ÅLISIS GLOBAL] Datos obtenidos para ${symbol}:`, {
                        price: symbolData.price,
                        volume: symbolData.volume,
                        hasFunding: !!symbolData.funding_rate,
                        hasVolatility: !!symbolData.volatility
                    });
                    
                    const estadoPsicologico = await this.nucleoPsicologico.analizarEstadoPsicologico(
                        symbol,
                        symbolData.price || 0,
                        symbolData,
                        this.estadoGlobal.estadoPsicologicoActual?.[symbol]
                    );
                    
                    estadosPsicologicos.push({
                        symbol,
                        estado: estadoPsicologico
                    });
                    
                    simbolosAnalizados++;
                    console.log(`‚úÖ [AN√ÅLISIS GLOBAL] ${symbol} analizado exitosamente`);
                } else {
                    console.warn(`‚ö†Ô∏è [AN√ÅLISIS GLOBAL] No se pudieron obtener datos para ${symbol}`);
                }
            }
            
            console.log(`üìä [AN√ÅLISIS GLOBAL] Total s√≠mbolos analizados: ${simbolosAnalizados}/${simbolosAnalizar.length}`);
            
            // üßÆ CALCULAR ESTADO GLOBAL PROMEDIO
            const estadoGlobal = this.calcularEstadoPsicologicoGlobal(estadosPsicologicos);
            
            return {
                estados_individuales: estadosPsicologicos,
                estado_global: estadoGlobal,
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            console.error('‚ùå [ESTADO GLOBAL] Error:', error.message);
            return this.crearEstadoGlobalFallback();
        }
    }
    
    /**
     * üéØ DETECTAR OPORTUNIDADES
     */
    async detectarOportunidades(estadoPsicologicoGlobal) {
        try {
            const oportunidades = [];
            const { estados_individuales } = estadoPsicologicoGlobal;
            
            for (const { symbol, estado } of estados_individuales) {
                // üß† EVALUAR OPORTUNIDAD BASADA EN ESTADO PSICOL√ìGICO
                const oportunidad = this.evaluarOportunidadPsicologica(symbol, estado);
                
                if (oportunidad) {
                    oportunidades.push(oportunidad);
                }
            }
            
            // üìä ORDENAR POR SCORE Y LIMITAR
            oportunidades.sort((a, b) => b.score - a.score);
            return oportunidades.slice(0, this.config.maxOportunidades);
            
        } catch (error) {
            console.error('‚ùå [DETECTAR OPORTUNIDADES] Error:', error.message);
            return [];
        }
    }
    
    /**
     * üö® VERIFICAR ALERTAS
     */
    verificarAlertas(estadoPsicologicoGlobal) {
        const alertas = [];
        const { estado_global, estados_individuales } = estadoPsicologicoGlobal;
        
        // üö® ALERTA DE ESTADO PSICOL√ìGICO EXTREMO
        if (estado_global.puntuacion > this.config.umbralAlertaPsicologica) {
            alertas.push({
                tipo: 'PSICOLOGICO_EXTREMO',
                severidad: 'ALTA',
                mensaje: `Estado psicol√≥gico extremo detectado: ${estado_global.emocion} (${estado_global.puntuacion.toFixed(3)})`,
                timestamp: new Date().toISOString()
            });
        }
        
        // üö® ALERTA DE TRANSICI√ìN PSICOL√ìGICA R√ÅPIDA
        for (const { symbol, estado } of estados_individuales) {
            const transicion = estado.transicion_psicologica;
            if (transicion.velocidad > 0.5) {
                alertas.push({
                    tipo: 'TRANSICION_RAPIDA',
                    severidad: 'MEDIA',
                    simbolo: symbol,
                    mensaje: `Transici√≥n psicol√≥gica r√°pida en ${symbol}: ${transicion.tipo}`,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        return alertas;
    }
    
    /**
     * üìä ACTUALIZAR ESTADO GLOBAL
     */
    actualizarEstadoGlobal(estadoPsicologicoGlobal, oportunidades, alertas) {
        this.estadoGlobal = {
            ultimaActualizacion: new Date().toISOString(),
            estadoPsicologicoActual: estadoPsicologicoGlobal,
            oportunidadesDetectadas: oportunidades,
            alertasPsicologicas: alertas,
            metricasGlobales: this.calcularMetricasGlobales(estadoPsicologicoGlobal, oportunidades, alertas)
        };
    }
    
    /**
     * üìà REGISTRAR M√âTRICAS
     */
    registrarMetricas(estadoPsicologicoGlobal, oportunidades, alertas) {
        if (this.config.activarLogs) {
            const { estado_global } = estadoPsicologicoGlobal;
            console.log(`üìä [M√âTRICAS] Estado: ${estado_global.emocion} (${estado_global.puntuacion.toFixed(3)}) | Oportunidades: ${oportunidades.length} | Alertas: ${alertas.length}`);
        }
    }
    
    // üõ†Ô∏è M√âTODOS AUXILIARES
    
    obtenerDatosSimbolo(symbol) {
        if (!this.qbtcData) {
            console.warn(`‚ö†Ô∏è [DATA INGESTION] No hay datos QBTC disponibles para ${symbol}`);
            return null;
        }
        
        // üîç BUSCAR EN SPOT
        if (this.qbtcData.spot && this.qbtcData.spot[symbol]) {
            console.log(`‚úÖ [DATA INGESTION] ${symbol} encontrado en SPOT`);
            return this.qbtcData.spot[symbol];
        }
        
        // üîç BUSCAR EN FUTURES
        if (this.qbtcData.futures && this.qbtcData.futures[symbol]) {
            console.log(`‚úÖ [DATA INGESTION] ${symbol} encontrado en FUTURES`);
            return this.qbtcData.futures[symbol];
        }
        
        // üîç BUSCAR VARIACIONES DEL S√çMBOLO
        const variaciones = this.buscarVariacionesSimbolo(symbol);
        if (variaciones.length > 0) {
            console.log(`‚úÖ [DATA INGESTION] ${symbol} encontrado como variaci√≥n: ${variaciones[0]}`);
            return this.qbtcData.spot[variaciones[0]] || this.qbtcData.futures[variaciones[0]];
        }
        
        console.warn(`‚ö†Ô∏è [DATA INGESTION] ${symbol} no encontrado en ning√∫n mercado`);
        return null;
    }
    
    buscarVariacionesSimbolo(symbol) {
        const variaciones = [];
        
        if (!this.qbtcData) return variaciones;
        
        // üîç BUSCAR EN SPOT
        if (this.qbtcData.spot) {
            const spotSymbols = Object.keys(this.qbtcData.spot);
            const matches = spotSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
            variaciones.push(...matches);
        }
        
        // üîç BUSCAR EN FUTURES
        if (this.qbtcData.futures) {
            const futuresSymbols = Object.keys(this.qbtcData.futures);
            const matches = futuresSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
            variaciones.push(...matches);
        }
        
        return variaciones;
    }
    
    obtenerSimbolosParaAnalizar() {
        const simbolos = [];
        
        if (this.qbtcData) {
            // üìä AGREGAR S√çMBOLOS SPOT
            if (this.qbtcData.spot) {
                const spotSymbols = Object.keys(this.qbtcData.spot);
                console.log(`üìä [DATA INGESTION] S√≠mbolos SPOT disponibles: ${spotSymbols.length}`);
                simbolos.push(...spotSymbols.slice(0, 20));
            }
            
            // üìä AGREGAR S√çMBOLOS FUTURES
            if (this.qbtcData.futures) {
                const futuresSymbols = Object.keys(this.qbtcData.futures);
                console.log(`üìä [DATA INGESTION] S√≠mbolos FUTURES disponibles: ${futuresSymbols.length}`);
                simbolos.push(...futuresSymbols.slice(0, 20));
            }
        }
        
        // üéØ PRIORIZAR S√çMBOLOS PRINCIPALES
        const simbolosPrincipales = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
        
        // üîç VERIFICAR QU√â S√çMBOLOS PRINCIPALES EST√ÅN DISPONIBLES
        const simbolosDisponibles = simbolosPrincipales.filter(symbol => {
            const disponible = this.verificarDisponibilidadSimbolo(symbol);
            if (disponible) {
                console.log(`‚úÖ [DATA INGESTION] ${symbol} est√° disponible`);
            } else {
                console.warn(`‚ö†Ô∏è [DATA INGESTION] ${symbol} no est√° disponible`);
            }
            return disponible;
        });
        
        const simbolosUnicos = [...new Set([...simbolosDisponibles, ...simbolos])];
        console.log(`üìä [DATA INGESTION] Total s√≠mbolos para analizar: ${simbolosUnicos.length}`);
        
        return simbolosUnicos.slice(0, 50);
    }
    
    verificarDisponibilidadSimbolo(symbol) {
        if (!this.qbtcData) return false;
        
        // üîç VERIFICAR EN SPOT
        if (this.qbtcData.spot && this.qbtcData.spot[symbol]) {
            return true;
        }
        
        // üîç VERIFICAR EN FUTURES
        if (this.qbtcData.futures && this.qbtcData.futures[symbol]) {
            return true;
        }
        
        // üîç VERIFICAR VARIACIONES
        const variaciones = this.buscarVariacionesSimbolo(symbol);
        return variaciones.length > 0;
    }
    
    calcularEstadoPsicologicoGlobal(estadosIndividuales) {
        if (estadosIndividuales.length === 0) {
            return this.nucleoPsicologico.estadosPsicologicos.NEUTRAL;
        }
        
        // üßÆ CALCULAR PROMEDIOS
        const puntuaciones = estadosIndividuales.map(e => e.estado.estado_psicologico.puntuacion);
        const coherencias = estadosIndividuales.map(e => e.estado.estado_psicologico.coherencia);
        const confianzas = estadosIndividuales.map(e => e.estado.estado_psicologico.confianza);
        const energias = estadosIndividuales.map(e => e.estado.estado_psicologico.energia);
        
        const promedioPuntuacion = puntuaciones.reduce((sum, p) => sum + p, 0) / puntuaciones.length;
        const promedioCoherencia = coherencias.reduce((sum, c) => sum + c, 0) / coherencias.length;
        const promedioConfianza = confianzas.reduce((sum, c) => sum + c, 0) / confianzas.length;
        const promedioEnergia = energias.reduce((sum, e) => sum + e, 0) / energias.length;
        
        // üéØ DETERMINAR EMOCI√ìN DOMINANTE
        const emociones = estadosIndividuales.map(e => e.estado.estado_psicologico.emocion);
        const emocionDominante = this.determinarEmocionDominante(emociones);
        
        return {
            puntuacion: promedioPuntuacion,
            coherencia: promedioCoherencia,
            confianza: promedioConfianza,
            energia: promedioEnergia,
            emocion: emocionDominante,
            total_simbolos: estadosIndividuales.length
        };
    }
    
    determinarEmocionDominante(emociones) {
        const conteo = {};
        emociones.forEach(emocion => {
            conteo[emocion] = (conteo[emocion] || 0) + 1;
        });
        
        return Object.keys(conteo).reduce((a, b) => conteo[a] > conteo[b] ? a : b);
    }
    
    evaluarOportunidadPsicologica(symbol, estado) {
        const { estado_psicologico, tasas_cambio, quantum_enhanced } = estado;
        
        // üéØ CRITERIOS DE OPORTUNIDAD
        const criterios = {
            estado_psicologico_favorable: estado_psicologico.puntuacion > 0.7 || estado_psicologico.puntuacion < 0.3,
            tasas_cambio_significativas: tasas_cambio.puntuacion_global > 0.6,
            quantum_enhancement_alto: quantum_enhanced.quantum_enhancement > 0.5,
            transicion_psicologica: estado.transicion_psicologica.tipo !== 'ESTABLE'
        };
        
        // üßÆ CALCULAR SCORE DE OPORTUNIDAD
        const score = this.calcularScoreOportunidad(criterios, estado);
        
        if (score > 0.6) {
            return {
                symbol,
                score,
                tipo: this.determinarTipoOportunidad(estado_psicologico.emocion),
                estado_psicologico: estado_psicologico.emocion,
                puntuacion_psicologica: estado_psicologico.puntuacion,
                tasas_cambio: tasas_cambio.puntuacion_global,
                quantum_enhancement: quantum_enhanced.quantum_enhancement,
                timestamp: new Date().toISOString()
            };
        }
        
        return null;
    }
    
    calcularScoreOportunidad(criterios, estado) {
        let score = 0;
        
        if (criterios.estado_psicologico_favorable) score += 0.3;
        if (criterios.tasas_cambio_significativas) score += 0.25;
        if (criterios.quantum_enhancement_alto) score += 0.25;
        if (criterios.transicion_psicologica) score += 0.2;
        
        return Math.min(score, 1);
    }
    
    determinarTipoOportunidad(emocion) {
        switch (emocion) {
            case 'EUFORIA': return 'VENTA_OPORTUNISTA';
            case 'OPTIMISMO': return 'COMPRA_MOMENTUM';
            case 'PESIMISMO': return 'COMPRA_CONTRARIA';
            case 'PANICO': return 'COMPRA_OPORTUNISTA';
            default: return 'NEUTRAL';
        }
    }
    
    calcularMetricasGlobales(estadoPsicologicoGlobal, oportunidades, alertas) {
        return {
            total_simbolos_analizados: estadoPsicologicoGlobal.estados_individuales.length,
            estado_psicologico_promedio: estadoPsicologicoGlobal.estado_global.puntuacion,
            emocion_dominante: estadoPsicologicoGlobal.estado_global.emocion,
            oportunidades_detectadas: oportunidades.length,
            alertas_activas: alertas.length,
            timestamp: new Date().toISOString()
        };
    }
    
    crearEstadoGlobalFallback() {
        return {
            estados_individuales: [],
            estado_global: this.nucleoPsicologico.estadosPsicologicos.NEUTRAL,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * üìä OBTENER ESTADO GLOBAL ACTUAL
     */
    obtenerEstadoGlobal() {
        return this.estadoGlobal;
    }
    
    /**
     * üéØ OBTENER OPORTUNIDADES DETECTADAS
     */
    obtenerOportunidades() {
        return this.estadoGlobal.oportunidadesDetectadas;
    }
    
    /**
     * üö® OBTENER ALERTAS ACTIVAS
     */
    obtenerAlertas() {
        return this.estadoGlobal.alertasPsicologicas;
    }
}

module.exports = { IntegracionNucleoPsicologico };
