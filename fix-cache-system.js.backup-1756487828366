// Script de correcci√≥n para implementar cach√© real sin simulaciones
// Respeta el trabajo previo del equipo

const fs = require('fs');
const path = require('path');

console.log('üîß CORRIGIENDO SISTEMA DE CACHE - RESPETANDO TRABAJO PREVIO');
console.log('=' .repeat(60));

// Funci√≥n para corregir la implementaci√≥n de cach√©
function fixCacheImplementation() {
    const coreFile = './core-system-organized.js';
    
    if (!fs.existsSync(coreFile)) {
        console.log('‚ùå Archivo core-system-organized.js no encontrado');
        return false;
    }
    
    let content = fs.readFileSync(coreFile, 'utf8');
    
    // Reemplazar la funci√≥n getFuturesData para usar cach√© real
    const newGetFuturesData = `
// Funci√≥n para obtener datos FUTURES de Binance con cach√© cu√°ntica REAL
async function getFuturesData() {
    try {
        const cache = organizedCache.futures;
        
        // PROTECCI√ìN CR√çTICA: Verificar si se debe usar cach√© basado en m√©tricas cu√°nticas
        if (!shouldCallBinance('futures') && Object.keys(cache.ticker).length > 0) {
            updateQuantumMetrics('futures', true, false, false);
            console.log('üìä Usando cach√© cu√°ntica de futuros (protecci√≥n rate limiting)');
            return cache.ticker;
        }
        
        // PROTECCI√ìN CR√çTICA: Verificar si hemos sido baneados recientemente
        if (cache.metrics.rateLimitCount > 3) {
            console.log('üö® Sistema baneado por Binance - Usando cach√© cu√°ntica por 30 minutos');
            cache.lastUpdate = Date.now() + (30 * 60 * 1000); // Forzar 30 minutos de cach√©
            updateQuantumMetrics('futures', true, false, false);
            return cache.ticker;
        }
        
        // Si no hay datos en cach√©, forzar una llamada a Binance una sola vez
        if (Object.keys(cache.ticker).length === 0) {
            console.log('üìä Cache vac√≠a - Forzando llamada inicial a Binance');
        } else {
            // Usar cach√© existente si est√° disponible
            updateQuantumMetrics('futures', true, false, false);
            console.log('üìä Usando cach√© cu√°ntica de futuros');
            return cache.ticker;
        }
        
        // Obtener datos reales de FUTURES con rate limiting inteligente
        updateQuantumMetrics('futures', false, true, false);
        
        // Delay adaptativo basado en m√©tricas
        const baseDelay = 5000; // Aumentar delay base
        const rateLimitDelay = cache.metrics.rateLimitCount * 10000; // 10 segundos adicionales por rate limit
        const totalDelay = baseDelay + rateLimitDelay;
        
        console.log(\`‚è∞ Delay adaptativo: \${totalDelay}ms (rate limits: \${cache.metrics.rateLimitCount})\`);
        await new Promise(resolve => setTimeout(resolve, totalDelay));
        
        const response = await axios.get(\`\${BINANCE_URLS.FUTURES}/fapi/v1/ticker/24hr\`, {
            timeout: 20000, // Aumentar timeout
            headers: {
                'User-Agent': 'QBTC-System/1.0',
                'Accept': 'application/json'
            }
        });
        
        if (response.data && Array.isArray(response.data)) {
            const validData = response.data.filter(item => 
                item && item.symbol && VALID_BINANCE_FUTURES_SYMBOLS.includes(item.symbol)
            );
            
            if (validData.length > 0) {
                cache.ticker = validData;
                cache.lastUpdate = Date.now();
                updateQuantumMetrics('futures', false, true, false);
                console.log(\`üìà Datos FUTURES obtenidos: \${validData.length} s√≠mbolos v√°lidos\`);
                return cache.ticker;
            }
        }
        
        throw new Error('Datos inv√°lidos de Binance');
        
    } catch (error) {
        console.error('‚ùå Error obteniendo datos FUTURES:', error.message);
        
        // Manejo inteligente de errores con m√©tricas cu√°nticas
        if (error.response) {
            if (error.response.status === 418) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('üö® Rate limiting detectado - Aumentando m√©tricas de protecci√≥n');
                console.log('‚ö†Ô∏è Usando cach√© cu√°ntica con datos existentes');
                return cache.ticker;
            } else if (error.response.status === 429) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('üö® Too Many Requests - Aumentando m√©tricas de protecci√≥n');
                console.log('‚ö†Ô∏è Usando cach√© cu√°ntica con datos existentes');
                return cache.ticker;
            }
        }
        
        // Para otros errores, retornar cach√© existente o error
        if (Object.keys(cache.ticker).length > 0) {
            console.log('‚ö†Ô∏è Error de conexi√≥n - Usando cach√© existente');
            return cache.ticker;
        } else {
            throw new Error('No hay datos disponibles en cach√© y no se pueden obtener de Binance');
        }
    }
}`;

    // Buscar y reemplazar la funci√≥n getFuturesData
    const functionRegex = /async function getFuturesData\(\) \{[\s\S]*?\n\}/;
    
    if (functionRegex.test(content)) {
        content = content.replace(functionRegex, newGetFuturesData);
        console.log('‚úÖ Funci√≥n getFuturesData corregida para usar cach√© real');
    } else {
        console.log('‚ùå No se encontr√≥ la funci√≥n getFuturesData');
        return false;
    }
    
    // Eliminar referencias a generateInitialFuturesData
    content = content.replace(/generateInitialFuturesData\(\)/g, '[]');
    console.log('‚úÖ Eliminadas referencias a simulaciones');
    
    // Guardar el archivo corregido
    fs.writeFileSync(coreFile, content, 'utf8');
    console.log('‚úÖ Archivo core-system-organized.js corregido');
    
    return true;
}

// Funci√≥n para verificar que la correcci√≥n funcion√≥
function verifyFix() {
    const coreFile = './core-system-organized.js';
    
    if (!fs.existsSync(coreFile)) {
        console.log('‚ùå Archivo no encontrado despu√©s de la correcci√≥n');
        return false;
    }
    
    const content = fs.readFileSync(coreFile, 'utf8');
    
    // Verificar que no hay simulaciones
    if (content.includes('generateInitialFuturesData')) {
        console.log('‚ùå A√∫n hay referencias a simulaciones');
        return false;
    }
    
    // Verificar que hay cach√© real
    if (content.includes('Usando cach√© cu√°ntica de futuros')) {
        console.log('‚úÖ Cach√© real implementada correctamente');
        return true;
    }
    
    console.log('‚ùå Cach√© real no implementada correctamente');
    return false;
}

// Ejecutar correcci√≥n
console.log('üöÄ Iniciando correcci√≥n del sistema de cach√©...');
const success = fixCacheImplementation();

if (success) {
    console.log('‚úÖ Correcci√≥n completada');
    
    if (verifyFix()) {
        console.log('‚úÖ Verificaci√≥n exitosa - Sistema de cach√© corregido');
        console.log('üìä El sistema ahora usa cach√© real sin simulaciones');
        console.log('üîí Protecci√≥n contra rate limiting implementada');
    } else {
        console.log('‚ùå Verificaci√≥n fallida');
    }
} else {
    console.log('‚ùå Correcci√≥n fallida');
}

console.log('=' .repeat(60));
