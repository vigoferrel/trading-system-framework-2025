
// Constantes f√≠sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * QBTC RATE LIMIT OPTIMIZER
 * Soluci√≥n avanzada para prevenir HTTP 429 errors y optimizar llamadas a API
 * Implementa queue inteligente, backoff exponencial y cache persistente
 */

const fs = require('fs');
const path = require('path');

class QBTCRateLimitOptimizer {
    constructor() {
        this.requestQueue = [];
        this.isProcessing = false;
        this.rateLimits = {
            EAPI: { limit: 400, window: 60000, current: 0, resetTime: 0 },
            FAPI: { limit: 1200, window: 60000, current: 0, resetTime: 0 },
            SAPI: { limit: 6000, window: 60000, current: 0, resetTime: 0 }
        };
        
        this.backoffConfig = {
            initialDelay: 1000,
            maxDelay: 30000,
            multiplier: 2,
            jitter: true
        };
        
        this.cache = new Map();
        this.cacheFile = path.join(__dirname, 'cache', 'rate_limit_cache.json');
        this.statsFile = path.join(__dirname, 'logs', 'rate_limit_stats.json');
        
        this.stats = {
            totalRequests: 0,
            rateLimitHits: 0,
            cacheHits: 0,
            backoffActivations: 0,
            averageResponseTime: 0
        };
        
        this.loadCache();
        this.startCleanupTimer();
    }

    /**
     * OPTIMIZAR REQUEST CON RATE LIMITING INTELIGENTE
     */
    async optimizedRequest(apiType, endpoint, params = {}, options = {}) {
        const requestId = this.generateRequestId(apiType, endpoint, params);
        const cacheKey = this.generateCacheKey(apiType, endpoint, params);
        
        // Verificar cache primero
        const cachedResult = this.getCachedResult(cacheKey, options.cacheTTL || 60000);
        if (cachedResult) {
            this.stats.cacheHits++;
            console.log(`üì¶ [${apiType}] Cache hit for ${endpoint}`);
            return cachedResult;
        }
        
        // Verificar rate limit
        if (this.isRateLimited(apiType)) {
            console.log(`üö¶ [${apiType}] Rate limit reached, queuing request`);
            return this.queueRequest(apiType, endpoint, params, options);
        }
        
        // Ejecutar request
        return this.executeRequest(requestId, apiType, endpoint, params, options);
    }

    /**
     * VERIFICAR ESTADO DE RATE LIMIT
     */
    isRateLimited(apiType) {
        const limit = this.rateLimits[apiType];
        if (!limit) return false;
        
        const now = Date.now();
        
        // Reset counter si ha pasado la ventana
        if (now >= limit.resetTime) {
            limit.current = 0;
            limit.resetTime = now + limit.window;
        }
        
        // Usar 80% del l√≠mite como threshold de seguridad
        const safeLimit = Math.floor(limit.limit * 0.8);
        return limit.current >= safeLimit;
    }

    /**
     * QUEUE INTELIGENTE DE REQUESTS
     */
    async queueRequest(apiType, endpoint, params, options) {
        return new Promise((resolve, reject) => {
            const queueItem = {
                id: this.generateRequestId(apiType, endpoint, params),
                apiType,
                endpoint,
                params,
                options,
                resolve,
                reject,
                timestamp: Date.now(),
                priority: options.priority || 5
            };
            
            // Insertar en queue ordenado por prioridad
            this.insertByPriority(queueItem);
            
            // Procesar queue si no est√° procesando
            if (!this.isProcessing) {
                this.processQueue();
            }
        });
    }

    /**
     * INSERTAR EN QUEUE POR PRIORIDAD
     */
    insertByPriority(item) {
        let inserted = false;
        for (let i = 0; i < this.requestQueue.length; i++) {
            if (item.priority < this.requestQueue[i].priority) {
                this.requestQueue.splice(i, 0, item);
                inserted = true;
                break;
            }
        }
        
        if (!inserted) {
            this.requestQueue.push(item);
        }
        
        console.log(`[LIST] [${item.apiType}] Queued ${item.endpoint} (Priority: ${item.priority}, Queue size: ${this.requestQueue.length})`);
    }

    /**
     * PROCESAR QUEUE DE REQUESTS
     */
    async processQueue() {
        if (this.isProcessing || this.requestQueue.length === 0) {
            return;
        }
        
        this.isProcessing = true;
        console.log(`[RELOAD] Processing queue with ${this.requestQueue.length} items`);
        
        while (this.requestQueue.length > 0) {
            const item = this.requestQueue.shift();
            
            try {
                // Verificar si el request ha expirado
                if (item.options.timeout && (Date.now() - item.timestamp) > item.options.timeout) {
                    console.log(`[TIME] [${item.apiType}] Request ${item.id} expired`);
                    item.reject(new Error('Request timeout'));
                    continue;
                }
                
                // Esperar si hay rate limit
                await this.waitForRateLimit(item.apiType);
                
                // Ejecutar request
                const result = await this.executeRequest(item.id, item.apiType, item.endpoint, item.params, item.options);
                item.resolve(result);
                
                // Delay entre requests para evitar burst
                await this.sleep(this.calculateDelay(item.apiType));
                
            } catch (error) {
                console.error(`[ERROR] [${item.apiType}] Queue processing error for ${item.endpoint}:`, error.message);
                item.reject(error);
            }
        }
        
        this.isProcessing = false;
        console.log(`[OK] Queue processing completed`);
    }

    /**
     * ESPERAR HASTA QUE RATE LIMIT SE LIBERE
     */
    async waitForRateLimit(apiType) {
        const limit = this.rateLimits[apiType];
        if (!limit) return;
        
        while (this.isRateLimited(apiType)) {
            const waitTime = Math.min(limit.resetTime - Date.now(), 5000);
            if (waitTime > 0) {
                console.log(`‚è≥ [${apiType}] Waiting ${waitTime}ms for rate limit reset`);
                await this.sleep(waitTime);
            }
        }
    }

    /**
     * EJECUTAR REQUEST CON BACKOFF EXPONENCIAL
     */
    async executeRequest(requestId, apiType, endpoint, params, options) {
        const startTime = Date.now();
        let attempt = 0;
        let delay = this.backoffConfig.initialDelay;
        
        while (attempt < (options.maxRetries || 3)) {
            try {
                console.log(`[START] [${apiType}] Executing ${endpoint} (Attempt ${attempt + 1})`);
                
                // Simular llamada a API (reemplazar con llamada real)
                const result = await this.makeAPICall(apiType, endpoint, params);
                
                // Actualizar rate limit counter
                this.updateRateLimit(apiType);
                
                // Cachear resultado
                const cacheKey = this.generateCacheKey(apiType, endpoint, params);
                this.setCachedResult(cacheKey, result, options.cacheTTL || 60000);
                
                // Actualizar estad√≠sticas
                this.updateStats(startTime, false);
                
                return result;
                
            } catch (error) {
                attempt++;
                
                if (error.message.includes('429') || error.message.includes('Too many requests')) {
                    console.log(`üö¶ [${apiType}] Rate limit hit, activating backoff`);
                    this.stats.rateLimitHits++;
                    this.stats.backoffActivations++;
                    
                    // Backoff exponencial con jitter
                    const backoffDelay = this.calculateBackoffDelay(delay, attempt);
                    console.log(`‚è≥ [${apiType}] Backing off for ${backoffDelay}ms`);
                    await this.sleep(backoffDelay);
                    
                    delay = Math.min(delay * this.backoffConfig.multiplier, this.backoffConfig.maxDelay);
                    continue;
                }
                
                // Si no es rate limit error, fallar inmediatamente
                if (attempt >= (options.maxRetries || 3)) {
                    this.updateStats(startTime, true);
                    throw error;
                }
                
                // Retry con delay menor para otros errores
                await this.sleep(1000 * attempt);
            }
        }
        
        throw new Error(`Max retries exceeded for ${endpoint}`);
    }

    /**
     * SIMULAR LLAMADA A API (REEMPLAZAR CON IMPLEMENTACI√ìN REAL)
     */
    async makeAPICall(apiType, endpoint, params) {
        // Esta funci√≥n debe ser reemplazada con la implementaci√≥n real de la API
        await this.sleep(100 + ((Date.now() % 200))); // Simular latencia
        
        // Simular error de rate limit ocasionalmente
        if (((Date.now() % 100) / 100) < 0.1) {
            throw new Error('HTTP 429 Too many requests');
        }
        
        return {
            success: true,
            data: { endpoint, params, timestamp: Date.now() },
            apiType
        };
    }

    /**
     * CALCULAR DELAY DE BACKOFF CON JITTER
     */
    calculateBackoffDelay(baseDelay, attempt) {
        let delay = baseDelay * Math.pow(this.backoffConfig.multiplier, attempt - 1);
        
        if (this.backoffConfig.jitter) {
            // Agregar jitter del ¬±25%
            const jitter = delay * 0.25 * (((Date.now() % 100) / 100) * 2 - 1);
            delay += jitter;
        }
        
        return Math.min(Math.max(delay, 100), this.backoffConfig.maxDelay);
    }

    /**
     * CALCULAR DELAY ENTRE REQUESTS
     */
    calculateDelay(apiType) {
        const baseDelays = {
            EAPI: 150,  // 150ms para EAPI (m√°s conservador)
            FAPI: 50,   // 50ms para FAPI
            SAPI: 10    // 10ms para SAPI
        };
        
        return baseDelays[apiType] || 100;
    }

    /**
     * ACTUALIZAR CONTADOR DE RATE LIMIT
     */
    updateRateLimit(apiType) {
        const limit = this.rateLimits[apiType];
        if (limit) {
            limit.current++;
            
            // Log cuando nos acercamos al l√≠mite
            const usage = (limit.current / limit.limit) * 100;
            if (usage > 70) {
                console.warn(`[WARNING]  [${apiType}] Rate limit usage: ${usage.toFixed(1)}% (${limit.current}/${limit.limit})`);
            }
        }
    }

    /**
     * CACHE MANAGEMENT
     */
    getCachedResult(key, ttl) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        
        if (Date.now() - cached.timestamp > ttl) {
            this.cache.delete(key);
            return null;
        }
        
        return cached.data;
    }

    setCachedResult(key, data, ttl) {
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
            ttl
        });
        
        // Guardar cache peri√≥dicamente
        if (this.cache.size % 100 === 0) {
            this.saveCache();
        }
    }

    /**
     * GENERAR CLAVES DE CACHE Y REQUEST
     */
    generateCacheKey(apiType, endpoint, params) {
        const paramString = JSON.stringify(params, Object.keys(params).sort());
        return `${apiType}:${endpoint}:${Buffer.from(paramString).toString('base64')}`;
    }

    generateRequestId(apiType, endpoint, params) {
        return `${apiType}_${endpoint}_${Date.now()}_${(Date.now() % 1000000).toString(36)}`;
    }

    /**
     * PERSISTENCIA DE CACHE
     */
    loadCache() {
        try {
            if (fs.existsSync(this.cacheFile)) {
                const cacheData = JSON.parse(fs.readFileSync(this.cacheFile, 'utf8'));
                this.cache = new Map(cacheData);
                console.log(`üì¶ Loaded ${this.cache.size} cached items`);
            }
        } catch (error) {
            console.error('[ERROR] Error loading cache:', error.message);
        }
    }

    saveCache() {
        try {
            const cacheDir = path.dirname(this.cacheFile);
            if (!fs.existsSync(cacheDir)) {
                fs.mkdirSync(cacheDir, { recursive: true });
            }
            
            const cacheData = Array.from(this.cache.entries());
            fs.writeFileSync(this.cacheFile, JSON.stringify(cacheData, null, 2));
        } catch (error) {
            console.error('[ERROR] Error saving cache:', error.message);
        }
    }

    /**
     * CLEANUP TIMER
     */
    startCleanupTimer() {
        setInterval(() => {
            this.cleanupExpiredCache();
            this.saveStats();
        }, 300000); // 5 minutos
    }

    cleanupExpiredCache() {
        const now = Date.now();
        let cleaned = 0;
        
        for (const [key, value] of this.cache.entries()) {
            if (now - value.timestamp > value.ttl) {
                this.cache.delete(key);
                cleaned++;
            }
        }
        
        if (cleaned > 0) {
            console.log(`üßπ Cleaned ${cleaned} expired cache entries`);
        }
    }

    /**
     * ESTAD√çSTICAS
     */
    updateStats(startTime, isError) {
        this.stats.totalRequests++;
        
        if (!isError) {
            const responseTime = Date.now() - startTime;
            this.stats.averageResponseTime = 
                (this.stats.averageResponseTime * (this.stats.totalRequests - 1) + responseTime) / this.stats.totalRequests;
        }
    }

    saveStats() {
        try {
            const statsDir = path.dirname(this.statsFile);
            if (!fs.existsSync(statsDir)) {
                fs.mkdirSync(statsDir, { recursive: true });
            }
            
            const statsData = {
                ...this.stats,
                timestamp: new Date().toISOString(),
                rateLimits: this.rateLimits,
                queueSize: this.requestQueue.length,
                cacheSize: this.cache.size
            };
            
            fs.writeFileSync(this.statsFile, JSON.stringify(statsData, null, 2));
        } catch (error) {
            console.error('[ERROR] Error saving stats:', error.message);
        }
    }

    getStats() {
        return {
            ...this.stats,
            rateLimits: this.rateLimits,
            queueSize: this.requestQueue.length,
            cacheSize: this.cache.size,
            cacheHitRate: this.stats.totalRequests > 0 ? (this.stats.cacheHits / this.stats.totalRequests) * 100 : 0,
            rateLimitHitRate: this.stats.totalRequests > 0 ? (this.stats.rateLimitHits / this.stats.totalRequests) * 100 : 0
        };
    }

    /**
     * UTILIDADES
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * RESET RATE LIMITS (PARA TESTING)
     */
    resetRateLimits() {
        Object.keys(this.rateLimits).forEach(apiType => {
            this.rateLimits[apiType].current = 0;
            this.rateLimits[apiType].resetTime = 0;
        });
        console.log('[RELOAD] Rate limits reset');
    }
}

// Crear instancia global
const rateLimitOptimizer = new QBTCRateLimitOptimizer();

module.exports = {
    QBTCRateLimitOptimizer,
    optimizedRequest: (apiType, endpoint, params, options) => 
        rateLimitOptimizer.optimizedRequest(apiType, endpoint, params, options),
    getStats: () => rateLimitOptimizer.getStats(),
    resetRateLimits: () => rateLimitOptimizer.resetRateLimits()
};

// Auto-ejecuci√≥n
if (require.main === module) {
    console.log('\n[FAST] QBTC RATE LIMIT OPTIMIZER ACTIVATED');
    console.log('Intelligent request queuing and caching enabled');
    console.log('Exponential backoff and rate limit protection active');
    
    // Mostrar configuraci√≥n inicial
    console.log('Rate limits:', rateLimitOptimizer.rateLimits);
    console.log('Backoff config:', rateLimitOptimizer.backoffConfig);
}