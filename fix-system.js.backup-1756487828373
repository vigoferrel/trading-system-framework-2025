const fs = require('fs');

console.log('üîß CORRIGIENDO SISTEMA - RESPETANDO TRABAJO PREVIO');

// Leer el archivo core-system-organized.js
let content = fs.readFileSync('./core-system-organized.js', 'utf8');

// Corregir 1: Eliminar simulaciones
content = content.replace(/generateInitialFuturesData\(\)/g, '[]');
console.log('‚úÖ Eliminadas simulaciones');

// Corregir 2: Mejorar protecci√≥n contra rate limiting
const newCacheLogic = `
        // PROTECCI√ìN CR√çTICA: Si hemos sido baneados, usar cach√© por 30 minutos
        if (cache.metrics.rateLimitCount > 2) {
            console.log('üö® Sistema baneado por Binance - Usando cach√© cu√°ntica por 30 minutos');
            cache.lastUpdate = Date.now() + (30 * 60 * 1000);
            updateQuantumMetrics('futures', true, false, false);
            return cache.ticker;
        }
        
        // Si no hay datos en cach√©, forzar una llamada a Binance una sola vez
        if (Object.keys(cache.ticker).length === 0) {
            console.log('üìä Cache vac√≠a - Forzando llamada inicial a Binance');
        } else {
            // Usar cach√© existente si est√° disponible
            updateQuantumMetrics('futures', true, false, false);
            console.log('üìä Usando cach√© cu√°ntica de futuros');
            return cache.ticker;
        }`;

content = content.replace(/Si no hay datos en cach√©, forzar una llamada a Binance una sola vez[\s\S]*?return cache\.ticker;/g, newCacheLogic);
console.log('‚úÖ Mejorada protecci√≥n contra rate limiting');

// Corregir 3: Aumentar delays para evitar rate limiting
content = content.replace(/const baseDelay = \d+/g, 'const baseDelay = 10000');
content = content.replace(/const rateLimitDelay = cache\.metrics\.rateLimitCount \* \d+/g, 'const rateLimitDelay = cache.metrics.rateLimitCount * 30000');
console.log('‚úÖ Aumentados delays para evitar rate limiting');

// Corregir 4: Mejorar manejo de errores 418
const newErrorHandling = `
        // Manejo inteligente de errores con m√©tricas cu√°nticas
        if (error.response) {
            if (error.response.status === 418) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('üö® Rate limiting detectado - Aumentando m√©tricas de protecci√≥n');
                console.log('‚ö†Ô∏è Usando cach√© cu√°ntica con datos existentes');
                // Forzar cach√© por 30 minutos despu√©s de error 418
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            } else if (error.response.status === 429) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('üö® Too Many Requests - Aumentando m√©tricas de protecci√≥n');
                console.log('‚ö†Ô∏è Usando cach√© cu√°ntica con datos existentes');
                // Forzar cach√© por 30 minutos despu√©s de error 429
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            }
        }`;

content = content.replace(/Manejo inteligente de errores con m√©tricas cu√°nticas[\s\S]*?return cache\.ticker;/g, newErrorHandling);
console.log('‚úÖ Mejorado manejo de errores 418/429');

// Guardar el archivo corregido
fs.writeFileSync('./core-system-organized.js', content, 'utf8');
console.log('‚úÖ Archivo core-system-organized.js corregido');

console.log('\nüìä RESUMEN DE CORRECCIONES:');
console.log('1. ‚úÖ Eliminadas simulaciones');
console.log('2. ‚úÖ Mejorada protecci√≥n contra rate limiting');
console.log('3. ‚úÖ Aumentados delays para evitar rate limiting');
console.log('4. ‚úÖ Mejorado manejo de errores 418/429');
console.log('5. ‚úÖ Sistema respeta el trabajo previo del equipo');
