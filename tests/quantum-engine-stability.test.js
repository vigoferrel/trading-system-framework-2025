/**
 * QUANTUM ENGINE STABILITY TESTS
 * ==============================
 * 
 * Suite de tests unitarios para validar la estabilidad numérica
 * del motor cuántico y las funciones matemáticas seguras.
 * 
 * Tests incluidos:
 * - Protección contra divisiones por cero
 * - Estabilidad de funciones trigonométricas
 * - Validación de rangos cuánticos
 * - Performance del cache trigonométrico
 * - Reproducibilidad del Kernel RNG
 * - Invariantes matemáticas
 */

const {
    safeDiv,
    safeTrigSin,
    safeTrigCos,
    safeTrigTan,
    safeLog,
    safeSqrt,
    safeComplexTransform,
    validateRange,
    clampValue,
    kernelRandom,
    SAFE_MATH_CONSTANTS,
    trigCache,
    getTrigCacheStats,
    clearTrigCache
} = require('../src/utils/safe-math');

const {
    KernelRNG,
    kernelRNG,
    random,
    randomInt,
    randomNormal,
    setSeed,
    getSeed,
    qualityTest
} = require('../src/utils/kernel-rng');

const {
    VALIDATION_CONSTANTS,
    isValidValue,
    getLimitsForType
} = require('../src/constants/validation-constants');

describe('🔬 QUANTUM ENGINE STABILITY TESTS', () => {
    
    beforeEach(() => {
        // Limpiar cache antes de cada test
        clearTrigCache();
        
        // Establecer semilla fija para reproducibilidad
        setSeed(12345);
    });
    
    describe('🛡️ Safe Math Functions', () => {
        
        describe('safeDiv - División Segura', () => {
            
            test('debe manejar división por cero correctamente', () => {
                expect(safeDiv(10, 0)).toBe(0);
                expect(safeDiv(10, 0, -1)).toBe(-1);
                expect(safeDiv(-5, 0, 100)).toBe(100);
            });
            
            test('debe manejar divisiones por números muy pequeños', () => {
                const verySmall = 1e-20;\n                const result = safeDiv(10, verySmall);\n                expect(result).toBe(0); // Fallback por divisor muy pequeño\n            });\n            \n            test('debe manejar valores infinitos y NaN', () => {\n                expect(safeDiv(Infinity, 5)).toBe(0);\n                expect(safeDiv(10, Infinity)).toBe(0);\n                expect(safeDiv(NaN, 5)).toBe(0);\n                expect(safeDiv(10, NaN)).toBe(0);\n            });\n            \n            test('debe funcionar correctamente con números válidos', () => {\n                expect(safeDiv(10, 2)).toBe(5);\n                expect(safeDiv(15, 3)).toBe(5);\n                expect(safeDiv(-10, 2)).toBe(-5);\n                expect(safeDiv(7, 3)).toBeCloseTo(2.3333, 4);\n            });\n            \n            test('debe prevenir overflows', () => {\n                const huge = Number.MAX_SAFE_INTEGER;\n                const result = safeDiv(huge, 1e-10);\n                expect(result).toBe(0); // Fallback por overflow\n            });\n        });\n        \n        describe('safeTrigSin - Seno Seguro', () => {\n            \n            test('debe prevenir senos muy cercanos a cero', () => {\n                const nearZero = 1e-15;\n                const result = safeTrigSin(nearZero);\n                expect(Math.abs(result)).toBeGreaterThanOrEqual(SAFE_MATH_CONSTANTS.MIN_TRIG_THRESHOLD);\n            });\n            \n            test('debe usar cache para valores repetidos', () => {\n                const angle = Math.PI / 4;\n                \n                // Primera llamada\n                const result1 = safeTrigSin(angle);\n                \n                // Segunda llamada (debería usar cache)\n                const result2 = safeTrigSin(angle);\n                \n                expect(result1).toBe(result2);\n                \n                const stats = getTrigCacheStats();\n                expect(stats.hits).toBeGreaterThan(0);\n            });\n            \n            test('debe manejar valores infinitos y NaN', () => {\n                expect(safeTrigSin(Infinity)).toBe(0);\n                expect(safeTrigSin(NaN)).toBe(0);\n                expect(safeTrigSin(-Infinity)).toBe(0);\n            });\n            \n            test('debe normalizar valores grandes', () => {\n                const large = 100 * Math.PI;\n                const result = safeTrigSin(large);\n                expect(result).toBeCloseTo(Math.sin(large % (2 * Math.PI)), 10);\n            });\n        });\n        \n        describe('safeTrigTan - Tangente Segura', () => {\n            \n            test('debe manejar singularidades de tangente', () => {\n                const nearSingularity = Math.PI / 2 - 1e-15;\n                const result = safeTrigTan(nearSingularity, 1e6);\n                expect(result).toBe(1e6); // Fallback\n            });\n            \n            test('debe funcionar correctamente lejos de singularidades', () => {\n                const angle = Math.PI / 4;\n                const result = safeTrigTan(angle);\n                expect(result).toBeCloseTo(1, 10);\n            });\n        });\n        \n        describe('safeLog - Logaritmo Seguro', () => {\n            \n            test('debe manejar log(0) y log(negativos)', () => {\n                expect(safeLog(0)).toBe(-10);\n                expect(safeLog(-5)).toBe(-10);\n                expect(safeLog(-1, -20)).toBe(-20);\n            });\n            \n            test('debe funcionar con valores positivos', () => {\n                expect(safeLog(Math.E)).toBeCloseTo(1, 10);\n                expect(safeLog(10)).toBeCloseTo(Math.log(10), 10);\n            });\n        });\n        \n        describe('safeComplexTransform - Transformación Compleja', () => {\n            \n            test('debe usar constantes cuánticas por defecto', () => {\n                const x = 0.5;\n                const result = safeComplexTransform(x);\n                \n                expect(result).toHaveProperty('real');\n                expect(result).toHaveProperty('imag');\n                expect(result).toHaveProperty('magnitude');\n                expect(result).toHaveProperty('normalized');\n                \n                expect(isFinite(result.real)).toBe(true);\n                expect(isFinite(result.imag)).toBe(true);\n                expect(result.magnitude).toBeGreaterThanOrEqual(0);\n            });\n            \n            test('debe manejar valores infinitos', () => {\n                const result = safeComplexTransform(Infinity);\n                expect(result.real).toBe(0);\n                expect(result.imag).toBe(0);\n                expect(result.magnitude).toBe(0);\n                expect(result.normalized).toBe(0);\n            });\n            \n            test('debe preservar propiedades matemáticas', () => {\n                const x1 = 0.25;\n                const x2 = 0.75;\n                \n                const r1 = safeComplexTransform(x1);\n                const r2 = safeComplexTransform(x2);\n                \n                // Verificar que magnitude = sqrt(real² + imag²)\n                const expectedMag1 = Math.sqrt(r1.real * r1.real + r1.imag * r1.imag);\n                expect(r1.magnitude).toBeCloseTo(expectedMag1, 10);\n            });\n        });\n    });\n    \n    describe('🎯 Validation and Range Checking', () => {\n        \n        describe('validateRange', () => {\n            \n            test('debe validar rangos de coherencia', () => {\n                expect(validateRange(0.5, 'coherence')).toBe(true);\n                expect(validateRange(-0.1, 'coherence')).toBe(false);\n                expect(validateRange(1.1, 'coherence')).toBe(false);\n                expect(validateRange(0, 'coherence')).toBe(true);\n                expect(validateRange(1, 'coherence')).toBe(true);\n            });\n            \n            test('debe validar rangos de energía', () => {\n                expect(validateRange(50, 'energy')).toBe(true);\n                expect(validateRange(-10, 'energy')).toBe(false);\n                expect(validateRange(150, 'energy')).toBe(false);\n            });\n            \n            test('debe validar rangos de fase', () => {\n                expect(validateRange(Math.PI, 'phase')).toBe(true);\n                expect(validateRange(-Math.PI, 'phase')).toBe(true);\n                expect(validateRange(3 * Math.PI, 'phase')).toBe(false);\n            });\n            \n            test('debe validar rangos de probabilidad', () => {\n                expect(validateRange(0.5, 'probability')).toBe(true);\n                expect(validateRange(-0.1, 'probability')).toBe(false);\n                expect(validateRange(1.1, 'probability')).toBe(false);\n            });\n        });\n        \n        describe('clampValue', () => {\n            \n            test('debe limitar valores a rango especificado', () => {\n                expect(clampValue(5, 0, 10)).toBe(5);\n                expect(clampValue(-5, 0, 10)).toBe(0);\n                expect(clampValue(15, 0, 10)).toBe(10);\n            });\n            \n            test('debe manejar valores infinitos', () => {\n                expect(clampValue(Infinity, 0, 10)).toBe(0);\n                expect(clampValue(NaN, 0, 10)).toBe(0);\n            });\n        });\n    });\n    \n    describe('🎲 Kernel RNG Tests', () => {\n        \n        describe('Reproducibilidad', () => {\n            \n            test('debe generar secuencias reproducibles con misma semilla', () => {\n                setSeed(54321);\n                const sequence1 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence1.push(random());\n                }\n                \n                setSeed(54321);\n                const sequence2 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence2.push(random());\n                }\n                \n                expect(sequence1).toEqual(sequence2);\n            });\n            \n            test('debe generar secuencias diferentes con semillas diferentes', () => {\n                setSeed(11111);\n                const sequence1 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence1.push(random());\n                }\n                \n                setSeed(22222);\n                const sequence2 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence2.push(random());\n                }\n                \n                expect(sequence1).not.toEqual(sequence2);\n            });\n        });\n        \n        describe('Distribuciones', () => {\n            \n            test('random() debe generar valores en [0,1)', () => {\n                for (let i = 0; i < 100; i++) {\n                    const value = random();\n                    expect(value).toBeGreaterThanOrEqual(0);\n                    expect(value).toBeLessThan(1);\n                }\n            });\n            \n            test('randomInt(n) debe generar enteros en [0,n)', () => {\n                const n = 10;\n                for (let i = 0; i < 100; i++) {\n                    const value = randomInt(n);\n                    expect(Number.isInteger(value)).toBe(true);\n                    expect(value).toBeGreaterThanOrEqual(0);\n                    expect(value).toBeLessThan(n);\n                }\n            });\n            \n            test('randomNormal() debe generar distribución aproximadamente normal', () => {\n                const samples = [];\n                for (let i = 0; i < 1000; i++) {\n                    samples.push(randomNormal(0, 1));\n                }\n                \n                const mean = samples.reduce((a, b) => a + b) / samples.length;\n                const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;\n                \n                // La media debe estar cerca de 0\n                expect(Math.abs(mean)).toBeLessThan(0.1);\n                \n                // La varianza debe estar cerca de 1\n                expect(Math.abs(variance - 1)).toBeLessThan(0.2);\n            });\n        });\n        \n        describe('Test de Calidad', () => {\n            \n            test('qualityTest debe reportar estadísticas válidas', () => {\n                const testResult = qualityTest(5000);\n                \n                expect(testResult).toHaveProperty('samples', 5000);\n                expect(testResult).toHaveProperty('mean');\n                expect(testResult).toHaveProperty('standardDeviation');\n                expect(testResult).toHaveProperty('qualityScore');\n                \n                // La media debe estar cerca de 0.5 para distribución uniforme\n                expect(Math.abs(testResult.mean - 0.5)).toBeLessThan(0.05);\n                \n                // El score de calidad debe ser razonable\n                expect(testResult.qualityScore).toBeGreaterThan(50);\n            });\n        });\n    });\n    \n    describe('🚀 Performance Tests', () => {\n        \n        describe('Cache Trigonométrico', () => {\n            \n            test('debe mejorar performance con valores repetidos', () => {\n                const angle = Math.PI / 3;\n                const iterations = 1000;\n                \n                // Limpiar cache\n                clearTrigCache();\n                \n                const startTime = process.hrtime.bigint();\n                \n                for (let i = 0; i < iterations; i++) {\n                    safeTrigSin(angle);\n                }\n                \n                const endTime = process.hrtime.bigint();\n                const duration = Number(endTime - startTime) / 1e6; // Convertir a ms\n                \n                const stats = getTrigCacheStats();\n                \n                // Debe tener muchos hits de cache\n                expect(stats.hits).toBeGreaterThan(iterations * 0.9);\n                \n                // Performance debe ser razonable (menos de 10ms para 1000 operaciones)\n                expect(duration).toBeLessThan(10);\n            });\n        });\n        \n        describe('Kernel RNG Performance', () => {\n            \n            test('debe generar números a velocidad aceptable', () => {\n                const iterations = 10000;\n                \n                const startTime = process.hrtime.bigint();\n                \n                for (let i = 0; i < iterations; i++) {\n                    random();\n                }\n                \n                const endTime = process.hrtime.bigint();\n                const duration = Number(endTime - startTime) / 1e6; // ms\n                \n                // Debe generar 10,000 números en menos de 50ms\n                expect(duration).toBeLessThan(50);\n                \n                console.log(`[PERFORMANCE] Generados ${iterations} números en ${duration.toFixed(2)}ms`);\n            });\n        });\n    });\n    \n    describe('🔧 Invariantes Matemáticas', () => {\n        \n        test('debe preservar propiedades trigonométricas fundamentales', () => {\n            const angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, Math.PI/2];\n            \n            angles.forEach(angle => {\n                const sin = safeTrigSin(angle);\n                const cos = safeTrigCos(angle);\n                \n                // sin² + cos² = 1 (identidad fundamental)\n                const identity = sin * sin + cos * cos;\n                expect(identity).toBeCloseTo(1, 10);\n            });\n        });\n        \n        test('debe mantener propiedades de transformación compleja', () => {\n            const testValues = [0.1, 0.3, 0.5, 0.7, 0.9];\n            \n            testValues.forEach(x => {\n                const transform = safeComplexTransform(x);\n                \n                // La magnitud debe ser positiva\n                expect(transform.magnitude).toBeGreaterThanOrEqual(0);\n                \n                // El valor normalizado debe estar en [0,1]\n                expect(transform.normalized).toBeGreaterThanOrEqual(0);\n                expect(transform.normalized).toBeLessThanOrEqual(1);\n                \n                // Verificar relación magnitude = sqrt(real² + imag²)\n                const computedMagnitude = Math.sqrt(\n                    transform.real * transform.real + \n                    transform.imag * transform.imag\n                );\n                expect(transform.magnitude).toBeCloseTo(computedMagnitude, 10);\n            });\n        });\n        \n        test('debe mantener consistencia en generación aleatoria', () => {\n            // Test de uniformidad básico\n            const buckets = new Array(10).fill(0);\n            const samples = 10000;\n            \n            for (let i = 0; i < samples; i++) {\n                const value = random();\n                const bucket = Math.floor(value * 10);\n                buckets[Math.min(9, bucket)]++;\n            }\n            \n            // Cada bucket debería tener aproximadamente samples/10 elementos\n            const expected = samples / 10;\n            buckets.forEach(count => {\n                const deviation = Math.abs(count - expected) / expected;\n                expect(deviation).toBeLessThan(0.1); // 10% de desviación máxima\n            });\n        });\n    });\n    \n    describe('🔍 Edge Cases y Robustez', () => {\n        \n        test('debe manejar valores extremos sin fallar', () => {\n            const extremeValues = [\n                Number.MAX_SAFE_INTEGER,\n                Number.MIN_SAFE_INTEGER,\n                Number.POSITIVE_INFINITY,\n                Number.NEGATIVE_INFINITY,\n                NaN,\n                0,\n                -0,\n                1e-100,\n                1e100\n            ];\n            \n            extremeValues.forEach(value => {\n                expect(() => {\n                    safeDiv(value, 2);\n                    safeDiv(2, value);\n                    safeTrigSin(value);\n                    safeTrigCos(value);\n                    safeLog(Math.abs(value) || 1);\n                    safeSqrt(Math.abs(value));\n                }).not.toThrow();\n            });\n        });\n        \n        test('debe manejar arrays vacíos y null en validaciones', () => {\n            expect(() => {\n                validateRange(null, 'coherence');\n                validateRange(undefined, 'energy');\n                clampValue(null, 0, 1);\n                clampValue(undefined, 0, 1);\n            }).not.toThrow();\n        });\n    });\n});\n\n/**\n * COMANDOS PARA EJECUTAR LOS TESTS:\n * \n * 1. Ejecutar todos los tests:\n *    npm test tests/quantum-engine-stability.test.js\n * \n * 2. Ejecutar con coverage:\n *    npm test -- --coverage tests/quantum-engine-stability.test.js\n * \n * 3. Ejecutar solo tests de performance:\n *    npm test -- --testNamePattern=\"Performance\" tests/quantum-engine-stability.test.js\n * \n * 4. Ejecutar con verbose output:\n *    npm test -- --verbose tests/quantum-engine-stability.test.js\n * \n * 5. Ejecutar en modo watch:\n *    npm test -- --watch tests/quantum-engine-stability.test.js\n */
