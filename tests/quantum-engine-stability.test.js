/**
 * QUANTUM ENGINE STABILITY TESTS
 * ==============================
 * 
 * Suite de tests unitarios para validar la estabilidad num√©rica
 * del motor cu√°ntico y las funciones matem√°ticas seguras.
 * 
 * Tests incluidos:
 * - Protecci√≥n contra divisiones por cero
 * - Estabilidad de funciones trigonom√©tricas
 * - Validaci√≥n de rangos cu√°nticos
 * - Performance del cache trigonom√©trico
 * - Reproducibilidad del Kernel RNG
 * - Invariantes matem√°ticas
 */

const {
    safeDiv,
    safeTrigSin,
    safeTrigCos,
    safeTrigTan,
    safeLog,
    safeSqrt,
    safeComplexTransform,
    validateRange,
    clampValue,
    kernelRandom,
    SAFE_MATH_CONSTANTS,
    trigCache,
    getTrigCacheStats,
    clearTrigCache
} = require('../src/utils/safe-math');

const {
    KernelRNG,
    kernelRNG,
    random,
    randomInt,
    randomNormal,
    setSeed,
    getSeed,
    qualityTest
} = require('../src/utils/kernel-rng');

const {
    VALIDATION_CONSTANTS,
    isValidValue,
    getLimitsForType
} = require('../src/constants/validation-constants');

describe('üî¨ QUANTUM ENGINE STABILITY TESTS', () => {
    
    beforeEach(() => {
        // Limpiar cache antes de cada test
        clearTrigCache();
        
        // Establecer semilla fija para reproducibilidad
        setSeed(12345);
    });
    
    describe('üõ°Ô∏è Safe Math Functions', () => {
        
        describe('safeDiv - Divisi√≥n Segura', () => {
            
            test('debe manejar divisi√≥n por cero correctamente', () => {
                expect(safeDiv(10, 0)).toBe(0);
                expect(safeDiv(10, 0, -1)).toBe(-1);
                expect(safeDiv(-5, 0, 100)).toBe(100);
            });
            
            test('debe manejar divisiones por n√∫meros muy peque√±os', () => {
                const verySmall = 1e-20;\n                const result = safeDiv(10, verySmall);\n                expect(result).toBe(0); // Fallback por divisor muy peque√±o\n            });\n            \n            test('debe manejar valores infinitos y NaN', () => {\n                expect(safeDiv(Infinity, 5)).toBe(0);\n                expect(safeDiv(10, Infinity)).toBe(0);\n                expect(safeDiv(NaN, 5)).toBe(0);\n                expect(safeDiv(10, NaN)).toBe(0);\n            });\n            \n            test('debe funcionar correctamente con n√∫meros v√°lidos', () => {\n                expect(safeDiv(10, 2)).toBe(5);\n                expect(safeDiv(15, 3)).toBe(5);\n                expect(safeDiv(-10, 2)).toBe(-5);\n                expect(safeDiv(7, 3)).toBeCloseTo(2.3333, 4);\n            });\n            \n            test('debe prevenir overflows', () => {\n                const huge = Number.MAX_SAFE_INTEGER;\n                const result = safeDiv(huge, 1e-10);\n                expect(result).toBe(0); // Fallback por overflow\n            });\n        });\n        \n        describe('safeTrigSin - Seno Seguro', () => {\n            \n            test('debe prevenir senos muy cercanos a cero', () => {\n                const nearZero = 1e-15;\n                const result = safeTrigSin(nearZero);\n                expect(Math.abs(result)).toBeGreaterThanOrEqual(SAFE_MATH_CONSTANTS.MIN_TRIG_THRESHOLD);\n            });\n            \n            test('debe usar cache para valores repetidos', () => {\n                const angle = Math.PI / 4;\n                \n                // Primera llamada\n                const result1 = safeTrigSin(angle);\n                \n                // Segunda llamada (deber√≠a usar cache)\n                const result2 = safeTrigSin(angle);\n                \n                expect(result1).toBe(result2);\n                \n                const stats = getTrigCacheStats();\n                expect(stats.hits).toBeGreaterThan(0);\n            });\n            \n            test('debe manejar valores infinitos y NaN', () => {\n                expect(safeTrigSin(Infinity)).toBe(0);\n                expect(safeTrigSin(NaN)).toBe(0);\n                expect(safeTrigSin(-Infinity)).toBe(0);\n            });\n            \n            test('debe normalizar valores grandes', () => {\n                const large = 100 * Math.PI;\n                const result = safeTrigSin(large);\n                expect(result).toBeCloseTo(Math.sin(large % (2 * Math.PI)), 10);\n            });\n        });\n        \n        describe('safeTrigTan - Tangente Segura', () => {\n            \n            test('debe manejar singularidades de tangente', () => {\n                const nearSingularity = Math.PI / 2 - 1e-15;\n                const result = safeTrigTan(nearSingularity, 1e6);\n                expect(result).toBe(1e6); // Fallback\n            });\n            \n            test('debe funcionar correctamente lejos de singularidades', () => {\n                const angle = Math.PI / 4;\n                const result = safeTrigTan(angle);\n                expect(result).toBeCloseTo(1, 10);\n            });\n        });\n        \n        describe('safeLog - Logaritmo Seguro', () => {\n            \n            test('debe manejar log(0) y log(negativos)', () => {\n                expect(safeLog(0)).toBe(-10);\n                expect(safeLog(-5)).toBe(-10);\n                expect(safeLog(-1, -20)).toBe(-20);\n            });\n            \n            test('debe funcionar con valores positivos', () => {\n                expect(safeLog(Math.E)).toBeCloseTo(1, 10);\n                expect(safeLog(10)).toBeCloseTo(Math.log(10), 10);\n            });\n        });\n        \n        describe('safeComplexTransform - Transformaci√≥n Compleja', () => {\n            \n            test('debe usar constantes cu√°nticas por defecto', () => {\n                const x = 0.5;\n                const result = safeComplexTransform(x);\n                \n                expect(result).toHaveProperty('real');\n                expect(result).toHaveProperty('imag');\n                expect(result).toHaveProperty('magnitude');\n                expect(result).toHaveProperty('normalized');\n                \n                expect(isFinite(result.real)).toBe(true);\n                expect(isFinite(result.imag)).toBe(true);\n                expect(result.magnitude).toBeGreaterThanOrEqual(0);\n            });\n            \n            test('debe manejar valores infinitos', () => {\n                const result = safeComplexTransform(Infinity);\n                expect(result.real).toBe(0);\n                expect(result.imag).toBe(0);\n                expect(result.magnitude).toBe(0);\n                expect(result.normalized).toBe(0);\n            });\n            \n            test('debe preservar propiedades matem√°ticas', () => {\n                const x1 = 0.25;\n                const x2 = 0.75;\n                \n                const r1 = safeComplexTransform(x1);\n                const r2 = safeComplexTransform(x2);\n                \n                // Verificar que magnitude = sqrt(real¬≤ + imag¬≤)\n                const expectedMag1 = Math.sqrt(r1.real * r1.real + r1.imag * r1.imag);\n                expect(r1.magnitude).toBeCloseTo(expectedMag1, 10);\n            });\n        });\n    });\n    \n    describe('üéØ Validation and Range Checking', () => {\n        \n        describe('validateRange', () => {\n            \n            test('debe validar rangos de coherencia', () => {\n                expect(validateRange(0.5, 'coherence')).toBe(true);\n                expect(validateRange(-0.1, 'coherence')).toBe(false);\n                expect(validateRange(1.1, 'coherence')).toBe(false);\n                expect(validateRange(0, 'coherence')).toBe(true);\n                expect(validateRange(1, 'coherence')).toBe(true);\n            });\n            \n            test('debe validar rangos de energ√≠a', () => {\n                expect(validateRange(50, 'energy')).toBe(true);\n                expect(validateRange(-10, 'energy')).toBe(false);\n                expect(validateRange(150, 'energy')).toBe(false);\n            });\n            \n            test('debe validar rangos de fase', () => {\n                expect(validateRange(Math.PI, 'phase')).toBe(true);\n                expect(validateRange(-Math.PI, 'phase')).toBe(true);\n                expect(validateRange(3 * Math.PI, 'phase')).toBe(false);\n            });\n            \n            test('debe validar rangos de probabilidad', () => {\n                expect(validateRange(0.5, 'probability')).toBe(true);\n                expect(validateRange(-0.1, 'probability')).toBe(false);\n                expect(validateRange(1.1, 'probability')).toBe(false);\n            });\n        });\n        \n        describe('clampValue', () => {\n            \n            test('debe limitar valores a rango especificado', () => {\n                expect(clampValue(5, 0, 10)).toBe(5);\n                expect(clampValue(-5, 0, 10)).toBe(0);\n                expect(clampValue(15, 0, 10)).toBe(10);\n            });\n            \n            test('debe manejar valores infinitos', () => {\n                expect(clampValue(Infinity, 0, 10)).toBe(0);\n                expect(clampValue(NaN, 0, 10)).toBe(0);\n            });\n        });\n    });\n    \n    describe('üé≤ Kernel RNG Tests', () => {\n        \n        describe('Reproducibilidad', () => {\n            \n            test('debe generar secuencias reproducibles con misma semilla', () => {\n                setSeed(54321);\n                const sequence1 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence1.push(random());\n                }\n                \n                setSeed(54321);\n                const sequence2 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence2.push(random());\n                }\n                \n                expect(sequence1).toEqual(sequence2);\n            });\n            \n            test('debe generar secuencias diferentes con semillas diferentes', () => {\n                setSeed(11111);\n                const sequence1 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence1.push(random());\n                }\n                \n                setSeed(22222);\n                const sequence2 = [];\n                for (let i = 0; i < 10; i++) {\n                    sequence2.push(random());\n                }\n                \n                expect(sequence1).not.toEqual(sequence2);\n            });\n        });\n        \n        describe('Distribuciones', () => {\n            \n            test('random() debe generar valores en [0,1)', () => {\n                for (let i = 0; i < 100; i++) {\n                    const value = random();\n                    expect(value).toBeGreaterThanOrEqual(0);\n                    expect(value).toBeLessThan(1);\n                }\n            });\n            \n            test('randomInt(n) debe generar enteros en [0,n)', () => {\n                const n = 10;\n                for (let i = 0; i < 100; i++) {\n                    const value = randomInt(n);\n                    expect(Number.isInteger(value)).toBe(true);\n                    expect(value).toBeGreaterThanOrEqual(0);\n                    expect(value).toBeLessThan(n);\n                }\n            });\n            \n            test('randomNormal() debe generar distribuci√≥n aproximadamente normal', () => {\n                const samples = [];\n                for (let i = 0; i < 1000; i++) {\n                    samples.push(randomNormal(0, 1));\n                }\n                \n                const mean = samples.reduce((a, b) => a + b) / samples.length;\n                const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;\n                \n                // La media debe estar cerca de 0\n                expect(Math.abs(mean)).toBeLessThan(0.1);\n                \n                // La varianza debe estar cerca de 1\n                expect(Math.abs(variance - 1)).toBeLessThan(0.2);\n            });\n        });\n        \n        describe('Test de Calidad', () => {\n            \n            test('qualityTest debe reportar estad√≠sticas v√°lidas', () => {\n                const testResult = qualityTest(5000);\n                \n                expect(testResult).toHaveProperty('samples', 5000);\n                expect(testResult).toHaveProperty('mean');\n                expect(testResult).toHaveProperty('standardDeviation');\n                expect(testResult).toHaveProperty('qualityScore');\n                \n                // La media debe estar cerca de 0.5 para distribuci√≥n uniforme\n                expect(Math.abs(testResult.mean - 0.5)).toBeLessThan(0.05);\n                \n                // El score de calidad debe ser razonable\n                expect(testResult.qualityScore).toBeGreaterThan(50);\n            });\n        });\n    });\n    \n    describe('üöÄ Performance Tests', () => {\n        \n        describe('Cache Trigonom√©trico', () => {\n            \n            test('debe mejorar performance con valores repetidos', () => {\n                const angle = Math.PI / 3;\n                const iterations = 1000;\n                \n                // Limpiar cache\n                clearTrigCache();\n                \n                const startTime = process.hrtime.bigint();\n                \n                for (let i = 0; i < iterations; i++) {\n                    safeTrigSin(angle);\n                }\n                \n                const endTime = process.hrtime.bigint();\n                const duration = Number(endTime - startTime) / 1e6; // Convertir a ms\n                \n                const stats = getTrigCacheStats();\n                \n                // Debe tener muchos hits de cache\n                expect(stats.hits).toBeGreaterThan(iterations * 0.9);\n                \n                // Performance debe ser razonable (menos de 10ms para 1000 operaciones)\n                expect(duration).toBeLessThan(10);\n            });\n        });\n        \n        describe('Kernel RNG Performance', () => {\n            \n            test('debe generar n√∫meros a velocidad aceptable', () => {\n                const iterations = 10000;\n                \n                const startTime = process.hrtime.bigint();\n                \n                for (let i = 0; i < iterations; i++) {\n                    random();\n                }\n                \n                const endTime = process.hrtime.bigint();\n                const duration = Number(endTime - startTime) / 1e6; // ms\n                \n                // Debe generar 10,000 n√∫meros en menos de 50ms\n                expect(duration).toBeLessThan(50);\n                \n                console.log(`[PERFORMANCE] Generados ${iterations} n√∫meros en ${duration.toFixed(2)}ms`);\n            });\n        });\n    });\n    \n    describe('üîß Invariantes Matem√°ticas', () => {\n        \n        test('debe preservar propiedades trigonom√©tricas fundamentales', () => {\n            const angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, Math.PI/2];\n            \n            angles.forEach(angle => {\n                const sin = safeTrigSin(angle);\n                const cos = safeTrigCos(angle);\n                \n                // sin¬≤ + cos¬≤ = 1 (identidad fundamental)\n                const identity = sin * sin + cos * cos;\n                expect(identity).toBeCloseTo(1, 10);\n            });\n        });\n        \n        test('debe mantener propiedades de transformaci√≥n compleja', () => {\n            const testValues = [0.1, 0.3, 0.5, 0.7, 0.9];\n            \n            testValues.forEach(x => {\n                const transform = safeComplexTransform(x);\n                \n                // La magnitud debe ser positiva\n                expect(transform.magnitude).toBeGreaterThanOrEqual(0);\n                \n                // El valor normalizado debe estar en [0,1]\n                expect(transform.normalized).toBeGreaterThanOrEqual(0);\n                expect(transform.normalized).toBeLessThanOrEqual(1);\n                \n                // Verificar relaci√≥n magnitude = sqrt(real¬≤ + imag¬≤)\n                const computedMagnitude = Math.sqrt(\n                    transform.real * transform.real + \n                    transform.imag * transform.imag\n                );\n                expect(transform.magnitude).toBeCloseTo(computedMagnitude, 10);\n            });\n        });\n        \n        test('debe mantener consistencia en generaci√≥n aleatoria', () => {\n            // Test de uniformidad b√°sico\n            const buckets = new Array(10).fill(0);\n            const samples = 10000;\n            \n            for (let i = 0; i < samples; i++) {\n                const value = random();\n                const bucket = Math.floor(value * 10);\n                buckets[Math.min(9, bucket)]++;\n            }\n            \n            // Cada bucket deber√≠a tener aproximadamente samples/10 elementos\n            const expected = samples / 10;\n            buckets.forEach(count => {\n                const deviation = Math.abs(count - expected) / expected;\n                expect(deviation).toBeLessThan(0.1); // 10% de desviaci√≥n m√°xima\n            });\n        });\n    });\n    \n    describe('üîç Edge Cases y Robustez', () => {\n        \n        test('debe manejar valores extremos sin fallar', () => {\n            const extremeValues = [\n                Number.MAX_SAFE_INTEGER,\n                Number.MIN_SAFE_INTEGER,\n                Number.POSITIVE_INFINITY,\n                Number.NEGATIVE_INFINITY,\n                NaN,\n                0,\n                -0,\n                1e-100,\n                1e100\n            ];\n            \n            extremeValues.forEach(value => {\n                expect(() => {\n                    safeDiv(value, 2);\n                    safeDiv(2, value);\n                    safeTrigSin(value);\n                    safeTrigCos(value);\n                    safeLog(Math.abs(value) || 1);\n                    safeSqrt(Math.abs(value));\n                }).not.toThrow();\n            });\n        });\n        \n        test('debe manejar arrays vac√≠os y null en validaciones', () => {\n            expect(() => {\n                validateRange(null, 'coherence');\n                validateRange(undefined, 'energy');\n                clampValue(null, 0, 1);\n                clampValue(undefined, 0, 1);\n            }).not.toThrow();\n        });\n    });\n});\n\n/**\n * COMANDOS PARA EJECUTAR LOS TESTS:\n * \n * 1. Ejecutar todos los tests:\n *    npm test tests/quantum-engine-stability.test.js\n * \n * 2. Ejecutar con coverage:\n *    npm test -- --coverage tests/quantum-engine-stability.test.js\n * \n * 3. Ejecutar solo tests de performance:\n *    npm test -- --testNamePattern=\"Performance\" tests/quantum-engine-stability.test.js\n * \n * 4. Ejecutar con verbose output:\n *    npm test -- --verbose tests/quantum-engine-stability.test.js\n * \n * 5. Ejecutar en modo watch:\n *    npm test -- --watch tests/quantum-engine-stability.test.js\n */
