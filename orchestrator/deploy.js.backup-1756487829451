#!/usr/bin/env node

/**
 * DEPLOY.JS - Configuraci√≥n y despliegue del LLM GEMINI SUPREME ORCHESTRATOR
 * Valida entorno, configura logging, arranca servicios background y expone API
 */

const path = require("path");
const fs = require("fs");
const { LLMSupremeOrchestrator } = require("./LLM_GEMINI_SUPREME_ORCHESTRATOR");

// =======================================
// Configuraci√≥n y validaci√≥n de entorno
// =======================================
function validateEnvironment() {
  const required = [
    "BINANCE_API_KEY",
    "BINANCE_API_SECRET"
  ];

  const missing = required.filter(key => !process.env[key]);
  if (missing.length > 0) {
    console.error(`‚ùå Faltan variables de entorno: ${missing.join(", ")}`);
    process.exit(1);
  }

  console.log("‚úÖ Variables de entorno validadas");
  return true;
}

function ensureDirectories(orchestrator) {
  const dirs = [
    orchestrator.config.srona.logsDir,
    path.join(__dirname, "..", "cache"),
    path.join(__dirname, "..", "logs")
  ];

  for (const dir of dirs) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`üìÅ Directorio creado: ${dir}`);
    }
  }
}

// =======================================
// Configuraci√≥n de logging
// =======================================
class OrchestratorLogger {
  constructor(logDir) {
    this.logDir = logDir;
    this.logFile = path.join(logDir, `orchestrator-${new Date().toISOString().slice(0, 10)}.log`);
  }

  log(level, message, meta = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...meta
    };

    const logLine = `[${timestamp}] ${level.toUpperCase()}: ${message}${Object.keys(meta).length ? ' ' + JSON.stringify(meta) : ''}\n`;
    
    console.log(logLine.trim());
    fs.appendFileSync(this.logFile, logLine);
  }

  info(message, meta) { this.log("info", message, meta); }
  warn(message, meta) { this.log("warn", message, meta); }
  error(message, meta) { this.log("error", message, meta); }
  debug(message, meta) { this.log("debug", message, meta); }
}

// =======================================
// API Express simple para el orquestador
// =======================================
function createOrchestratorAPI(orchestrator, logger) {
  const express = require("express");
  const app = express();
  
  app.use(express.json());

  // Middleware de logging
  app.use((req, res, next) => {
    logger.info(`${req.method} ${req.url}`, { 
      ip: req.ip, 
      userAgent: req.get("User-Agent") 
    });
    next();
  });

  // Rutas principales
  app.get("/health", (req, res) => {
    res.json({ 
      status: "ok", 
      timestamp: Date.now(),
      primes: {
        z: "9+16i",
        lambda: Math.log(7919),
        resonance: "888 MHz"
      }
    });
  });

  app.post("/optimize-portfolio", async (req, res) => {
    try {
      const { aiScores = {}, vigoScores = {}, budgetUSD } = req.body;
      const result = await orchestrator.optimizePortfolio({ aiScores, vigoScores, budgetUSD });
      logger.info("Portfolio optimizado", { decisions: result.decisions.length });
      res.json(result);
    } catch (error) {
      logger.error("Error optimizando portfolio", { error: error.message });
      res.status(500).json({ error: error.message });
    }
  });

  // üöÄ NUEVA RUTA INTELIGENTE - Maximiza ganancias con plano z = 9 + 16i
  app.post("/optimize-intelligent", async (req, res) => {
    try {
      // Inicializar Intelligence Adapter si no existe
      if (!orchestrator.intel) {
        const { IntelligenceAdapter } = require("./IntelligenceAdapter");
        orchestrator.intel = new IntelligenceAdapter();
        await orchestrator.intel.initialize();
        logger.info("Intelligence Adapter inicializado", orchestrator.intel.getSystemsStatus());
      }

      // Obtener scores amplificados con plano z
      const intelligentScores = await orchestrator.intel.getEnhancedScores(orchestrator.config.symbols);
      
      // Optimizar portfolio con inteligencia maximizada
      const result = await orchestrator.optimizePortfolio({ 
        aiScores: intelligentScores, 
        budgetUSD: req.body.budgetUSD || orchestrator.config.budgetUSD
      });

      // Agregar m√©tricas de inteligencia al resultado
      result.intelligence = {
        systems: orchestrator.intel.getSystemsStatus(),
        amplification: "z = 9 + 16i",
        algorithms: ["SRONA Unified", "Markov Primes", "Feynman Path Integrals"]
      };

      logger.info("Portfolio INTELIGENTE optimizado", { 
        decisions: result.decisions.length,
        avgScore: Object.values(intelligentScores).reduce((a,b)=>a+b,0)/Object.keys(intelligentScores).length
      });
      
      res.json(result);
    } catch (error) {
      logger.error("Error en optimizaci√≥n inteligente", { error: error.message });
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/srona/inverse-prime", async (req, res) => {
    try {
      const { carnadaUSD } = req.body;
      const result = await orchestrator.runSronaInversePrime({ carnadaUSD });
      logger.info("SRONA Inverse Prime ejecutado", { code: result.code });
      res.json(result);
    } catch (error) {
      logger.error("Error ejecutando SRONA", { error: error.message });
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/background/launch-srona", async (req, res) => {
    try {
      const result = await orchestrator.launchSronaBackground();
      logger.info("SRONA background lanzado", { pid: result.pid });
      res.json(result);
    } catch (error) {
      logger.error("Error lanzando SRONA background", { error: error.message });
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/background/status", (req, res) => {
    const status = orchestrator.getBackgroundStatus();
    res.json(status);
  });

  app.delete("/background/:name", (req, res) => {
    const result = orchestrator.stopBackgroundByName(req.params.name);
    if (result.ok) {
      logger.info(`Proceso background detenido: ${req.params.name}`);
    }
    res.json(result);
  });

  app.get("/logs/:filename", (req, res) => {
    const content = orchestrator.tryReadRecentLogLines(req.params.filename);
    res.json({ filename: req.params.filename, content });
  });

  return app;
}

// =======================================
// Configuraci√≥n principal del sistema
// =======================================
async function loadConfiguration() {
  const configPath = path.join(__dirname, "..", "config.json");
  let config = {};

  if (fs.existsSync(configPath)) {
    try {
      config = JSON.parse(fs.readFileSync(configPath, "utf8"));
      console.log("üìã Configuraci√≥n cargada desde config.json");
    } catch (e) {
      console.warn("‚ö†Ô∏è Error leyendo config.json, usando configuraci√≥n por defecto");
    }
  }

  // CARGA DIN√ÅMICA DE S√çMBOLOS - Obtener todos los futuros disponibles
  const { SymbolsLoader } = require('./SymbolsLoader');
  const symbolsLoader = new SymbolsLoader();
  let ALL_SYMBOLS;
  
  try {
    console.log('üåê Cargando s√≠mbolos din√°micamente desde Binance...');
    ALL_SYMBOLS = await symbolsLoader.loadAllFuturesSymbols();
    console.log(`‚úÖ S√≠mbolos cargados din√°micamente: ${ALL_SYMBOLS.length} futuros disponibles`);
  } catch (error) {
    console.warn('‚ö†Ô∏è Error cargando s√≠mbolos din√°micos, usando fallback:', error.message);
    ALL_SYMBOLS = symbolsLoader.getFallbackSymbols();
  }
  
  return {
    symbols: config.symbols || ALL_SYMBOLS,
    budgetUSD: Number(process.env.BUDGET_USD) || 1000,
    cacheTtlMs: Number(process.env.CACHE_TTL_MS) || 20000,
    port: Number(process.env.PORT) || 4602,
    aiWeight: Number(process.env.AI_WEIGHT) || 0.25,
    vigoWeight: Number(process.env.VIGO_WEIGHT) || 0.25,
    coreWeight: Number(process.env.CORE_WEIGHT) || 0.50,
    srona: {
      pythonBin: process.env.PYTHON_BIN || "python",
      logsDir: process.env.LOGS_DIR || path.join(__dirname, "..", "logs")
    },
    ...config
  };
}

// =======================================
// Funciones de control de procesos
// =======================================
function setupGracefulShutdown(orchestrator, logger, server) {
  const shutdown = async (signal) => {
    logger.info(`Recibida se√±al ${signal}, cerrando gracefully...`);
    
    // Cerrar servidor HTTP
    server.close(() => {
      logger.info("Servidor HTTP cerrado");
    });

    // Detener procesos background
    const bgStatus = orchestrator.getBackgroundStatus();
    for (const name of Object.keys(bgStatus)) {
      const result = orchestrator.stopBackgroundByName(name);
      logger.info(`Proceso background ${name}: ${result.ok ? "detenido" : result.error}`);
    }

    logger.info("Shutdown completo");
    process.exit(0);
  };

  process.on("SIGTERM", () => shutdown("SIGTERM"));
  process.on("SIGINT", () => shutdown("SIGINT"));
}

// =======================================
// Funci√≥n principal
// =======================================
async function main() {
  console.log("üöÄ INICIANDO LLM GEMINI SUPREME ORCHESTRATOR");
  console.log("=" .repeat(50));
  
  // 1. Validar entorno
  validateEnvironment();
  
  // 2. Cargar configuraci√≥n (as√≠ncrona)
  const config = await loadConfiguration();
  console.log(`üìä Budget: $${config.budgetUSD} | Puerto: ${config.port} | S√≠mbolos: ${config.symbols.length}`);
  
  // 3. Crear orquestador
  const orchestrator = new LLMSupremeOrchestrator(config);
  
  // 4. Asegurar directorios
  ensureDirectories(orchestrator);
  
  // 5. Configurar logging
  const logger = new OrchestratorLogger(config.srona.logsDir);
  logger.info("LLM Gemini Supreme Orchestrator iniciando", { config: config });
  
  // 6. Crear API
  const app = createOrchestratorAPI(orchestrator, logger);
  
  // 7. Iniciar servidor
  const server = app.listen(config.port, () => {
    logger.info(`üåê API disponible en http://localhost:${config.port}`);
    logger.info("üéØ Endpoints principales:");
    logger.info("  POST /optimize-portfolio - Optimizaci√≥n de cartera");
    logger.info("  POST /srona/inverse-prime - Ejecutar SRONA Inverse Prime");
    logger.info("  POST /background/launch-srona - Lanzar SRONA en background");
    logger.info("  GET  /background/status - Estado de procesos background");
    logger.info("  GET  /health - Health check");
    console.log("‚úÖ ORQUESTADOR SUPREMO ACTIVO");
  });
  
  // 8. Configurar cierre graceful
  setupGracefulShutdown(orchestrator, logger, server);

  // 9. Prueba inicial opcional
  if (process.env.RUN_TEST === "true") {
    logger.info("üß™ Ejecutando prueba inicial...");
    try {
      const testResult = await orchestrator.optimizePortfolio({
        aiScores: { BTCUSDT: 0.8, ETHUSDT: 0.7 },
        vigoScores: { BTCUSDT: 0.75, SOLUSDT: 0.65 }
      });
      logger.info("Prueba inicial exitosa", { decisions: testResult.decisions.length });
    } catch (e) {
      logger.error("Error en prueba inicial", { error: e.message });
    }
  }

  return { orchestrator, logger, server };
}

// Ejecutar si es el m√≥dulo principal
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main, loadConfiguration, OrchestratorLogger };
