#!/usr/bin/env python3
"""
VERIFICACI√ìN FINAL - SISTEMA QBTC BANDA 46
Script final para confirmar que el sistema est√° completamente libre de simulaciones
"""

import requests
import json
import time
import re
from datetime import datetime

def print_banner():
    """Imprime el banner del sistema."""
    print("=" * 80)
    print("[ENDPOINTS] VERIFICACI√ìN FINAL - SISTEMA QBTC BANDA 46")
    print("=" * 80)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("[ENDPOINTS] Objetivo: Confirmar sistema 100% libre de simulaciones")
    print("[SEARCH] Verificaci√≥n exhaustiva y precisa")
    print("=" * 80)

def check_qbtc_core_real_data():
    """Verifica que QBTC Core proporcione datos reales de Binance."""
    print("\n[SEARCH] VERIFICACI√ìN 1: QBTC CORE - DATOS REALES DE BINANCE")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                print(f"[OK] QBTC Core respondiendo correctamente")
                print(f"[DATA] Cantidad de s√≠mbolos: {len(futures_data)}")
                
                # Verificar que los datos sean reales
                real_symbols = 0
                simulated_symbols = 0
                
                for item in futures_data[:10]:  # Revisar primeros 10
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    # Verificar que sean s√≠mbolos reales de Binance
                    if symbol and last_price and price_change:
                        if re.match(r'^[A-Z0-9]+USDT$', symbol):
                            real_symbols += 1
                            print(f"[OK] S√≠mbolo real: {symbol} - Precio: {last_price}")
                        else:
                            simulated_symbols += 1
                            print(f"[WARNING] S√≠mbolo sospechoso: {symbol}")
                
                print(f"\n[UP] RESULTADO QBTC CORE:")
                print(f"[OK] S√≠mbolos reales: {real_symbols}")
                print(f"[WARNING] S√≠mbolos sospechosos: {simulated_symbols}")
                
                if real_symbols > 0 and simulated_symbols == 0:
                    print("üéâ QBTC Core: DATOS REALES CONFIRMADOS")
                    return True
                else:
                    print("[ERROR] QBTC Core: POSIBLES SIMULACIONES DETECTADAS")
                    return False
            else:
                print("[ERROR] QBTC Core: Respuesta inv√°lida")
                return False
        else:
            print(f"[ERROR] QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] QBTC Core: Error de conexi√≥n - {e}")
        return False

def check_dashboard_no_simulations():
    """Verifica que el Dashboard no contenga simulaciones."""
    print("\n[SEARCH] VERIFICACI√ìN 2: DASHBOARD QBTC - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4605/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si est√° en contexto de simulaci√≥n
            if "test" in content:
                # Buscar contexto de simulaci√≥n alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("[OK] Dashboard QBTC: Sin simulaciones detectadas")
                return True
            else:
                print(f"[ERROR] Dashboard QBTC: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"[ERROR] Dashboard QBTC: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Dashboard QBTC: Error de conexi√≥n - {e}")
        return False

def check_monitor_no_simulations():
    """Verifica que el Monitor de Gr√°ficos no contenga simulaciones."""
    print("\n[SEARCH] VERIFICACI√ìN 3: MONITOR DE GR√ÅFICOS - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4606/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si est√° en contexto de simulaci√≥n
            if "test" in content:
                # Buscar contexto de simulaci√≥n alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("[OK] Monitor de Gr√°ficos: Sin simulaciones detectadas")
                return True
            else:
                print(f"[ERROR] Monitor de Gr√°ficos: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"[ERROR] Monitor de Gr√°ficos: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Monitor de Gr√°ficos: Error de conexi√≥n - {e}")
        return False

def check_all_apis_functional():
    """Verifica que todas las APIs funcionen correctamente."""
    print("\n[SEARCH] VERIFICACI√ìN 4: TODAS LAS APIS - FUNCIONALIDAD")
    print("-" * 60)
    
    apis = [
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health")
    ]
    
    working_apis = 0
    total_apis = len(apis)
    
    for name, url in apis:
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                print(f"[OK] {name}: Funcionando correctamente")
                working_apis += 1
            else:
                print(f"[ERROR] {name}: Error HTTP {response.status_code}")
                
        except Exception as e:
            print(f"[ERROR] {name}: Error de conexi√≥n - {e}")
    
    print(f"\n[DATA] RESULTADO APIS:")
    print(f"[OK] APIs funcionando: {working_apis}/{total_apis}")
    
    if working_apis == total_apis:
        print("üéâ Todas las APIs funcionando correctamente")
        return True
    else:
        print("[WARNING] Algunas APIs no est√°n funcionando")
        return False

def check_data_consistency_real():
    """Verifica consistencia de datos reales."""
    print("\n[SEARCH] VERIFICACI√ìN 5: CONSISTENCIA DE DATOS REALES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                # Verificar que los datos sean consistentes
                valid_data = 0
                invalid_data = 0
                
                for item in futures_data[:5]:  # Revisar primeros 5
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    if symbol and last_price and price_change:
                        try:
                            price_float = float(last_price)
                            change_float = float(price_change)
                            
                            if price_float > 0 and isinstance(change_float, (int, float)):
                                valid_data += 1
                                print(f"[OK] Datos v√°lidos: {symbol} - {last_price}")
                            else:
                                invalid_data += 1
                                print(f"[WARNING] Datos inv√°lidos: {symbol}")
                        except ValueError:
                            invalid_data += 1
                            print(f"[WARNING] Datos no num√©ricos: {symbol}")
                    else:
                        invalid_data += 1
                        print(f"[WARNING] Datos incompletos: {symbol}")
                
                print(f"\n[DATA] CONSISTENCIA DE DATOS:")
                print(f"[OK] Datos v√°lidos: {valid_data}")
                print(f"[WARNING] Datos inv√°lidos: {invalid_data}")
                
                if valid_data > 0 and invalid_data == 0:
                    print("üéâ Consistencia de datos: EXCELENTE")
                    return True
                elif valid_data > 0:
                    print("[WARNING] Consistencia de datos: PARCIAL")
                    return True
                else:
                    print("[ERROR] Consistencia de datos: DEFICIENTE")
                    return False
            else:
                print("[ERROR] QBTC Core: Respuesta inv√°lida")
                return False
        else:
            print(f"[ERROR] QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Error verificando consistencia: {e}")
        return False

def check_system_performance_final():
    """Verifica el rendimiento final del sistema."""
    print("\n[SEARCH] VERIFICACI√ìN 6: RENDIMIENTO FINAL DEL SISTEMA")
    print("-" * 60)
    
    services = [
        ("QBTC Core", "http://localhost:4602/api/futures-data"),
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health"),
        ("Dashboard QBTC", "http://localhost:4605/"),
        ("Monitor de Gr√°ficos", "http://localhost:4606/")
    ]
    
    total_time = 0
    successful_requests = 0
    
    for name, url in services:
        try:
            start_time = time.time()
            response = requests.get(url, timeout=5)
            end_time = time.time()
            
            response_time = (end_time - start_time) * 1000  # en milisegundos
            
            if response.status_code == 200:
                print(f"[OK] {name}: {response_time:.2f}ms")
                total_time += response_time
                successful_requests += 1
            else:
                print(f"[ERROR] {name}: Error {response.status_code}")
                
        except Exception as e:
            print(f"[ERROR] {name}: Error - {e}")
    
    if successful_requests > 0:
        avg_time = total_time / successful_requests
        print(f"\n[DATA] RENDIMIENTO FINAL:")
        print(f"[OK] Requests exitosos: {successful_requests}/{len(services)}")
        print(f"‚è±Ô∏è Tiempo promedio: {avg_time:.2f}ms")
        
        if avg_time < 1000:  # menos de 1 segundo
            print("üéâ Rendimiento: EXCELENTE")
            return True
        elif avg_time < 3000:  # menos de 3 segundos
            print("[OK] Rendimiento: BUENO")
            return True
        else:
            print("[WARNING] Rendimiento: LENTO")
            return False
    else:
        print("[ERROR] Rendimiento: NO FUNCIONAL")
        return False

def main():
    """Funci√≥n principal."""
    print_banner()
    
    tests = [
        ("QBTC Core - Datos Reales", check_qbtc_core_real_data),
        ("Dashboard QBTC - Sin Simulaciones", check_dashboard_no_simulations),
        ("Monitor de Gr√°ficos - Sin Simulaciones", check_monitor_no_simulations),
        ("Todas las APIs - Funcionalidad", check_all_apis_functional),
        ("Consistencia de Datos Reales", check_data_consistency_real),
        ("Rendimiento Final del Sistema", check_system_performance_final)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"[ERROR] Error en {test_name}: {e}")
            results.append((test_name, False))
    
    # Resumen final
    print("\n" + "=" * 80)
    print("[ENDPOINTS] VERIFICACI√ìN FINAL COMPLETADA")
    print("=" * 80)
    
    passed_tests = sum(1 for _, result in results if result)
    total_tests = len(results)
    
    print(f"\n[OK] Pruebas exitosas: {passed_tests}/{total_tests}")
    
    for test_name, result in results:
        status = "[OK] PAS√ì" if result else "[ERROR] FALL√ì"
        print(f"{status} - {test_name}")
    
    print(f"\n[ENDPOINTS] RESULTADO FINAL:")
    if passed_tests == total_tests:
        print("üéâ ¬°SISTEMA 100% LIBRE DE SIMULACIONES!")
        print("[START] Todos los servicios funcionan con datos reales")
        print("[OK] Sistema completamente operativo y listo para producci√≥n")
        print("[SECURE] Verificaci√≥n de integridad: EXITOSA")
    elif passed_tests >= total_tests * 0.8:
        print("[OK] SISTEMA MAYORMENTE FUNCIONAL")
        print("[WARNING] Algunas verificaciones fallaron, pero el sistema es usable")
        print("üîß Se recomienda revisar los puntos fallidos")
    else:
        print("[ERROR] SISTEMA CON PROBLEMAS")
        print("üîß Se requieren correcciones antes del uso")
    
    print("\n" + "=" * 80)

if __name__ == "__main__":
    main()
