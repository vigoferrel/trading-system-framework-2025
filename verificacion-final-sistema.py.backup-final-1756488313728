#!/usr/bin/env python3
"""
VERIFICACIÓN FINAL - SISTEMA QBTC BANDA 46
Script final para confirmar que el sistema está completamente libre de simulaciones
"""

import requests
import json
import time
import re
from datetime import datetime

def print_banner():
    """Imprime el banner del sistema."""
    print("=" * 80)
    print("[ENDPOINTS] VERIFICACIÓN FINAL - SISTEMA QBTC BANDA 46")
    print("=" * 80)
    print(f"📅 Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("[ENDPOINTS] Objetivo: Confirmar sistema 100% libre de simulaciones")
    print("[SEARCH] Verificación exhaustiva y precisa")
    print("=" * 80)

def check_qbtc_core_real_data():
    """Verifica que QBTC Core proporcione datos reales de Binance."""
    print("\n[SEARCH] VERIFICACIÓN 1: QBTC CORE - DATOS REALES DE BINANCE")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                print(f"[OK] QBTC Core respondiendo correctamente")
                print(f"[DATA] Cantidad de símbolos: {len(futures_data)}")
                
                # Verificar que los datos sean reales
                real_symbols = 0
                simulated_symbols = 0
                
                for item in futures_data[:10]:  # Revisar primeros 10
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    # Verificar que sean símbolos reales de Binance
                    if symbol and last_price and price_change:
                        if re.match(r'^[A-Z0-9]+USDT$', symbol):
                            real_symbols += 1
                            print(f"[OK] Símbolo real: {symbol} - Precio: {last_price}")
                        else:
                            simulated_symbols += 1
                            print(f"[WARNING] Símbolo sospechoso: {symbol}")
                
                print(f"\n[UP] RESULTADO QBTC CORE:")
                print(f"[OK] Símbolos reales: {real_symbols}")
                print(f"[WARNING] Símbolos sospechosos: {simulated_symbols}")
                
                if real_symbols > 0 and simulated_symbols == 0:
                    print("🎉 QBTC Core: DATOS REALES CONFIRMADOS")
                    return True
                else:
                    print("[ERROR] QBTC Core: POSIBLES SIMULACIONES DETECTADAS")
                    return False
            else:
                print("[ERROR] QBTC Core: Respuesta inválida")
                return False
        else:
            print(f"[ERROR] QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] QBTC Core: Error de conexión - {e}")
        return False

def check_dashboard_no_simulations():
    """Verifica que el Dashboard no contenga simulaciones."""
    print("\n[SEARCH] VERIFICACIÓN 2: DASHBOARD QBTC - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4605/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si está en contexto de simulación
            if "test" in content:
                # Buscar contexto de simulación alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("[OK] Dashboard QBTC: Sin simulaciones detectadas")
                return True
            else:
                print(f"[ERROR] Dashboard QBTC: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"[ERROR] Dashboard QBTC: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Dashboard QBTC: Error de conexión - {e}")
        return False

def check_monitor_no_simulations():
    """Verifica que el Monitor de Gráficos no contenga simulaciones."""
    print("\n[SEARCH] VERIFICACIÓN 3: MONITOR DE GRÁFICOS - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4606/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si está en contexto de simulación
            if "test" in content:
                # Buscar contexto de simulación alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("[OK] Monitor de Gráficos: Sin simulaciones detectadas")
                return True
            else:
                print(f"[ERROR] Monitor de Gráficos: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"[ERROR] Monitor de Gráficos: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Monitor de Gráficos: Error de conexión - {e}")
        return False

def check_all_apis_functional():
    """Verifica que todas las APIs funcionen correctamente."""
    print("\n[SEARCH] VERIFICACIÓN 4: TODAS LAS APIS - FUNCIONALIDAD")
    print("-" * 60)
    
    apis = [
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health")
    ]
    
    working_apis = 0
    total_apis = len(apis)
    
    for name, url in apis:
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                print(f"[OK] {name}: Funcionando correctamente")
                working_apis += 1
            else:
                print(f"[ERROR] {name}: Error HTTP {response.status_code}")
                
        except Exception as e:
            print(f"[ERROR] {name}: Error de conexión - {e}")
    
    print(f"\n[DATA] RESULTADO APIS:")
    print(f"[OK] APIs funcionando: {working_apis}/{total_apis}")
    
    if working_apis == total_apis:
        print("🎉 Todas las APIs funcionando correctamente")
        return True
    else:
        print("[WARNING] Algunas APIs no están funcionando")
        return False

def check_data_consistency_real():
    """Verifica consistencia de datos reales."""
    print("\n[SEARCH] VERIFICACIÓN 5: CONSISTENCIA DE DATOS REALES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                # Verificar que los datos sean consistentes
                valid_data = 0
                invalid_data = 0
                
                for item in futures_data[:5]:  # Revisar primeros 5
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    if symbol and last_price and price_change:
                        try:
                            price_float = float(last_price)
                            change_float = float(price_change)
                            
                            if price_float > 0 and isinstance(change_float, (int, float)):
                                valid_data += 1
                                print(f"[OK] Datos válidos: {symbol} - {last_price}")
                            else:
                                invalid_data += 1
                                print(f"[WARNING] Datos inválidos: {symbol}")
                        except ValueError:
                            invalid_data += 1
                            print(f"[WARNING] Datos no numéricos: {symbol}")
                    else:
                        invalid_data += 1
                        print(f"[WARNING] Datos incompletos: {symbol}")
                
                print(f"\n[DATA] CONSISTENCIA DE DATOS:")
                print(f"[OK] Datos válidos: {valid_data}")
                print(f"[WARNING] Datos inválidos: {invalid_data}")
                
                if valid_data > 0 and invalid_data == 0:
                    print("🎉 Consistencia de datos: EXCELENTE")
                    return True
                elif valid_data > 0:
                    print("[WARNING] Consistencia de datos: PARCIAL")
                    return True
                else:
                    print("[ERROR] Consistencia de datos: DEFICIENTE")
                    return False
            else:
                print("[ERROR] QBTC Core: Respuesta inválida")
                return False
        else:
            print(f"[ERROR] QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"[ERROR] Error verificando consistencia: {e}")
        return False

def check_system_performance_final():
    """Verifica el rendimiento final del sistema."""
    print("\n[SEARCH] VERIFICACIÓN 6: RENDIMIENTO FINAL DEL SISTEMA")
    print("-" * 60)
    
    services = [
        ("QBTC Core", "http://localhost:4602/api/futures-data"),
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health"),
        ("Dashboard QBTC", "http://localhost:4605/"),
        ("Monitor de Gráficos", "http://localhost:4606/")
    ]
    
    total_time = 0
    successful_requests = 0
    
    for name, url in services:
        try:
            start_time = time.time()
            response = requests.get(url, timeout=5)
            end_time = time.time()
            
            response_time = (end_time - start_time) * 1000  # en milisegundos
            
            if response.status_code == 200:
                print(f"[OK] {name}: {response_time:.2f}ms")
                total_time += response_time
                successful_requests += 1
            else:
                print(f"[ERROR] {name}: Error {response.status_code}")
                
        except Exception as e:
            print(f"[ERROR] {name}: Error - {e}")
    
    if successful_requests > 0:
        avg_time = total_time / successful_requests
        print(f"\n[DATA] RENDIMIENTO FINAL:")
        print(f"[OK] Requests exitosos: {successful_requests}/{len(services)}")
        print(f"⏱️ Tiempo promedio: {avg_time:.2f}ms")
        
        if avg_time < 1000:  # menos de 1 segundo
            print("🎉 Rendimiento: EXCELENTE")
            return True
        elif avg_time < 3000:  # menos de 3 segundos
            print("[OK] Rendimiento: BUENO")
            return True
        else:
            print("[WARNING] Rendimiento: LENTO")
            return False
    else:
        print("[ERROR] Rendimiento: NO FUNCIONAL")
        return False

def main():
    """Función principal."""
    print_banner()
    
    tests = [
        ("QBTC Core - Datos Reales", check_qbtc_core_real_data),
        ("Dashboard QBTC - Sin Simulaciones", check_dashboard_no_simulations),
        ("Monitor de Gráficos - Sin Simulaciones", check_monitor_no_simulations),
        ("Todas las APIs - Funcionalidad", check_all_apis_functional),
        ("Consistencia de Datos Reales", check_data_consistency_real),
        ("Rendimiento Final del Sistema", check_system_performance_final)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"[ERROR] Error en {test_name}: {e}")
            results.append((test_name, False))
    
    # Resumen final
    print("\n" + "=" * 80)
    print("[ENDPOINTS] VERIFICACIÓN FINAL COMPLETADA")
    print("=" * 80)
    
    passed_tests = sum(1 for _, result in results if result)
    total_tests = len(results)
    
    print(f"\n[OK] Pruebas exitosas: {passed_tests}/{total_tests}")
    
    for test_name, result in results:
        status = "[OK] PASÓ" if result else "[ERROR] FALLÓ"
        print(f"{status} - {test_name}")
    
    print(f"\n[ENDPOINTS] RESULTADO FINAL:")
    if passed_tests == total_tests:
        print("🎉 ¡SISTEMA 100% LIBRE DE SIMULACIONES!")
        print("[START] Todos los servicios funcionan con datos reales")
        print("[OK] Sistema completamente operativo y listo para producción")
        print("[SECURE] Verificación de integridad: EXITOSA")
    elif passed_tests >= total_tests * 0.8:
        print("[OK] SISTEMA MAYORMENTE FUNCIONAL")
        print("[WARNING] Algunas verificaciones fallaron, pero el sistema es usable")
        print("🔧 Se recomienda revisar los puntos fallidos")
    else:
        print("[ERROR] SISTEMA CON PROBLEMAS")
        print("🔧 Se requieren correcciones antes del uso")
    
    print("\n" + "=" * 80)

if __name__ == "__main__":
    main()
