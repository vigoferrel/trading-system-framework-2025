
// Constantes f√≠sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * üöÄ QBTC Advanced Cache System
 * Sistema de cache avanzado para reducir llamadas API y evitar rate limiting
 * 
 * Caracter√≠sticas:
 * - Cache persistente con TTL extendido
 * - Fetch nativo para optimizaci√≥n
 * - Estrategias de cache inteligentes
 * - Reducci√≥n dr√°stica de llamadas API
 */

const fs = require('fs').promises;
const path = require('path');

class QBTCAdvancedCacheSystem {
    constructor(options = {}) {
        this.options = {
            // Cache TTL extendido para reducir llamadas API
            balanceTTL: 300000,        // 5 minutos (vs 30s anterior)
            positionsTTL: 180000,      // 3 minutos (vs 30s anterior)
            marketDataTTL: 60000,      // 1 minuto para datos de mercado
            staticDataTTL: 3600000,    // 1 hora para datos est√°ticos
            
            // Cache persistente
            enablePersistentCache: true,
            cacheDir: './cache',
            
            // Estrategias de optimizaci√≥n
            enablePreloading: true,
            enableBatching: true,
            maxBatchSize: 10,
            
            // Rate limiting protection
            minRequestInterval: 2000,   // 2 segundos m√≠nimo entre requests
            maxConcurrentRequests: 3,   // M√°ximo 3 requests simult√°neos
            
            ...options
        };
        
        // Cache en memoria
        this.memoryCache = new Map();
        
        // Cache persistente
        this.persistentCache = new Map();
        
        // Control de rate limiting
        this.requestQueue = [];
        this.activeRequests = 0;
        this.lastRequestTime = 0;
        
        // Estad√≠sticas
        this.stats = {
            hits: 0,
            misses: 0,
            apiCalls: 0,
            rateLimitHits: 0,
            cacheSize: 0
        };
        
        this.initializeCache();
        
        console.log('üöÄ Advanced Cache System inicializado');
        console.log(`üìä Balance TTL: ${this.options.balanceTTL/1000}s`);
        console.log(`üìä Positions TTL: ${this.options.positionsTTL/1000}s`);
    }
    
    /**
     * Inicializar sistema de cache
     */
    async initializeCache() {
        try {
            // Crear directorio de cache si no existe
            if (this.options.enablePersistentCache) {
                await this.ensureCacheDirectory();
                await this.loadPersistentCache();
            }
            
            // Iniciar limpieza autom√°tica
            this.startCacheCleanup();
            
            console.log('‚úÖ Cache system inicializado exitosamente');
            
        } catch (error) {
            console.error('‚ùå Error inicializando cache system:', error.message);
        }
    }
    
    /**
     * Obtener datos con cache inteligente
     */
    async get(key, fetchFunction, ttl = null) {
        try {
            // Determinar TTL seg√∫n tipo de datos
            const cacheTTL = ttl || this.determineTTL(key);
            
            // Verificar cache en memoria primero
            const memoryResult = this.getFromMemoryCache(key, cacheTTL);
            if (memoryResult) {
                this.stats.hits++;
                console.log(`üíæ Cache HIT (memory): ${key}`);
                return memoryResult;
            }
            
            // Verificar cache persistente
            if (this.options.enablePersistentCache) {
                const persistentResult = await this.getFromPersistentCache(key, cacheTTL);
                if (persistentResult) {
                    // Promover a memoria cache
                    this.setMemoryCache(key, persistentResult, cacheTTL);
                    this.stats.hits++;
                    console.log(`üíø Cache HIT (persistent): ${key}`);
                    return persistentResult;
                }
            }
            
            // Cache miss - obtener datos frescos con rate limiting
            this.stats.misses++;
            console.log(`üîÑ Cache MISS: ${key} - Fetching fresh data`);
            
            const freshData = await this.fetchWithRateLimit(fetchFunction, key);
            
            if (freshData) {
                // Guardar en ambos caches
                this.setMemoryCache(key, freshData, cacheTTL);
                
                if (this.options.enablePersistentCache) {
                    await this.setPersistentCache(key, freshData, cacheTTL);
                }
                
                console.log(`‚úÖ Fresh data cached: ${key}`);
            }
            
            return freshData;
            
        } catch (error) {
            console.error(`‚ùå Error getting cached data for ${key}:`, error.message);
            
            // Intentar devolver datos caducados como fallback
            return this.getStaleData(key);
        }
    }
    
    /**
     * Fetch con rate limiting inteligente
     */
    async fetchWithRateLimit(fetchFunction, key) {
        return new Promise((resolve, reject) => {
            // Agregar a cola de requests
            this.requestQueue.push({
                fetchFunction,
                key,
                resolve,
                reject,
                timestamp: Date.now()
            });
            
            // Procesar cola
            this.processRequestQueue();
        });
    }
    
    /**
     * Procesar cola de requests con rate limiting
     */
    async processRequestQueue() {
        // Verificar si podemos procesar m√°s requests
        if (this.activeRequests >= this.options.maxConcurrentRequests) {
            return;
        }
        
        if (this.requestQueue.length === 0) {
            return;
        }
        
        // Verificar intervalo m√≠nimo entre requests
        const now = Date.now();
        const timeSinceLastRequest = now - this.lastRequestTime;
        
        if (timeSinceLastRequest < this.options.minRequestInterval) {
            // Esperar antes de procesar
            setTimeout(() => {
                this.processRequestQueue();
            }, this.options.minRequestInterval - timeSinceLastRequest);
            return;
        }
        
        // Procesar siguiente request
        const request = this.requestQueue.shift();
        if (!request) return;
        
        this.activeRequests++;
        this.lastRequestTime = now;
        this.stats.apiCalls++;
        
        try {
            console.log(`üåê Processing API request: ${request.key} (Queue: ${this.requestQueue.length})`);
            
            const result = await request.fetchFunction();
            request.resolve(result);
            
        } catch (error) {
            console.error(`‚ùå API request failed for ${request.key}:`, error.message);
            
            // Verificar si es rate limiting
            if (error.message.includes('429') || error.message.includes('rate limit')) {
                this.stats.rateLimitHits++;
                console.log(`üö¶ Rate limit detected for ${request.key}, extending cache TTL`);
                
                // Intentar devolver datos caducados
                const staleData = this.getStaleData(request.key);
                if (staleData) {
                    console.log(`üì¶ Using stale data for ${request.key}`);
                    request.resolve(staleData);
                } else {
                    request.reject(error);
                }
            } else {
                request.reject(error);
            }
        } finally {
            this.activeRequests--;
            
            // Procesar siguiente request despu√©s de un delay
            setTimeout(() => {
                this.processRequestQueue();
            }, 500); // 500ms delay entre requests
        }
    }
    
    /**
     * Determinar TTL seg√∫n tipo de datos
     */
    determineTTL(key) {
        if (key.includes('balance')) {
            return this.options.balanceTTL;
        } else if (key.includes('position')) {
            return this.options.positionsTTL;
        } else if (key.includes('market') || key.includes('price')) {
            return this.options.marketDataTTL;
        } else {
            return this.options.staticDataTTL;
        }
    }
    
    /**
     * Obtener de cache en memoria
     */
    getFromMemoryCache(key, ttl) {
        const cached = this.memoryCache.get(key);
        
        if (!cached) return null;
        
        const age = Date.now() - cached.timestamp;
        
        if (age > ttl) {
            this.memoryCache.delete(key);
            return null;
        }
        
        return cached.data;
    }
    
    /**
     * Guardar en cache en memoria
     */
    setMemoryCache(key, data, ttl) {
        this.memoryCache.set(key, {
            data,
            timestamp: Date.now(),
            ttl
        });
        
        this.stats.cacheSize = this.memoryCache.size;
    }
    
    /**
     * Obtener de cache persistente
     */
    async getFromPersistentCache(key, ttl) {
        try {
            const cacheFile = path.join(this.options.cacheDir, `${key}.json`);
            const data = await fs.readFile(cacheFile, 'utf8');
            const cached = JSON.parse(data);
            
            const age = Date.now() - cached.timestamp;
            
            if (age > ttl) {
                // Cache expirado, eliminar archivo
                await fs.unlink(cacheFile).catch(() => {});
                return null;
            }
            
            return cached.data;
            
        } catch (error) {
            // Archivo no existe o error leyendo
            return null;
        }
    }
    
    /**
     * Guardar en cache persistente
     */
    async setPersistentCache(key, data, ttl) {
        try {
            const cacheFile = path.join(this.options.cacheDir, `${key}.json`);
            const cached = {
                data,
                timestamp: Date.now(),
                ttl
            };
            
            await fs.writeFile(cacheFile, JSON.stringify(cached, null, 2));
            
        } catch (error) {
            console.error(`‚ùå Error saving persistent cache for ${key}:`, error.message);
        }
    }
    
    /**
     * Obtener datos caducados como fallback
     */
    getStaleData(key) {
        // Intentar memoria cache sin verificar TTL
        const memoryCached = this.memoryCache.get(key);
        if (memoryCached) {
            console.log(`üì¶ Using stale memory data for ${key}`);
            return memoryCached.data;
        }
        
        // Intentar cache persistente sin verificar TTL
        try {
            const cacheFile = path.join(this.options.cacheDir, `${key}.json`);
            const data = require(cacheFile);
            console.log(`üì¶ Using stale persistent data for ${key}`);
            return data.data;
        } catch (error) {
            return null;
        }
    }
    
    /**
     * Asegurar que existe el directorio de cache
     */
    async ensureCacheDirectory() {
        try {
            await fs.mkdir(this.options.cacheDir, { recursive: true });
        } catch (error) {
            console.error('‚ùå Error creating cache directory:', error.message);
        }
    }
    
    /**
     * Cargar cache persistente al inicio
     */
    async loadPersistentCache() {
        try {
            const files = await fs.readdir(this.options.cacheDir);
            
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const key = file.replace('.json', '');
                    const cached = this.persistentCache.get(key);
                    
                    if (!cached) {
                        this.persistentCache.set(key, true); // Marcar como disponible
                    }
                }
            }
            
            console.log(`üì¶ Loaded ${files.length} cached files`);
            
        } catch (error) {
            console.error('‚ùå Error loading persistent cache:', error.message);
        }
    }
    
    /**
     * Iniciar limpieza autom√°tica de cache
     */
    startCacheCleanup() {
        // Limpiar cache en memoria cada 10 minutos
        setInterval(() => {
            this.cleanupMemoryCache();
        }, 600000); // 10 minutos
        
        // Limpiar cache persistente cada hora
        setInterval(() => {
            this.cleanupPersistentCache();
        }, 3600000); // 1 hora
    }
    
    /**
     * Limpiar cache en memoria
     */
    cleanupMemoryCache() {
        const now = Date.now();
        let cleaned = 0;
        
        for (const [key, cached] of this.memoryCache.entries()) {
            const age = now - cached.timestamp;
            
            if (age > cached.ttl * 2) { // Limpiar datos muy viejos
                this.memoryCache.delete(key);
                cleaned++;
            }
        }
        
        if (cleaned > 0) {
            console.log(`üßπ Cleaned ${cleaned} expired entries from memory cache`);
            this.stats.cacheSize = this.memoryCache.size;
        }
    }
    
    /**
     * Limpiar cache persistente
     */
    async cleanupPersistentCache() {
        try {
            const files = await fs.readdir(this.options.cacheDir);
            let cleaned = 0;
            
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const filePath = path.join(this.options.cacheDir, file);
                    const stats = await fs.stat(filePath);
                    const age = Date.now() - stats.mtime.getTime();
                    
                    // Eliminar archivos m√°s viejos que 2 horas
                    if (age > 7200000) {
                        await fs.unlink(filePath);
                        cleaned++;
                    }
                }
            }
            
            if (cleaned > 0) {
                console.log(`üßπ Cleaned ${cleaned} expired files from persistent cache`);
            }
            
        } catch (error) {
            console.error('‚ùå Error cleaning persistent cache:', error.message);
        }
    }
    
    /**
     * Invalidar cache espec√≠fico
     */
    invalidate(key) {
        // Eliminar de memoria
        this.memoryCache.delete(key);
        
        // Eliminar de cache persistente
        if (this.options.enablePersistentCache) {
            const cacheFile = path.join(this.options.cacheDir, `${key}.json`);
            fs.unlink(cacheFile).catch(() => {});
        }
        
        console.log(`üóëÔ∏è Cache invalidated: ${key}`);
    }
    
    /**
     * Limpiar todo el cache
     */
    clear() {
        this.memoryCache.clear();
        this.stats.cacheSize = 0;
        
        if (this.options.enablePersistentCache) {
            fs.readdir(this.options.cacheDir)
                .then(files => {
                    return Promise.all(
                        files.filter(f => f.endsWith('.json'))
                             .map(f => fs.unlink(path.join(this.options.cacheDir, f)))
                    );
                })
                .catch(() => {});
        }
        
        console.log('üßπ All cache cleared');
    }
    
    /**
     * Obtener estad√≠sticas del cache
     */
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0 
            ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(1)
            : 0;
        
        return {
            ...this.stats,
            hitRate: `${hitRate}%`,
            queueSize: this.requestQueue.length,
            activeRequests: this.activeRequests,
            memorySize: this.memoryCache.size
        };
    }
    
    /**
     * Generar reporte de cache
     */
    generateReport() {
        const stats = this.getStats();
        
        console.log('\nüìä ‚ïê‚ïê‚ïê CACHE SYSTEM REPORT ‚ïê‚ïê‚ïê');
        console.log(`üíæ Hit Rate: ${stats.hitRate}`);
        console.log(`üìà Hits: ${stats.hits} | Misses: ${stats.misses}`);
        console.log(`üåê API Calls: ${stats.apiCalls}`);
        console.log(`üö¶ Rate Limits: ${stats.rateLimitHits}`);
        console.log(`üì¶ Memory Cache Size: ${stats.memorySize}`);
        console.log(`‚è≥ Queue Size: ${stats.queueSize}`);
        console.log(`üîÑ Active Requests: ${stats.activeRequests}`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        
        return stats;
    }
}

module.exports = QBTCAdvancedCacheSystem;