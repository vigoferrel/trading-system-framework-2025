
// Constantes fÃ­sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * SCRIPT DE EMERGENCIA DIRECTO - CIERRE INMEDIATO DE POSICIÃ“N BTC
 * Usa las dependencias existentes del sistema principal
 */

const crypto = require('crypto');
const https = require('https');
const querystring = require('querystring');

// ConfiguraciÃ³n de API (usar las mismas credenciales del sistema principal)
const config = require('./config');

class DirectBinanceAPI {
    constructor(apiKey, apiSecret) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.baseURL = 'eapi.binance.com';
    }
    
    createSignature(queryString) {
        return crypto
            .createHmac('sha256', this.apiSecret)
            .update(queryString)
            .digest('hex');
    }
    
    async makeRequest(method, endpoint, params = {}) {
        const timestamp = Date.now();
        params.timestamp = timestamp;
        
        const queryString = querystring.stringify(params);
        const signature = this.createSignature(queryString);
        const finalQuery = `${queryString}&signature=${signature}`;
        
        const options = {
            hostname: this.baseURL,
            port: 443,
            path: `${endpoint}?${finalQuery}`,
            method: method,
            headers: {
                'X-MBX-APIKEY': this.apiKey,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        };
        
        return new Promise((resolve, reject) => {
            const req = https.request(options, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        const response = JSON.parse(data);
                        if (res.statusCode === 200) {
                            resolve(response);
                        } else {
                            reject(new Error(`API Error: ${response.msg || data}`));
                        }
                    } catch (error) {
                        reject(new Error(`Parse Error: ${error.message}`));
                    }
                });
            });
            
            req.on('error', (error) => {
                reject(error);
            });
            
            req.end();
        });
    }
}

async function emergencyCloseBTCPosition() {
    console.log('[ALERT] INICIANDO CIERRE DE EMERGENCIA DIRECTO DE POSICIÃ“N BTC');
    console.log('=' .repeat(60));
    
    try {
        // Inicializar API directa
        const api = new DirectBinanceAPI(config.binance.apiKey, config.binance.apiSecret);
        
        console.log('[OK] API inicializada');
        
        // Obtener posiciones actuales
        console.log('[DATA] Obteniendo posiciones de opciones...');
        const positions = await api.makeRequest('GET', '/eapi/v1/position', {});
        
        console.log(`[UP] Encontradas ${positions.length} posiciones`);
        
        // Buscar la posiciÃ³n BTC especÃ­fica
        const btcPosition = positions.find(pos => 
            pos.symbol === 'BTC-250829-150000-C' && 
            parseFloat(pos.quantity) !== 0
        );
        
        if (!btcPosition) {
            console.log('[ERROR] No se encontrÃ³ la posiciÃ³n BTC-250829-150000-C activa');
            
            // Mostrar todas las posiciones disponibles
            console.log('\n[LIST] Posiciones encontradas:');
            positions.forEach(pos => {
                if (parseFloat(pos.quantity) !== 0) {
                    console.log(`   - ${pos.symbol}: ${pos.quantity} (${pos.side})`);
                }
            });
            return;
        }
        
        console.log('\n[ENDPOINTS] POSICIÃ“N BTC ENCONTRADA:');
        console.log(`   - SÃ­mbolo: ${btcPosition.symbol}`);
        console.log(`   - Lado: ${btcPosition.side}`);
        console.log(`   - Cantidad: ${btcPosition.quantity}`);
        console.log(`   - Cantidad reducible: ${btcPosition.reducibleQty}`);
        console.log(`   - Precio de entrada: $${btcPosition.entryPrice}`);
        console.log(`   - Precio actual: $${btcPosition.markPrice}`);
        console.log(`   - Valor de mercado: $${btcPosition.markValue}`);
        console.log(`   - PnL no realizado: $${btcPosition.unrealizedPNL}`);
        console.log(`   - RoR: ${(parseFloat(btcPosition.ror) * 100).toFixed(2)}%`);
        console.log(`   - Costo de posiciÃ³n: $${btcPosition.positionCost}`);
        
        // Calcular pÃ©rdida porcentual
        const lossPercentage = (parseFloat(btcPosition.unrealizedPNL) / parseFloat(btcPosition.positionCost)) * 100;
        console.log(`   - PÃ©rdida porcentual: ${lossPercentage.toFixed(2)}%`);
        
        // Confirmar cierre de emergencia
        console.log('\n[ALERT] CONFIRMACIÃ“N DE CIERRE DE EMERGENCIA:');
        console.log(`   - Esta posiciÃ³n tiene una pÃ©rdida de ${lossPercentage.toFixed(2)}%`);
        console.log(`   - PÃ©rdida absoluta: $${btcPosition.unrealizedPNL}`);
        console.log(`   - Se procederÃ¡ con el cierre inmediato usando orden MARKET`);
        
        // Preparar parÃ¡metros de orden de cierre
        const orderParams = {
            symbol: btcPosition.symbol,
            side: btcPosition.side === 'LONG' ? 'SELL' : 'BUY', // Lado opuesto para cerrar
            type: 'MARKET',
            quantity: btcPosition.reducibleQty || btcPosition.quantity, // Usar cantidad reducible
            reduceOnly: 'true'
        };
        
        console.log('\nðŸ”¥ EJECUTANDO ORDEN DE CIERRE...');
        console.log(`ðŸ“¤ ParÃ¡metros: ${JSON.stringify(orderParams, null, 2)}`);
        
        // Ejecutar orden de cierre
        const orderResult = await api.makeRequest('POST', '/eapi/v1/order', orderParams);
        
        console.log('\n[OK] ORDEN ENVIADA EXITOSAMENTE');
        console.log(`   - Order ID: ${orderResult.orderId}`);
        console.log(`   - Client Order ID: ${orderResult.clientOrderId}`);
        console.log(`   - Status: ${orderResult.status}`);
        console.log(`   - SÃ­mbolo: ${orderResult.symbol}`);
        console.log(`   - Lado: ${orderResult.side}`);
        console.log(`   - Tipo: ${orderResult.type}`);
        console.log(`   - Cantidad: ${orderResult.quantity}`);
        
        // Esperar un momento y verificar el resultado
        console.log('\nâ³ Esperando confirmaciÃ³n de ejecuciÃ³n...');
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        // Verificar estado de la orden
        try {
            const orderStatus = await api.makeRequest('GET', '/eapi/v1/order', {
                symbol: orderResult.symbol,
                orderId: orderResult.orderId
            });
            
            console.log('\n[DATA] ESTADO DE LA ORDEN:');
            console.log(`   - Status: ${orderStatus.status}`);
            console.log(`   - Cantidad ejecutada: ${orderStatus.executedQty}`);
            console.log(`   - Precio promedio: ${orderStatus.avgPrice || 'N/A'}`);
            
            if (orderStatus.status === 'FILLED') {
                console.log('[OK] ORDEN COMPLETAMENTE EJECUTADA');
                
                // Calcular pÃ©rdida realizada
                const executedValue = parseFloat(orderStatus.executedQty) * parseFloat(orderStatus.avgPrice || btcPosition.markPrice);
                const originalCost = parseFloat(btcPosition.entryPrice) * parseFloat(orderStatus.executedQty);
                const realizedPnL = executedValue - originalCost;
                
                console.log(`   - Valor ejecutado: $${executedValue.toFixed(2)}`);
                console.log(`   - Costo original: $${originalCost.toFixed(2)}`);
                console.log(`   - PnL realizado: $${realizedPnL.toFixed(2)}`);
            }
            
        } catch (statusError) {
            console.log(`[WARNING] No se pudo verificar el estado de la orden: ${statusError.message}`);
        }
        
        // Verificar posiciones restantes
        console.log('\n[SEARCH] Verificando posiciones restantes...');
        const updatedPositions = await api.makeRequest('GET', '/eapi/v1/position', {});
        const remainingBTC = updatedPositions.find(pos => 
            pos.symbol === 'BTC-250829-150000-C' && 
            parseFloat(pos.quantity) !== 0
        );
        
        if (!remainingBTC) {
            console.log('[OK] CONFIRMADO: PosiciÃ³n BTC cerrada completamente');
        } else {
            console.log('[WARNING] ADVERTENCIA: AÃºn queda posiciÃ³n BTC:');
            console.log(`   - Cantidad restante: ${remainingBTC.quantity}`);
            console.log(`   - Cantidad reducible: ${remainingBTC.reducibleQty}`);
        }
        
        // Obtener balance final
        console.log('\n[MONEY] BALANCE FINAL:');
        try {
            const finalBalance = await api.makeRequest('GET', '/eapi/v1/account', {});
            
            if (finalBalance && finalBalance.asset) {
                const usdtAsset = finalBalance.asset.find(asset => asset.asset === 'USDT');
                if (usdtAsset) {
                    console.log(`   - Equity: $${usdtAsset.equity}`);
                    console.log(`   - Available: $${usdtAsset.available}`);
                    console.log(`   - Unrealized PnL: $${usdtAsset.unrealizedPNL}`);
                    console.log(`   - Margin Balance: $${usdtAsset.marginBalance}`);
                }
            }
        } catch (balanceError) {
            console.log(`   - Error obteniendo balance: ${balanceError.message}`);
        }
        
        console.log('\nðŸ CIERRE DE EMERGENCIA COMPLETADO');
        console.log('=' .repeat(60));
        
    } catch (error) {
        console.error('\nðŸ’¥ ERROR CRÃTICO EN CIERRE DE EMERGENCIA:');
        console.error(`   - Error: ${error.message}`);
        console.error(`   - Stack: ${error.stack}`);
        
        console.log('\nðŸ†˜ RECOMENDACIONES:');
        console.log('   1. Verificar credenciales de API');
        console.log('   2. Verificar permisos de trading en Binance');
        console.log('   3. Cerrar posiciÃ³n manualmente en la interfaz de Binance');
        console.log('   4. Contactar soporte si el problema persiste');
    }
}

// Ejecutar el script
if (require.main === module) {
    emergencyCloseBTCPosition()
        .then(() => {
            console.log('\n[ENDPOINTS] Script de emergencia finalizado');
            process.exit(0);
        })
        .catch((error) => {
            console.error('\nðŸ’¥ Error fatal en script de emergencia:', error);
            process.exit(1);
        });
}

module.exports = emergencyCloseBTCPosition;