/**
 * ðŸ§  MCP CRYPTO NEURAL AUTOMATION
 * ===============================
 * 
 * Sistema automatizado de bÃºsquedas MCP Brave integrado con anÃ¡lisis psicolÃ³gico neural
 * para potenciar el nÃºcleo de tasas de cambio existente
 */

const fs = require('fs');
const { spawn, exec } = require('child_process');
const { analizarEstadoPsicologico } = require('./nucleo-psicologico-tasas-cambio.js');

class MCPCryptoNeuralAutomation {
    constructor() {
        console.log('ðŸ§  [MCP NEURAL] Inicializando automation crypto neural...');
        
        // [LIST] CONFIGURACIÃ“N
        this.config = this.loadConfig();
        this.isRunning = false;
        this.searchHistory = [];
        this.psychologicalStates = new Map();
        this.lastStates = new Map();
        
        // [RELOAD] INTERVALOS
        this.searchIntervals = new Map();
        this.volatilityMonitor = null;
        this.sessionMultiplier = 1.0;
        
        // [DATA] MÃ‰TRICAS
        this.metrics = {
            totalSearches: 0,
            psychologicalTransitions: 0,
            quantumEnhancements: 0,
            lastUpdate: null,
            averageConfidence: 0,
            successRate: 1.0
        };
        
        this.initializeSystem();
    }
    
    /**
     * [START] INICIALIZAR SISTEMA COMPLETO
     */
    async initializeSystem() {
        try {
            console.log('[START] [MCP NEURAL] Iniciando sistema completo...');
            
            // [OK] 1. CARGAR CONFIGURACIÃ“N
            await this.validateConfiguration();
            
            // [OK] 2. INICIALIZAR MCP BRAVE SERVER
            await this.initializeMCPServer();
            
            // [OK] 3. CONFIGURAR AUTOMATION
            await this.setupAutomation();
            
            // [OK] 4. INICIAR MONITOREO
            await this.startMonitoring();
            
            console.log('[OK] [MCP NEURAL] Sistema inicializado exitosamente');
            
        } catch (error) {
            console.error('[ERROR] [MCP NEURAL] Error inicializando sistema:', error.message);
            process.exit(1);
        }
    }
    
    /**
     * [LIST] CARGAR CONFIGURACIÃ“N
     */
    loadConfig() {
        try {
            const configPath = './mcp-crypto-config.json';
            if (fs.existsSync(configPath)) {
                const configData = fs.readFileSync(configPath, 'utf8');
                return JSON.parse(configData).mcp_crypto_configuration;
            }
            throw new Error('Archivo de configuraciÃ³n no encontrado');
        } catch (error) {
            console.error('[ERROR] [CONFIG] Error cargando configuraciÃ³n:', error.message);
            return this.getDefaultConfig();
        }
    }
    
    /**
     * ðŸ”§ CONFIGURACIÃ“N POR DEFECTO
     */
    getDefaultConfig() {
        return {
            server_name: 'brave-crypto-neural-mcp',
            port: 9847,
            search_automation: {
                enabled: true,
                base_interval: 300000, // 5 minutos
                adaptive_frequency: true
            },
            crypto_queries: {
                core_assets: {
                    bitcoin: ['Bitcoin BTC precio anÃ¡lisis tÃ©cnico'],
                    ethereum: ['Ethereum ETH precio predicciÃ³n'],
                    binance: ['Binance BNB token analysis']
                }
            }
        };
    }
    
    /**
     * ðŸ› ï¸ INICIALIZAR MCP SERVER
     */
    async initializeMCPServer() {
        return new Promise((resolve, reject) => {
            console.log('ðŸ› ï¸ [MCP SERVER] Iniciando servidor MCP Brave...');
            
            // Verificar si el servidor ya estÃ¡ corriendo
            exec('netstat -an | findstr :9847', (error, stdout) => {
                if (stdout && stdout.includes('9847')) {
                    console.log('[OK] [MCP SERVER] Servidor ya estÃ¡ corriendo en puerto 9847');
                    resolve(true);
                    return;
                }
                
                // Iniciar servidor MCP
                const serverProcess = spawn('npx', [
                    '@brave/brave-search-mcp-server',
                    '--port', this.config.port.toString()
                ], {
                    stdio: ['ignore', 'pipe', 'pipe'],
                    env: { ...process.env, BRAVE_SEARCH_API_KEY: process.env.BRAVE_SEARCH_API_KEY }
                });
                
                let serverReady = false;
                
                serverProcess.stdout.on('data', (data) => {
                    const output = data.toString();
                    console.log(`ðŸ“¡ [MCP SERVER] ${output.trim()}`);
                    
                    if (output.includes('Server running') || output.includes('listening')) {
                        serverReady = true;
                        console.log('[OK] [MCP SERVER] Servidor iniciado exitosamente');
                        resolve(true);
                    }
                });
                
                serverProcess.stderr.on('data', (data) => {
                    console.error(`[ERROR] [MCP SERVER] Error: ${data.toString().trim()}`);
                });
                
                // Timeout de 30 segundos
                setTimeout(() => {
                    if (!serverReady) {
                        console.log('[WARNING] [MCP SERVER] Asumiendo servidor iniciado (timeout)');
                        resolve(true);
                    }
                }, 30000);
                
                serverProcess.on('error', (error) => {
                    console.error('[ERROR] [MCP SERVER] Error iniciando servidor:', error.message);
                    reject(error);
                });
            });
        });
    }
    
    /**
     * ðŸ”§ CONFIGURAR AUTOMATION
     */
    async setupAutomation() {
        console.log('ðŸ”§ [AUTOMATION] Configurando automation neural...');
        
        // [ENDPOINTS] QUERIES POR CATEGORÃA
        this.queryCategories = {
            core_assets: this.config.crypto_queries.core_assets,
            market_sentiment: this.config.crypto_queries.market_sentiment || [],
            technical_analysis: this.config.crypto_queries.technical_analysis || [],
            macroeconomic: this.config.crypto_queries.macroeconomic || [],
            on_chain: this.config.crypto_queries.on_chain || []
        };
        
        // [DATA] CONFIGURAR INTERVALOS ADAPTATIVOS
        this.setupAdaptiveIntervals();
        
        // ðŸ§  INICIALIZAR ESTADOS PSICOLÃ“GICOS
        await this.initializePsychologicalStates();
        
        console.log('[OK] [AUTOMATION] Automation configurada');
    }
    
    /**
     * [DATA] CONFIGURAR INTERVALOS ADAPTATIVOS
     */
    setupAdaptiveIntervals() {
        const baseInterval = this.config.search_automation.base_interval;
        
        // Intervalos por categorÃ­a
        this.searchIntervals.set('core_assets', baseInterval * 0.8);      // MÃ¡s frecuente
        this.searchIntervals.set('market_sentiment', baseInterval * 1.0);  // Base
        this.searchIntervals.set('technical_analysis', baseInterval * 1.2); // Menos frecuente
        this.searchIntervals.set('macroeconomic', baseInterval * 2.0);     // Muy menos frecuente
        this.searchIntervals.set('on_chain', baseInterval * 1.5);          // Moderado
        
        console.log('[DATA] [INTERVALS] Intervalos configurados:', Object.fromEntries(this.searchIntervals));
    }
    
    /**
     * ðŸ§  INICIALIZAR ESTADOS PSICOLÃ“GICOS
     */
    async initializePsychologicalStates() {
        console.log('ðŸ§  [PSYCHOLOGICAL] Inicializando estados psicolÃ³gicos...');
        
        // Inicializar estados para assets principales
        const mainAssets = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'];
        
        for (const symbol of mainAssets) {
            try {
                // Crear datos mock iniciales para bootstrapping
                const mockData = this.createMockSymbolData(symbol);
                
                // Analizar estado psicolÃ³gico inicial
                const estadoInicial = await analizarEstadoPsicologico(
                    symbol, 
                    mockData.price, 
                    mockData
                );
                
                this.psychologicalStates.set(symbol, estadoInicial);
                console.log(`ðŸ§  [${symbol}] Estado inicial: ${estadoInicial.estado_psicologico.emocion}`);
                
            } catch (error) {
                console.error(`[ERROR] [PSYCHOLOGICAL] Error inicializando ${symbol}:`, error.message);
            }
        }
        
        console.log('[OK] [PSYCHOLOGICAL] Estados psicolÃ³gicos inicializados');
    }
    
    /**
     * [DATA] CREAR DATOS MOCK PARA SÃMBOLO
     */
    createMockSymbolData(symbol) {
        const basePrices = { 'BTCUSDT': 45000, 'ETHUSDT': 2800, 'BNBUSDT': 320 };
        const basePrice = basePrices[symbol] || 1000;
        
        return {
            symbol: symbol,
            price: basePrice + (getSystemEntropy() - 0.5) * basePrice * 0.1,
            price_change: (getSystemEntropy() - 0.5) * 0.1,
            price_acceleration: (getSystemEntropy() - 0.5) * 0.05,
            volume: getSystemEntropy() * 1000000,
            volume_24h: getSystemEntropy() * 10000000,
            volume_change: (getSystemEntropy() - 0.5) * 0.3,
            funding_rate: (getSystemEntropy() - 0.5) * 0.01,
            funding_rate_change: (getSystemEntropy() - 0.5) * 0.005,
            volatility: getSystemEntropy() * 0.1,
            volatility_change: (getSystemEntropy() - 0.5) * 0.02,
            bid: basePrice * 0.999,
            ask: basePrice * 1.001,
            rsi: 30 + getSystemEntropy() * 40,
            macd: (getSystemEntropy() - 0.5) * 0.1,
            stochastic: 20 + getSystemEntropy() * 60
        };
    }
    
    /**
     * [RELOAD] INICIAR MONITOREO
     */
    async startMonitoring() {
        console.log('[RELOAD] [MONITORING] Iniciando monitoreo neural...');
        
        this.isRunning = true;
        
        // [START] Iniciar bÃºsquedas automÃ¡ticas
        this.startAutomaticSearches();
        
        // [DATA] Iniciar monitoreo de volatilidad
        this.startVolatilityMonitoring();
        
        // ðŸ§  Iniciar anÃ¡lisis psicolÃ³gico continuo
        this.startPsychologicalAnalysis();
        
        // [UP] Iniciar mÃ©tricas de performance
        this.startPerformanceMetrics();
        
        console.log('[OK] [MONITORING] Monitoreo iniciado exitosamente');
    }
    
    /**
     * [START] INICIAR BÃšSQUEDAS AUTOMÃTICAS
     */
    startAutomaticSearches() {
        console.log('[START] [SEARCHES] Iniciando bÃºsquedas automÃ¡ticas...');
        
        // BÃºsquedas por categorÃ­a
        for (const [category, interval] of this.searchIntervals.entries()) {
            this.scheduleSearchCategory(category, interval);
        }
    }
    
    /**
     * [TIME] PROGRAMAR BÃšSQUEDAS POR CATEGORÃA
     */
    scheduleSearchCategory(category, baseInterval) {
        const executeSearches = async () => {
            try {
                const queries = this.queryCategories[category];
                if (!queries || (Array.isArray(queries) && queries.length === 0)) return;
                
                console.log(`[SEARCH] [${category.toUpperCase()}] Ejecutando bÃºsquedas...`);
                
                if (typeof queries === 'object' && !Array.isArray(queries)) {
                    // Caso: { bitcoin: [...], ethereum: [...] }
                    for (const [asset, assetQueries] of Object.entries(queries)) {
                        await this.executeAssetSearches(asset, assetQueries, category);
                    }
                } else if (Array.isArray(queries)) {
                    // Caso: ['query1', 'query2', ...]
                    await this.executeGeneralSearches(queries, category);
                }
                
                this.metrics.totalSearches++;
                
            } catch (error) {
                console.error(`[ERROR] [${category.toUpperCase()}] Error en bÃºsquedas:`, error.message);
            }
        };
        
        // Ejecutar inmediatamente y luego programar
        executeSearches();
        
        setInterval(() => {
            const adaptiveInterval = this.calculateAdaptiveInterval(baseInterval);
            setTimeout(executeSearches, adaptiveInterval);
        }, baseInterval);
    }
    
    /**
     * ðŸª™ EJECUTAR BÃšSQUEDAS DE ASSET ESPECÃFICO
     */
    async executeAssetSearches(asset, queries, category) {
        console.log(`ðŸª™ [${asset.toUpperCase()}] Ejecutando ${queries.length} bÃºsquedas...`);
        
        for (const query of queries) {
            await this.executeSearch(query, { asset, category });
            
            // Pausa entre bÃºsquedas para evitar rate limiting
            await this.sleep(2000);
        }
    }
    
    /**
     * [SEARCH] EJECUTAR BÃšSQUEDAS GENERALES
     */
    async executeGeneralSearches(queries, category) {
        console.log(`[SEARCH] [${category.toUpperCase()}] Ejecutando ${queries.length} bÃºsquedas generales...`);
        
        for (const query of queries) {
            await this.executeSearch(query, { category });
            await this.sleep(2000);
        }
    }
    
    /**
     * [ENDPOINTS] EJECUTAR BÃšSQUEDA INDIVIDUAL
     */
    async executeSearch(query, metadata = {}) {
        try {
            const searchId = this.generateSearchId();
            console.log(`[ENDPOINTS] [SEARCH-${searchId}] Ejecutando: "${query}"`);
            
            // Preparar comando MCP
            const mcpCommand = this.buildMCPCommand(query);
            
            // Ejecutar bÃºsqueda
            const searchResult = await this.executeMCPCommand(mcpCommand);
            
            // Procesar resultado con anÃ¡lisis psicolÃ³gico
            const processedResult = await this.processSearchResult(searchResult, query, metadata);
            
            // Guardar en historial
            this.searchHistory.push({
                id: searchId,
                timestamp: new Date().toISOString(),
                query: query,
                metadata: metadata,
                result: processedResult,
                psychological_analysis: processedResult.psychological_analysis
            });
            
            // Mantener solo los Ãºltimos 100 resultados
            if (this.searchHistory.length > 100) {
                this.searchHistory.shift();
            }
            
            console.log(`[OK] [SEARCH-${searchId}] Completada exitosamente`);
            
            return processedResult;
            
        } catch (error) {
            console.error(`[ERROR] [SEARCH] Error ejecutando bÃºsqueda "${query}":`, error.message);
            this.metrics.successRate = this.metrics.successRate * 0.99; // Penalizar
            return null;
        }
    }
    
    /**
     * ðŸ› ï¸ CONSTRUIR COMANDO MCP
     */
    buildMCPCommand(query) {
        // Comando para PowerShell con JSON-RPC
        const jsonRpcRequest = {
            jsonrpc: '2.0',
            id: Date.now(),
            method: 'tools/call',
            params: {
                name: 'brave_web_search',
                arguments: {
                    query: query,
                    count: 5,
                    offset: 0
                }
            }
        };
        
        const jsonString = JSON.stringify(jsonRpcRequest).replace(/"/g, '\\"');
        
        return `echo "${jsonString}" | @brave/brave-search-mcp-server`;
    }
    
    /**
     * [FAST] EJECUTAR COMANDO MCP
     */
    executeMCPCommand(command) {
        return new Promise((resolve, reject) => {
            exec(command, { timeout: 30000 }, (error, stdout, stderr) => {
                if (error) {
                    reject(new Error(`MCP Command failed: ${error.message}`));
                    return;
                }
                
                if (stderr) {
                    console.warn('[WARNING] [MCP] Warning:', stderr);
                }
                
                try {
                    const result = JSON.parse(stdout);
                    resolve(result);
                } catch (parseError) {
                    console.error('[ERROR] [MCP] Error parsing result:', stdout);
                    resolve({ error: 'Parse error', raw: stdout });
                }
            });
        });
    }
    
    /**
     * ðŸ§  PROCESAR RESULTADO CON ANÃLISIS PSICOLÃ“GICO
     */
    async processSearchResult(searchResult, query, metadata) {
        try {
            // Analizar sentiment del contenido
            const sentiment = this.analyzeSentiment(searchResult);
            
            // Mapear sentiment a estado psicolÃ³gico
            const psychologicalState = this.mapSentimentToPsychological(sentiment);
            
            // Si es una bÃºsqueda de asset especÃ­fico, actualizar estado
            if (metadata.asset) {
                await this.updateAssetPsychologicalState(metadata.asset, searchResult, sentiment);
            }
            
            // Calcular impacto cuÃ¡ntico
            const quantumEnhancement = this.calculateQuantumEnhancement(sentiment, psychologicalState);
            
            return {
                search_query: query,
                metadata: metadata,
                results: searchResult,
                sentiment_analysis: {
                    score: sentiment,
                    psychological_state: psychologicalState,
                    confidence: this.calculateConfidence(searchResult),
                    quantum_enhancement: quantumEnhancement
                },
                psychological_analysis: {
                    state: psychologicalState,
                    transition: await this.analyzeStateTransition(metadata.asset, psychologicalState),
                    impact_score: this.calculateImpactScore(sentiment, metadata.category),
                    recommendation: this.generateRecommendation(psychologicalState, sentiment)
                },
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            console.error('[ERROR] [PROCESS] Error procesando resultado:', error.message);
            return {
                search_query: query,
                metadata: metadata,
                results: searchResult,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    /**
     * [DATA] ANALIZAR SENTIMENT
     */
    analyzeSentiment(searchResult) {
        if (!searchResult || !searchResult.result) return 0.5;
        
        // Keywords positivas y negativas
        const positiveKeywords = [
            'bullish', 'pump', 'moon', 'rally', 'breakout', 'surge', 'gain',
            'optimistic', 'positive', 'growth', 'adoption', 'institutional'
        ];
        
        const negativeKeywords = [
            'bearish', 'dump', 'crash', 'decline', 'drop', 'fall', 'panic',
            'pessimistic', 'negative', 'fear', 'regulation', 'ban', 'risk'
        ];
        
        let positiveScore = 0;
        let negativeScore = 0;
        let totalWords = 0;
        
        const text = JSON.stringify(searchResult).toLowerCase();
        const words = text.split(/\s+/);
        totalWords = words.length;
        
        words.forEach(word => {
            if (positiveKeywords.some(keyword => word.includes(keyword))) {
                positiveScore++;
            }
            if (negativeKeywords.some(keyword => word.includes(keyword))) {
                negativeScore++;
            }
        });
        
        // Normalizar entre 0 y 1
        const netScore = (positiveScore - negativeScore) / Math.max(totalWords * 0.1, 1);
        return Math.max(0, Math.min(1, 0.5 + netScore));
    }
    
    /**
     * [RELOAD] MAPEAR SENTIMENT A ESTADO PSICOLÃ“GICO
     */
    mapSentimentToPsychological(sentiment) {
        if (sentiment >= 0.8) return 'EUFORIA';
        if (sentiment >= 0.6) return 'OPTIMISMO';
        if (sentiment >= 0.4) return 'NEUTRAL';
        if (sentiment >= 0.2) return 'PESIMISMO';
        return 'PANICO';
    }
    
    /**
     * [DIAMOND] ACTUALIZAR ESTADO PSICOLÃ“GICO DEL ASSET
     */
    async updateAssetPsychologicalState(asset, searchResult, sentiment) {
        try {
            const symbol = this.assetToSymbol(asset);
            const currentState = this.psychologicalStates.get(symbol);
            
            // Crear datos actualizados
            const mockData = this.createMockSymbolData(symbol);
            mockData.news_sentiment = sentiment;
            mockData.news_impact = this.calculateNewsImpact(searchResult);
            
            // Analizar nuevo estado psicolÃ³gico
            const newState = await analizarEstadoPsicologico(
                symbol,
                mockData.price,
                mockData,
                currentState?.estado_psicologico
            );
            
            // Detectar transiciÃ³n
            if (currentState && currentState.estado_psicologico.emocion !== newState.estado_psicologico.emocion) {
                console.log(`[RELOAD] [${symbol}] TransiciÃ³n psicolÃ³gica: ${currentState.estado_psicologico.emocion} â†’ ${newState.estado_psicologico.emocion}`);
                this.metrics.psychologicalTransitions++;
            }
            
            // Guardar estado anterior y actualizar
            this.lastStates.set(symbol, currentState);
            this.psychologicalStates.set(symbol, newState);
            
        } catch (error) {
            console.error(`[ERROR] [PSYCHOLOGICAL] Error actualizando estado ${asset}:`, error.message);
        }
    }
    
    /**
     * ðŸ”— CONVERTIR ASSET A SÃMBOLO
     */
    assetToSymbol(asset) {
        const mapping = {
            'bitcoin': 'BTCUSDT',
            'ethereum': 'ETHUSDT',
            'binance': 'BNBUSDT',
            'btc': 'BTCUSDT',
            'eth': 'ETHUSDT',
            'bnb': 'BNBUSDT'
        };
        
        return mapping[asset.toLowerCase()] || 'BTCUSDT';
    }
    
    // ðŸ› ï¸ MÃ‰TODOS AUXILIARES
    
    calculateAdaptiveInterval(baseInterval) {
        return baseInterval * this.sessionMultiplier * (0.8 + getSystemEntropy() * 0.4);
    }
    
    calculateQuantumEnhancement(sentiment, psychologicalState) {
        const stateMultipliers = {
            'EUFORIA': 1.3,
            'OPTIMISMO': 1.1,
            'NEUTRAL': 1.0,
            'PESIMISMO': 0.9,
            'PANICO': 0.7
        };
        
        return sentiment * (stateMultipliers[psychologicalState] || 1.0);
    }
    
    calculateConfidence(searchResult) {
        if (!searchResult || !searchResult.result) return 0.5;
        
        // Confidence basado en cantidad y calidad de resultados
        const resultCount = Array.isArray(searchResult.result) ? searchResult.result.length : 1;
        return Math.min(1.0, 0.3 + (resultCount * 0.15));
    }
    
    calculateNewsImpact(searchResult) {
        // Calcular impacto basado en fuentes y contenido
        return 0.5 + getSystemEntropy() * 0.5;
    }
    
    calculateImpactScore(sentiment, category) {
        const categoryWeights = {
            'core_assets': 1.0,
            'market_sentiment': 0.8,
            'technical_analysis': 0.6,
            'macroeconomic': 0.9,
            'on_chain': 0.7
        };
        
        return sentiment * (categoryWeights[category] || 0.5);
    }
    
    generateRecommendation(psychologicalState, sentiment) {
        const recommendations = {
            'EUFORIA': 'Considerar toma de ganancias - Mercado sobrecalentado',
            'OPTIMISMO': 'Mantener posiciones - Tendencia positiva',
            'NEUTRAL': 'Esperar confirmaciÃ³n - Mercado indeciso',
            'PESIMISMO': 'Evaluar oportunidades de compra - Mercado pesimista',
            'PANICO': 'Oportunidad de acumulaciÃ³n - Mercado en pÃ¡nico'
        };
        
        return recommendations[psychologicalState] || 'Mantener vigilancia';
    }
    
    analyzeStateTransition(asset, newPsychologicalState) {
        if (!asset) return null;
        
        const symbol = this.assetToSymbol(asset);
        const lastState = this.lastStates.get(symbol);
        
        if (!lastState) return null;
        
        return {
            from: lastState.estado_psicologico.emocion,
            to: newPsychologicalState,
            type: this.determineTransitionType(lastState.estado_psicologico.emocion, newPsychologicalState),
            intensity: this.calculateTransitionIntensity(lastState.estado_psicologico.emocion, newPsychologicalState)
        };
    }
    
    determineTransitionType(fromState, toState) {
        const states = ['PANICO', 'PESIMISMO', 'NEUTRAL', 'OPTIMISMO', 'EUFORIA'];
        const fromIndex = states.indexOf(fromState);
        const toIndex = states.indexOf(toState);
        
        if (fromIndex === toIndex) return 'STABLE';
        if (toIndex > fromIndex) return 'BULLISH_TRANSITION';
        return 'BEARISH_TRANSITION';
    }
    
    calculateTransitionIntensity(fromState, toState) {
        const states = ['PANICO', 'PESIMISMO', 'NEUTRAL', 'OPTIMISMO', 'EUFORIA'];
        const fromIndex = states.indexOf(fromState);
        const toIndex = states.indexOf(toState);
        
        return Math.abs(toIndex - fromIndex) / (states.length - 1);
    }
    
    generateSearchId() {
        return Date.now().toString(36) + getSystemEntropy().toString(36).substr(2);
    }
    
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    async validateConfiguration() {
        console.log('[OK] [VALIDATION] Validando configuraciÃ³n...');
        
        if (!process.env.BRAVE_SEARCH_API_KEY) {
            throw new Error('BRAVE_SEARCH_API_KEY no configurada');
        }
        
        console.log('[OK] [VALIDATION] ConfiguraciÃ³n vÃ¡lida');
    }
    
    startVolatilityMonitoring() {
        console.log('[DATA] [VOLATILITY] Iniciando monitoreo de volatilidad...');
        // Placeholder para monitoreo de volatilidad
    }
    
    startPsychologicalAnalysis() {
        console.log('ðŸ§  [ANALYSIS] Iniciando anÃ¡lisis psicolÃ³gico continuo...');
        // Placeholder para anÃ¡lisis continuo
    }
    
    startPerformanceMetrics() {
        console.log('[UP] [METRICS] Iniciando mÃ©tricas de performance...');
        
        setInterval(() => {
            this.metrics.lastUpdate = new Date().toISOString();
            console.log('[DATA] [METRICS] Estado actual:', this.metrics);
        }, 60000); // Cada minuto
    }
    
    /**
     * [DATA] OBTENER ESTADO ACTUAL DEL SISTEMA
     */
    getSystemStatus() {
        return {
            isRunning: this.isRunning,
            metrics: this.metrics,
            activeStates: Object.fromEntries(
                Array.from(this.psychologicalStates.entries()).map(([symbol, state]) => [
                    symbol,
                    state.estado_psicologico.emocion
                ])
            ),
            recentSearches: this.searchHistory.slice(-5),
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * ðŸ›‘ DETENER SISTEMA
     */
    stop() {
        console.log('ðŸ›‘ [SYSTEM] Deteniendo sistema...');
        this.isRunning = false;
        // Limpiar intervalos si fuera necesario
        console.log('[OK] [SYSTEM] Sistema detenido');
    }
}

// [START] INICIALIZAR Y EXPORTAR
const mcpCryptoNeural = new MCPCryptoNeuralAutomation();

module.exports = {
    MCPCryptoNeuralAutomation,
    mcpCryptoNeural
};

// Si se ejecuta directamente
if (require.main === module) {
    console.log('[START] [MAIN] Iniciando MCP Crypto Neural Automation...');
    
    // Manejar seÃ±ales de terminaciÃ³n
    process.on('SIGINT', () => {
        console.log('\\nðŸ›‘ [MAIN] Recibida seÃ±al SIGINT, deteniendo...');
        mcpCryptoNeural.stop();
        process.exit(0);
    });
    
    process.on('SIGTERM', () => {
        console.log('\\nðŸ›‘ [MAIN] Recibida seÃ±al SIGTERM, deteniendo...');
        mcpCryptoNeural.stop();
        process.exit(0);
    });
}
