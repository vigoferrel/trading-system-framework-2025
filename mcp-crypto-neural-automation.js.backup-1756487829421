/**
 * üß† MCP CRYPTO NEURAL AUTOMATION
 * ===============================
 * 
 * Sistema automatizado de b√∫squedas MCP Brave integrado con an√°lisis psicol√≥gico neural
 * para potenciar el n√∫cleo de tasas de cambio existente
 */

const fs = require('fs');
const { spawn, exec } = require('child_process');
const { analizarEstadoPsicologico } = require('./nucleo-psicologico-tasas-cambio.js');

class MCPCryptoNeuralAutomation {
    constructor() {
        console.log('üß† [MCP NEURAL] Inicializando automation crypto neural...');
        
        // üìã CONFIGURACI√ìN
        this.config = this.loadConfig();
        this.isRunning = false;
        this.searchHistory = [];
        this.psychologicalStates = new Map();
        this.lastStates = new Map();
        
        // üîÑ INTERVALOS
        this.searchIntervals = new Map();
        this.volatilityMonitor = null;
        this.sessionMultiplier = 1.0;
        
        // üìä M√âTRICAS
        this.metrics = {
            totalSearches: 0,
            psychologicalTransitions: 0,
            quantumEnhancements: 0,
            lastUpdate: null,
            averageConfidence: 0,
            successRate: 1.0
        };
        
        this.initializeSystem();
    }
    
    /**
     * üöÄ INICIALIZAR SISTEMA COMPLETO
     */
    async initializeSystem() {
        try {
            console.log('üöÄ [MCP NEURAL] Iniciando sistema completo...');
            
            // ‚úÖ 1. CARGAR CONFIGURACI√ìN
            await this.validateConfiguration();
            
            // ‚úÖ 2. INICIALIZAR MCP BRAVE SERVER
            await this.initializeMCPServer();
            
            // ‚úÖ 3. CONFIGURAR AUTOMATION
            await this.setupAutomation();
            
            // ‚úÖ 4. INICIAR MONITOREO
            await this.startMonitoring();
            
            console.log('‚úÖ [MCP NEURAL] Sistema inicializado exitosamente');
            
        } catch (error) {
            console.error('‚ùå [MCP NEURAL] Error inicializando sistema:', error.message);
            process.exit(1);
        }
    }
    
    /**
     * üìã CARGAR CONFIGURACI√ìN
     */
    loadConfig() {
        try {
            const configPath = './mcp-crypto-config.json';
            if (fs.existsSync(configPath)) {
                const configData = fs.readFileSync(configPath, 'utf8');
                return JSON.parse(configData).mcp_crypto_configuration;
            }
            throw new Error('Archivo de configuraci√≥n no encontrado');
        } catch (error) {
            console.error('‚ùå [CONFIG] Error cargando configuraci√≥n:', error.message);
            return this.getDefaultConfig();
        }
    }
    
    /**
     * üîß CONFIGURACI√ìN POR DEFECTO
     */
    getDefaultConfig() {
        return {
            server_name: 'brave-crypto-neural-mcp',
            port: 9847,
            search_automation: {
                enabled: true,
                base_interval: 300000, // 5 minutos
                adaptive_frequency: true
            },
            crypto_queries: {
                core_assets: {
                    bitcoin: ['Bitcoin BTC precio an√°lisis t√©cnico'],
                    ethereum: ['Ethereum ETH precio predicci√≥n'],
                    binance: ['Binance BNB token analysis']
                }
            }
        };
    }
    
    /**
     * üõ†Ô∏è INICIALIZAR MCP SERVER
     */
    async initializeMCPServer() {
        return new Promise((resolve, reject) => {
            console.log('üõ†Ô∏è [MCP SERVER] Iniciando servidor MCP Brave...');
            
            // Verificar si el servidor ya est√° corriendo
            exec('netstat -an | findstr :9847', (error, stdout) => {
                if (stdout && stdout.includes('9847')) {
                    console.log('‚úÖ [MCP SERVER] Servidor ya est√° corriendo en puerto 9847');
                    resolve(true);
                    return;
                }
                
                // Iniciar servidor MCP
                const serverProcess = spawn('npx', [
                    '@brave/brave-search-mcp-server',
                    '--port', this.config.port.toString()
                ], {
                    stdio: ['ignore', 'pipe', 'pipe'],
                    env: { ...process.env, BRAVE_SEARCH_API_KEY: process.env.BRAVE_SEARCH_API_KEY }
                });
                
                let serverReady = false;
                
                serverProcess.stdout.on('data', (data) => {
                    const output = data.toString();
                    console.log(`üì° [MCP SERVER] ${output.trim()}`);
                    
                    if (output.includes('Server running') || output.includes('listening')) {
                        serverReady = true;
                        console.log('‚úÖ [MCP SERVER] Servidor iniciado exitosamente');
                        resolve(true);
                    }
                });
                
                serverProcess.stderr.on('data', (data) => {
                    console.error(`‚ùå [MCP SERVER] Error: ${data.toString().trim()}`);
                });
                
                // Timeout de 30 segundos
                setTimeout(() => {
                    if (!serverReady) {
                        console.log('‚ö†Ô∏è [MCP SERVER] Asumiendo servidor iniciado (timeout)');
                        resolve(true);
                    }
                }, 30000);
                
                serverProcess.on('error', (error) => {
                    console.error('‚ùå [MCP SERVER] Error iniciando servidor:', error.message);
                    reject(error);
                });
            });
        });
    }
    
    /**
     * üîß CONFIGURAR AUTOMATION
     */
    async setupAutomation() {
        console.log('üîß [AUTOMATION] Configurando automation neural...');
        
        // üéØ QUERIES POR CATEGOR√çA
        this.queryCategories = {
            core_assets: this.config.crypto_queries.core_assets,
            market_sentiment: this.config.crypto_queries.market_sentiment || [],
            technical_analysis: this.config.crypto_queries.technical_analysis || [],
            macroeconomic: this.config.crypto_queries.macroeconomic || [],
            on_chain: this.config.crypto_queries.on_chain || []
        };
        
        // üìä CONFIGURAR INTERVALOS ADAPTATIVOS
        this.setupAdaptiveIntervals();
        
        // üß† INICIALIZAR ESTADOS PSICOL√ìGICOS
        await this.initializePsychologicalStates();
        
        console.log('‚úÖ [AUTOMATION] Automation configurada');
    }
    
    /**
     * üìä CONFIGURAR INTERVALOS ADAPTATIVOS
     */
    setupAdaptiveIntervals() {
        const baseInterval = this.config.search_automation.base_interval;
        
        // Intervalos por categor√≠a
        this.searchIntervals.set('core_assets', baseInterval * 0.8);      // M√°s frecuente
        this.searchIntervals.set('market_sentiment', baseInterval * 1.0);  // Base
        this.searchIntervals.set('technical_analysis', baseInterval * 1.2); // Menos frecuente
        this.searchIntervals.set('macroeconomic', baseInterval * 2.0);     // Muy menos frecuente
        this.searchIntervals.set('on_chain', baseInterval * 1.5);          // Moderado
        
        console.log('üìä [INTERVALS] Intervalos configurados:', Object.fromEntries(this.searchIntervals));
    }
    
    /**
     * üß† INICIALIZAR ESTADOS PSICOL√ìGICOS
     */
    async initializePsychologicalStates() {
        console.log('üß† [PSYCHOLOGICAL] Inicializando estados psicol√≥gicos...');
        
        // Inicializar estados para assets principales
        const mainAssets = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'];
        
        for (const symbol of mainAssets) {
            try {
                // Crear datos mock iniciales para bootstrapping
                const mockData = this.createMockSymbolData(symbol);
                
                // Analizar estado psicol√≥gico inicial
                const estadoInicial = await analizarEstadoPsicologico(
                    symbol, 
                    mockData.price, 
                    mockData
                );
                
                this.psychologicalStates.set(symbol, estadoInicial);
                console.log(`üß† [${symbol}] Estado inicial: ${estadoInicial.estado_psicologico.emocion}`);
                
            } catch (error) {
                console.error(`‚ùå [PSYCHOLOGICAL] Error inicializando ${symbol}:`, error.message);
            }
        }
        
        console.log('‚úÖ [PSYCHOLOGICAL] Estados psicol√≥gicos inicializados');
    }
    
    /**
     * üìä CREAR DATOS MOCK PARA S√çMBOLO
     */
    createMockSymbolData(symbol) {
        const basePrices = { 'BTCUSDT': 45000, 'ETHUSDT': 2800, 'BNBUSDT': 320 };
        const basePrice = basePrices[symbol] || 1000;
        
        return {
            symbol: symbol,
            price: basePrice + (Math.random() - 0.5) * basePrice * 0.1,
            price_change: (Math.random() - 0.5) * 0.1,
            price_acceleration: (Math.random() - 0.5) * 0.05,
            volume: Math.random() * 1000000,
            volume_24h: Math.random() * 10000000,
            volume_change: (Math.random() - 0.5) * 0.3,
            funding_rate: (Math.random() - 0.5) * 0.01,
            funding_rate_change: (Math.random() - 0.5) * 0.005,
            volatility: Math.random() * 0.1,
            volatility_change: (Math.random() - 0.5) * 0.02,
            bid: basePrice * 0.999,
            ask: basePrice * 1.001,
            rsi: 30 + Math.random() * 40,
            macd: (Math.random() - 0.5) * 0.1,
            stochastic: 20 + Math.random() * 60
        };
    }
    
    /**
     * üîÑ INICIAR MONITOREO
     */
    async startMonitoring() {
        console.log('üîÑ [MONITORING] Iniciando monitoreo neural...');
        
        this.isRunning = true;
        
        // üöÄ Iniciar b√∫squedas autom√°ticas
        this.startAutomaticSearches();
        
        // üìä Iniciar monitoreo de volatilidad
        this.startVolatilityMonitoring();
        
        // üß† Iniciar an√°lisis psicol√≥gico continuo
        this.startPsychologicalAnalysis();
        
        // üìà Iniciar m√©tricas de performance
        this.startPerformanceMetrics();
        
        console.log('‚úÖ [MONITORING] Monitoreo iniciado exitosamente');
    }
    
    /**
     * üöÄ INICIAR B√öSQUEDAS AUTOM√ÅTICAS
     */
    startAutomaticSearches() {
        console.log('üöÄ [SEARCHES] Iniciando b√∫squedas autom√°ticas...');
        
        // B√∫squedas por categor√≠a
        for (const [category, interval] of this.searchIntervals.entries()) {
            this.scheduleSearchCategory(category, interval);
        }
    }
    
    /**
     * ‚è∞ PROGRAMAR B√öSQUEDAS POR CATEGOR√çA
     */
    scheduleSearchCategory(category, baseInterval) {
        const executeSearches = async () => {
            try {
                const queries = this.queryCategories[category];
                if (!queries || (Array.isArray(queries) && queries.length === 0)) return;
                
                console.log(`üîç [${category.toUpperCase()}] Ejecutando b√∫squedas...`);
                
                if (typeof queries === 'object' && !Array.isArray(queries)) {
                    // Caso: { bitcoin: [...], ethereum: [...] }
                    for (const [asset, assetQueries] of Object.entries(queries)) {
                        await this.executeAssetSearches(asset, assetQueries, category);
                    }
                } else if (Array.isArray(queries)) {
                    // Caso: ['query1', 'query2', ...]
                    await this.executeGeneralSearches(queries, category);
                }
                
                this.metrics.totalSearches++;
                
            } catch (error) {
                console.error(`‚ùå [${category.toUpperCase()}] Error en b√∫squedas:`, error.message);
            }
        };
        
        // Ejecutar inmediatamente y luego programar
        executeSearches();
        
        setInterval(() => {
            const adaptiveInterval = this.calculateAdaptiveInterval(baseInterval);
            setTimeout(executeSearches, adaptiveInterval);
        }, baseInterval);
    }
    
    /**
     * ü™ô EJECUTAR B√öSQUEDAS DE ASSET ESPEC√çFICO
     */
    async executeAssetSearches(asset, queries, category) {
        console.log(`ü™ô [${asset.toUpperCase()}] Ejecutando ${queries.length} b√∫squedas...`);
        
        for (const query of queries) {
            await this.executeSearch(query, { asset, category });
            
            // Pausa entre b√∫squedas para evitar rate limiting
            await this.sleep(2000);
        }
    }
    
    /**
     * üîç EJECUTAR B√öSQUEDAS GENERALES
     */
    async executeGeneralSearches(queries, category) {
        console.log(`üîç [${category.toUpperCase()}] Ejecutando ${queries.length} b√∫squedas generales...`);
        
        for (const query of queries) {
            await this.executeSearch(query, { category });
            await this.sleep(2000);
        }
    }
    
    /**
     * üéØ EJECUTAR B√öSQUEDA INDIVIDUAL
     */
    async executeSearch(query, metadata = {}) {
        try {
            const searchId = this.generateSearchId();
            console.log(`üéØ [SEARCH-${searchId}] Ejecutando: "${query}"`);
            
            // Preparar comando MCP
            const mcpCommand = this.buildMCPCommand(query);
            
            // Ejecutar b√∫squeda
            const searchResult = await this.executeMCPCommand(mcpCommand);
            
            // Procesar resultado con an√°lisis psicol√≥gico
            const processedResult = await this.processSearchResult(searchResult, query, metadata);
            
            // Guardar en historial
            this.searchHistory.push({
                id: searchId,
                timestamp: new Date().toISOString(),
                query: query,
                metadata: metadata,
                result: processedResult,
                psychological_analysis: processedResult.psychological_analysis
            });
            
            // Mantener solo los √∫ltimos 100 resultados
            if (this.searchHistory.length > 100) {
                this.searchHistory.shift();
            }
            
            console.log(`‚úÖ [SEARCH-${searchId}] Completada exitosamente`);
            
            return processedResult;
            
        } catch (error) {
            console.error(`‚ùå [SEARCH] Error ejecutando b√∫squeda "${query}":`, error.message);
            this.metrics.successRate = this.metrics.successRate * 0.99; // Penalizar
            return null;
        }
    }
    
    /**
     * üõ†Ô∏è CONSTRUIR COMANDO MCP
     */
    buildMCPCommand(query) {
        // Comando para PowerShell con JSON-RPC
        const jsonRpcRequest = {
            jsonrpc: '2.0',
            id: Date.now(),
            method: 'tools/call',
            params: {
                name: 'brave_web_search',
                arguments: {
                    query: query,
                    count: 5,
                    offset: 0
                }
            }
        };
        
        const jsonString = JSON.stringify(jsonRpcRequest).replace(/"/g, '\\"');
        
        return `echo "${jsonString}" | @brave/brave-search-mcp-server`;
    }
    
    /**
     * ‚ö° EJECUTAR COMANDO MCP
     */
    executeMCPCommand(command) {
        return new Promise((resolve, reject) => {
            exec(command, { timeout: 30000 }, (error, stdout, stderr) => {
                if (error) {
                    reject(new Error(`MCP Command failed: ${error.message}`));
                    return;
                }
                
                if (stderr) {
                    console.warn('‚ö†Ô∏è [MCP] Warning:', stderr);
                }
                
                try {
                    const result = JSON.parse(stdout);
                    resolve(result);
                } catch (parseError) {
                    console.error('‚ùå [MCP] Error parsing result:', stdout);
                    resolve({ error: 'Parse error', raw: stdout });
                }
            });
        });
    }
    
    /**
     * üß† PROCESAR RESULTADO CON AN√ÅLISIS PSICOL√ìGICO
     */
    async processSearchResult(searchResult, query, metadata) {
        try {
            // Analizar sentiment del contenido
            const sentiment = this.analyzeSentiment(searchResult);
            
            // Mapear sentiment a estado psicol√≥gico
            const psychologicalState = this.mapSentimentToPsychological(sentiment);
            
            // Si es una b√∫squeda de asset espec√≠fico, actualizar estado
            if (metadata.asset) {
                await this.updateAssetPsychologicalState(metadata.asset, searchResult, sentiment);
            }
            
            // Calcular impacto cu√°ntico
            const quantumEnhancement = this.calculateQuantumEnhancement(sentiment, psychologicalState);
            
            return {
                search_query: query,
                metadata: metadata,
                results: searchResult,
                sentiment_analysis: {
                    score: sentiment,
                    psychological_state: psychologicalState,
                    confidence: this.calculateConfidence(searchResult),
                    quantum_enhancement: quantumEnhancement
                },
                psychological_analysis: {
                    state: psychologicalState,
                    transition: await this.analyzeStateTransition(metadata.asset, psychologicalState),
                    impact_score: this.calculateImpactScore(sentiment, metadata.category),
                    recommendation: this.generateRecommendation(psychologicalState, sentiment)
                },
                timestamp: new Date().toISOString()
            };
            
        } catch (error) {
            console.error('‚ùå [PROCESS] Error procesando resultado:', error.message);
            return {
                search_query: query,
                metadata: metadata,
                results: searchResult,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    /**
     * üìä ANALIZAR SENTIMENT
     */
    analyzeSentiment(searchResult) {
        if (!searchResult || !searchResult.result) return 0.5;
        
        // Keywords positivas y negativas
        const positiveKeywords = [
            'bullish', 'pump', 'moon', 'rally', 'breakout', 'surge', 'gain',
            'optimistic', 'positive', 'growth', 'adoption', 'institutional'
        ];
        
        const negativeKeywords = [
            'bearish', 'dump', 'crash', 'decline', 'drop', 'fall', 'panic',
            'pessimistic', 'negative', 'fear', 'regulation', 'ban', 'risk'
        ];
        
        let positiveScore = 0;
        let negativeScore = 0;
        let totalWords = 0;
        
        const text = JSON.stringify(searchResult).toLowerCase();
        const words = text.split(/\s+/);
        totalWords = words.length;
        
        words.forEach(word => {
            if (positiveKeywords.some(keyword => word.includes(keyword))) {
                positiveScore++;
            }
            if (negativeKeywords.some(keyword => word.includes(keyword))) {
                negativeScore++;
            }
        });
        
        // Normalizar entre 0 y 1
        const netScore = (positiveScore - negativeScore) / Math.max(totalWords * 0.1, 1);
        return Math.max(0, Math.min(1, 0.5 + netScore));
    }
    
    /**
     * üîÑ MAPEAR SENTIMENT A ESTADO PSICOL√ìGICO
     */
    mapSentimentToPsychological(sentiment) {
        if (sentiment >= 0.8) return 'EUFORIA';
        if (sentiment >= 0.6) return 'OPTIMISMO';
        if (sentiment >= 0.4) return 'NEUTRAL';
        if (sentiment >= 0.2) return 'PESIMISMO';
        return 'PANICO';
    }
    
    /**
     * üíé ACTUALIZAR ESTADO PSICOL√ìGICO DEL ASSET
     */
    async updateAssetPsychologicalState(asset, searchResult, sentiment) {
        try {
            const symbol = this.assetToSymbol(asset);
            const currentState = this.psychologicalStates.get(symbol);
            
            // Crear datos actualizados
            const mockData = this.createMockSymbolData(symbol);
            mockData.news_sentiment = sentiment;
            mockData.news_impact = this.calculateNewsImpact(searchResult);
            
            // Analizar nuevo estado psicol√≥gico
            const newState = await analizarEstadoPsicologico(
                symbol,
                mockData.price,
                mockData,
                currentState?.estado_psicologico
            );
            
            // Detectar transici√≥n
            if (currentState && currentState.estado_psicologico.emocion !== newState.estado_psicologico.emocion) {
                console.log(`üîÑ [${symbol}] Transici√≥n psicol√≥gica: ${currentState.estado_psicologico.emocion} ‚Üí ${newState.estado_psicologico.emocion}`);
                this.metrics.psychologicalTransitions++;
            }
            
            // Guardar estado anterior y actualizar
            this.lastStates.set(symbol, currentState);
            this.psychologicalStates.set(symbol, newState);
            
        } catch (error) {
            console.error(`‚ùå [PSYCHOLOGICAL] Error actualizando estado ${asset}:`, error.message);
        }
    }
    
    /**
     * üîó CONVERTIR ASSET A S√çMBOLO
     */
    assetToSymbol(asset) {
        const mapping = {
            'bitcoin': 'BTCUSDT',
            'ethereum': 'ETHUSDT',
            'binance': 'BNBUSDT',
            'btc': 'BTCUSDT',
            'eth': 'ETHUSDT',
            'bnb': 'BNBUSDT'
        };
        
        return mapping[asset.toLowerCase()] || 'BTCUSDT';
    }
    
    // üõ†Ô∏è M√âTODOS AUXILIARES
    
    calculateAdaptiveInterval(baseInterval) {
        return baseInterval * this.sessionMultiplier * (0.8 + Math.random() * 0.4);
    }
    
    calculateQuantumEnhancement(sentiment, psychologicalState) {
        const stateMultipliers = {
            'EUFORIA': 1.3,
            'OPTIMISMO': 1.1,
            'NEUTRAL': 1.0,
            'PESIMISMO': 0.9,
            'PANICO': 0.7
        };
        
        return sentiment * (stateMultipliers[psychologicalState] || 1.0);
    }
    
    calculateConfidence(searchResult) {
        if (!searchResult || !searchResult.result) return 0.5;
        
        // Confidence basado en cantidad y calidad de resultados
        const resultCount = Array.isArray(searchResult.result) ? searchResult.result.length : 1;
        return Math.min(1.0, 0.3 + (resultCount * 0.15));
    }
    
    calculateNewsImpact(searchResult) {
        // Calcular impacto basado en fuentes y contenido
        return 0.5 + Math.random() * 0.5;
    }
    
    calculateImpactScore(sentiment, category) {
        const categoryWeights = {
            'core_assets': 1.0,
            'market_sentiment': 0.8,
            'technical_analysis': 0.6,
            'macroeconomic': 0.9,
            'on_chain': 0.7
        };
        
        return sentiment * (categoryWeights[category] || 0.5);
    }
    
    generateRecommendation(psychologicalState, sentiment) {
        const recommendations = {
            'EUFORIA': 'Considerar toma de ganancias - Mercado sobrecalentado',
            'OPTIMISMO': 'Mantener posiciones - Tendencia positiva',
            'NEUTRAL': 'Esperar confirmaci√≥n - Mercado indeciso',
            'PESIMISMO': 'Evaluar oportunidades de compra - Mercado pesimista',
            'PANICO': 'Oportunidad de acumulaci√≥n - Mercado en p√°nico'
        };
        
        return recommendations[psychologicalState] || 'Mantener vigilancia';
    }
    
    analyzeStateTransition(asset, newPsychologicalState) {
        if (!asset) return null;
        
        const symbol = this.assetToSymbol(asset);
        const lastState = this.lastStates.get(symbol);
        
        if (!lastState) return null;
        
        return {
            from: lastState.estado_psicologico.emocion,
            to: newPsychologicalState,
            type: this.determineTransitionType(lastState.estado_psicologico.emocion, newPsychologicalState),
            intensity: this.calculateTransitionIntensity(lastState.estado_psicologico.emocion, newPsychologicalState)
        };
    }
    
    determineTransitionType(fromState, toState) {
        const states = ['PANICO', 'PESIMISMO', 'NEUTRAL', 'OPTIMISMO', 'EUFORIA'];
        const fromIndex = states.indexOf(fromState);
        const toIndex = states.indexOf(toState);
        
        if (fromIndex === toIndex) return 'STABLE';
        if (toIndex > fromIndex) return 'BULLISH_TRANSITION';
        return 'BEARISH_TRANSITION';
    }
    
    calculateTransitionIntensity(fromState, toState) {
        const states = ['PANICO', 'PESIMISMO', 'NEUTRAL', 'OPTIMISMO', 'EUFORIA'];
        const fromIndex = states.indexOf(fromState);
        const toIndex = states.indexOf(toState);
        
        return Math.abs(toIndex - fromIndex) / (states.length - 1);
    }
    
    generateSearchId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    async validateConfiguration() {
        console.log('‚úÖ [VALIDATION] Validando configuraci√≥n...');
        
        if (!process.env.BRAVE_SEARCH_API_KEY) {
            throw new Error('BRAVE_SEARCH_API_KEY no configurada');
        }
        
        console.log('‚úÖ [VALIDATION] Configuraci√≥n v√°lida');
    }
    
    startVolatilityMonitoring() {
        console.log('üìä [VOLATILITY] Iniciando monitoreo de volatilidad...');
        // Placeholder para monitoreo de volatilidad
    }
    
    startPsychologicalAnalysis() {
        console.log('üß† [ANALYSIS] Iniciando an√°lisis psicol√≥gico continuo...');
        // Placeholder para an√°lisis continuo
    }
    
    startPerformanceMetrics() {
        console.log('üìà [METRICS] Iniciando m√©tricas de performance...');
        
        setInterval(() => {
            this.metrics.lastUpdate = new Date().toISOString();
            console.log('üìä [METRICS] Estado actual:', this.metrics);
        }, 60000); // Cada minuto
    }
    
    /**
     * üìä OBTENER ESTADO ACTUAL DEL SISTEMA
     */
    getSystemStatus() {
        return {
            isRunning: this.isRunning,
            metrics: this.metrics,
            activeStates: Object.fromEntries(
                Array.from(this.psychologicalStates.entries()).map(([symbol, state]) => [
                    symbol,
                    state.estado_psicologico.emocion
                ])
            ),
            recentSearches: this.searchHistory.slice(-5),
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * üõë DETENER SISTEMA
     */
    stop() {
        console.log('üõë [SYSTEM] Deteniendo sistema...');
        this.isRunning = false;
        // Limpiar intervalos si fuera necesario
        console.log('‚úÖ [SYSTEM] Sistema detenido');
    }
}

// üöÄ INICIALIZAR Y EXPORTAR
const mcpCryptoNeural = new MCPCryptoNeuralAutomation();

module.exports = {
    MCPCryptoNeuralAutomation,
    mcpCryptoNeural
};

// Si se ejecuta directamente
if (require.main === module) {
    console.log('üöÄ [MAIN] Iniciando MCP Crypto Neural Automation...');
    
    // Manejar se√±ales de terminaci√≥n
    process.on('SIGINT', () => {
        console.log('\\nüõë [MAIN] Recibida se√±al SIGINT, deteniendo...');
        mcpCryptoNeural.stop();
        process.exit(0);
    });
    
    process.on('SIGTERM', () => {
        console.log('\\nüõë [MAIN] Recibida se√±al SIGTERM, deteniendo...');
        mcpCryptoNeural.stop();
        process.exit(0);
    });
}
