const axios = require('axios');

// Funci√≥n para diagnosticar inconsistencias de datos
async function diagnoseDataInconsistencies() {
    try {
        console.log('üîç Diagnosticando inconsistencias de datos...');
        
        // Obtener datos del endpoint
        const response = await axios.get('http://localhost:4602/api/enhanced-opportunities');
        
        if (response.data && response.data.opportunities) {
            const opportunities = response.data.opportunities;
            
            console.log(`üìä Total oportunidades: ${opportunities.length}`);
            
            // Analizar problemas
            const problems = {
                nanPrices: [],
                invalidPrices: [],
                missingData: [],
                zeroVolumes: []
            };
            
            opportunities.forEach((opp, index) => {
                // Verificar precios NaN
                if (isNaN(opp.currentPrice) || opp.currentPrice === null || opp.currentPrice === undefined) {
                    problems.nanPrices.push({
                        symbol: opp.symbol,
                        index: index,
                        currentPrice: opp.currentPrice,
                        priceChange: opp.priceChange,
                        priceChangePercent: opp.priceChangePercent
                    });
                }
                
                // Verificar precios inv√°lidos
                if (opp.currentPrice <= 0 && !isNaN(opp.currentPrice)) {
                    problems.invalidPrices.push({
                        symbol: opp.symbol,
                        currentPrice: opp.currentPrice
                    });
                }
                
                // Verificar datos faltantes
                if (!opp.priceChange && !opp.priceChangePercent) {
                    problems.missingData.push({
                        symbol: opp.symbol,
                        volume: opp.volume
                    });
                }
                
                // Verificar vol√∫menes cero
                if (opp.volume === 0 || opp.volume === null || opp.volume === undefined) {
                    problems.zeroVolumes.push({
                        symbol: opp.symbol,
                        volume: opp.volume
                    });
                }
            });
            
            // Mostrar resultados
            console.log('\nüìä DIAGN√ìSTICO DE PROBLEMAS:');
            console.log(`‚ùå Precios NaN: ${problems.nanPrices.length}`);
            console.log(`‚ùå Precios inv√°lidos: ${problems.invalidPrices.length}`);
            console.log(`‚ùå Datos faltantes: ${problems.missingData.length}`);
            console.log(`‚ùå Vol√∫menes cero: ${problems.zeroVolumes.length}`);
            
            if (problems.nanPrices.length > 0) {
                console.log('\nüö® S√çMBOLOS CON PRECIOS NaN:');
                problems.nanPrices.slice(0, 10).forEach(problem => {
                    console.log(`  - ${problem.symbol}: precio=${problem.currentPrice}, cambio=${problem.priceChange}, cambio%=${problem.priceChangePercent}`);
                });
            }
            
            if (problems.invalidPrices.length > 0) {
                console.log('\nüö® S√çMBOLOS CON PRECIOS INV√ÅLIDOS:');
                problems.invalidPrices.slice(0, 10).forEach(problem => {
                    console.log(`  - ${problem.symbol}: precio=${problem.currentPrice}`);
                });
            }
            
            // Verificar datos de Binance directamente
            console.log('\nüîç Verificando datos directos de Binance...');
            const binanceResponse = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
            
            if (binanceResponse.data && Array.isArray(binanceResponse.data)) {
                const binanceData = binanceResponse.data;
                console.log(`üìä Datos de Binance obtenidos: ${binanceData.length} s√≠mbolos`);
                
                // Verificar algunos s√≠mbolos problem√°ticos
                const problematicSymbols = problems.nanPrices.slice(0, 5).map(p => p.symbol);
                
                problematicSymbols.forEach(symbol => {
                    const binanceSymbol = binanceData.find(item => item.symbol === symbol);
                    if (binanceSymbol) {
                        console.log(`‚úÖ ${symbol} en Binance: precio=${binanceSymbol.lastPrice}, cambio=${binanceSymbol.priceChange}, cambio%=${binanceSymbol.priceChangePercent}%`);
                    } else {
                        console.log(`‚ùå ${symbol} NO encontrado en Binance`);
                    }
                });
            }
            
            return problems;
        }
    } catch (error) {
        console.error('‚ùå Error diagnosticando inconsistencias:', error.message);
        return null;
    }
}

// Funci√≥n para corregir inconsistencias
async function fixDataInconsistencies() {
    try {
        console.log('\nüîß Corrigiendo inconsistencias de datos...');
        
        // Obtener datos directos de Binance
        const binanceResponse = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr');
        
        if (binanceResponse.data && Array.isArray(binanceResponse.data)) {
            const binanceData = binanceResponse.data;
            
            // Crear mapa de datos v√°lidos
            const validDataMap = {};
            binanceData.forEach(item => {
                if (item.symbol.endsWith('USDT') && 
                    parseFloat(item.lastPrice) > 0 && 
                    parseFloat(item.volume) > 0) {
                    validDataMap[item.symbol] = {
                        price: parseFloat(item.lastPrice),
                        priceChange: parseFloat(item.priceChange),
                        priceChangePercent: parseFloat(item.priceChangePercent),
                        volume: parseFloat(item.volume)
                    };
                }
            });
            
            console.log(`‚úÖ Datos v√°lidos de Binance: ${Object.keys(validDataMap).length} s√≠mbolos`);
            
            // Crear script de correcci√≥n
            const correctionScript = `// SCRIPT DE CORRECCI√ìN DE INCONSISTENCIAS
// Generado autom√°ticamente: ${new Date().toISOString()}

const VALID_BINANCE_DATA = ${JSON.stringify(validDataMap, null, 2)};

// Funci√≥n para obtener datos v√°lidos
function getValidBinanceData(symbol) {
    return VALID_BINANCE_DATA[symbol] || null;
}

// Funci√≥n para validar precio
function validatePrice(price) {
    if (isNaN(price) || price <= 0 || price === null || price === undefined) {
        return false;
    }
    return true;
}

// Funci√≥n para obtener precio v√°lido
function getValidPrice(symbol, fallbackPrice = 100) {
    const validData = getValidBinanceData(symbol);
    if (validData && validatePrice(validData.price)) {
        return validData.price;
    }
    return fallbackPrice;
}

module.exports = { 
    VALID_BINANCE_DATA, 
    getValidBinanceData, 
    validatePrice, 
    getValidPrice 
};`;
            
            // Guardar script de correcci√≥n
            const fs = require('fs');
            fs.writeFileSync('data-correction.js', correctionScript);
            
            console.log('‚úÖ Script de correcci√≥n guardado: data-correction.js');
            
            // Mostrar estad√≠sticas
            const validSymbols = Object.keys(validDataMap);
            console.log(`üìä S√≠mbolos v√°lidos: ${validSymbols.length}`);
            console.log(`üìä Rango de precios: $${Math.min(...Object.values(validDataMap).map(d => d.price)).toFixed(4)} - $${Math.max(...Object.values(validDataMap).map(d => d.price)).toFixed(4)}`);
            
            return validDataMap;
        }
    } catch (error) {
        console.error('‚ùå Error corrigiendo inconsistencias:', error.message);
        return null;
    }
}

// Ejecutar diagn√≥stico y correcci√≥n
async function main() {
    console.log('üöÄ INICIANDO DIAGN√ìSTICO Y CORRECCI√ìN DE DATOS\n');
    
    const problems = await diagnoseDataInconsistencies();
    const validData = await fixDataInconsistencies();
    
    if (problems && validData) {
        console.log('\n‚úÖ DIAGN√ìSTICO COMPLETADO');
        console.log(`üìä Total problemas encontrados: ${problems.nanPrices.length + problems.invalidPrices.length + problems.missingData.length + problems.zeroVolumes.length}`);
        console.log(`üìä Datos v√°lidos disponibles: ${Object.keys(validData).length} s√≠mbolos`);
        
        if (problems.nanPrices.length > 0) {
            console.log('\n‚ö†Ô∏è RECOMENDACI√ìN: Actualizar el sistema para usar datos v√°lidos de Binance');
        }
    }
}

main();
