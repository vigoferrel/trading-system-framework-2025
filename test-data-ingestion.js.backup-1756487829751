/**
 * 🧪 TEST DATA INGESTION
 * =====================
 * 
 * Script específico para probar la data ingestion del sistema
 */

async function testDataIngestion() {
    console.log('🧪 [TEST DATA INGESTION] Iniciando prueba de data ingestion...');
    
    try {
        // 📊 1. VERIFICAR CONECTIVIDAD CON QBTC
        console.log('\n📊 [TEST] Verificando conectividad con QBTC...');
        
        const response = await fetch('http://localhost:4602/api/market-data');
        if (!response.ok) {
            throw new Error(`Error HTTP: ${response.status}`);
        }
        
        const qbtcData = await response.json();
        console.log('✅ [TEST] Conexión con QBTC establecida');
        
        // 📊 2. ANALIZAR ESTRUCTURA DE DATOS
        console.log('\n📊 [TEST] Analizando estructura de datos QBTC...');
        
        console.log('📊 Estructura general:', Object.keys(qbtcData));
        
        // 🔍 VERIFICAR SI LOS DATOS ESTÁN EN LA PROPIEDAD 'data'
        if (qbtcData.data) {
            console.log('📊 Datos encontrados en propiedad "data"');
            console.log('📊 Estructura de data:', Object.keys(qbtcData.data));
            
            if (qbtcData.data.spot) {
                const spotSymbols = Object.keys(qbtcData.data.spot);
                console.log(`📊 Símbolos SPOT disponibles: ${spotSymbols.length}`);
                console.log('📊 Primeros 10 símbolos SPOT:', spotSymbols.slice(0, 10));
            }
            
            if (qbtcData.data.futures) {
                const futuresSymbols = Object.keys(qbtcData.data.futures);
                console.log(`📊 Símbolos FUTURES disponibles: ${futuresSymbols.length}`);
                console.log('📊 Primeros 10 símbolos FUTURES:', futuresSymbols.slice(0, 10));
            }
        } else {
            // 🔍 BUSCAR DATOS DIRECTAMENTE
            if (qbtcData.spot) {
                const spotSymbols = Object.keys(qbtcData.spot);
                console.log(`📊 Símbolos SPOT disponibles: ${spotSymbols.length}`);
                console.log('📊 Primeros 10 símbolos SPOT:', spotSymbols.slice(0, 10));
            }
            
            if (qbtcData.futures) {
                const futuresSymbols = Object.keys(qbtcData.futures);
                console.log(`📊 Símbolos FUTURES disponibles: ${futuresSymbols.length}`);
                console.log('📊 Primeros 10 símbolos FUTURES:', futuresSymbols.slice(0, 10));
            }
        }
        
        // 🎯 3. VERIFICAR SÍMBOLOS PRINCIPALES
        console.log('\n🎯 [TEST] Verificando símbolos principales...');
        
        const simbolosPrincipales = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
        
        for (const symbol of simbolosPrincipales) {
            console.log(`\n🔍 Verificando ${symbol}:`);
            
            // 🔍 BUSCAR EN SPOT
            if (qbtcData.spot && qbtcData.spot[symbol]) {
                console.log(`  ✅ Encontrado en SPOT`);
                const data = qbtcData.spot[symbol];
                console.log(`  📊 Datos disponibles:`, Object.keys(data));
                console.log(`  💰 Precio: ${data.price || 'N/A'}`);
                console.log(`  📊 Volumen: ${data.volume || 'N/A'}`);
                console.log(`  💸 Funding: ${data.funding_rate || 'N/A'}`);
                console.log(`  📈 Volatilidad: ${data.volatility || 'N/A'}`);
            } else {
                console.log(`  ❌ No encontrado en SPOT`);
            }
            
            // 🔍 BUSCAR EN FUTURES
            if (qbtcData.futures && qbtcData.futures[symbol]) {
                console.log(`  ✅ Encontrado en FUTURES`);
                const data = qbtcData.futures[symbol];
                console.log(`  📊 Datos disponibles:`, Object.keys(data));
                console.log(`  💰 Precio: ${data.price || 'N/A'}`);
                console.log(`  📊 Volumen: ${data.volume || 'N/A'}`);
                console.log(`  💸 Funding: ${data.funding_rate || 'N/A'}`);
                console.log(`  📈 Volatilidad: ${data.volatility || 'N/A'}`);
            } else {
                console.log(`  ❌ No encontrado en FUTURES`);
            }
            
            // 🔍 BUSCAR VARIACIONES
            const variaciones = buscarVariacionesSimbolo(qbtcData, symbol);
            if (variaciones.length > 0) {
                console.log(`  🔍 Variaciones encontradas:`, variaciones);
            }
        }
        
        // 📊 4. ANALIZAR MUESTRA DE DATOS
        console.log('\n📊 [TEST] Analizando muestra de datos...');
        
        if (qbtcData.spot) {
            const primerSymbol = Object.keys(qbtcData.spot)[0];
            if (primerSymbol) {
                console.log(`📊 Muestra de datos para ${primerSymbol}:`);
                const muestra = qbtcData.spot[primerSymbol];
                console.log(JSON.stringify(muestra, null, 2));
            }
        }
        
        // 🧠 5. PROBAR NÚCLEO PSICOLÓGICO CON DATOS REALES
        console.log('\n🧠 [TEST] Probando núcleo psicológico con datos reales...');
        
        const { NucleoPsicologicoTasasCambio } = require('./nucleo-psicologico-tasas-cambio.js');
        const nucleoPsicologico = new NucleoPsicologicoTasasCambio();
        
        // 🎯 BUSCAR UN SÍMBOLO CON DATOS COMPLETOS
        let symbolConDatos = null;
        let datosCompletos = null;
        
        if (qbtcData.spot) {
            for (const symbol of Object.keys(qbtcData.spot)) {
                const data = qbtcData.spot[symbol];
                if (data.price && data.volume) {
                    symbolConDatos = symbol;
                    datosCompletos = data;
                    break;
                }
            }
        }
        
        if (symbolConDatos && datosCompletos) {
            console.log(`🧠 Probando análisis psicológico con ${symbolConDatos}...`);
            
            const estadoPsicologico = await nucleoPsicologico.analizarEstadoPsicologico(
                symbolConDatos,
                datosCompletos.price,
                datosCompletos
            );
            
            console.log('✅ Análisis psicológico completado:');
            console.log(`  🧠 Estado: ${estadoPsicologico.estado_psicologico.emocion}`);
            console.log(`  📊 Puntuación: ${estadoPsicologico.estado_psicologico.puntuacion.toFixed(3)}`);
            console.log(`  📈 Tasas cambio: ${estadoPsicologico.tasas_cambio.puntuacion_global.toFixed(3)}`);
            console.log(`  ⚛️ Quantum enhancement: ${estadoPsicologico.quantum_enhanced.quantum_enhancement.toFixed(3)}`);
        } else {
            console.log('⚠️ No se encontró ningún símbolo con datos completos para probar');
        }
        
        console.log('\n🎉 [TEST DATA INGESTION] Prueba completada exitosamente!');
        
    } catch (error) {
        console.error('❌ [TEST DATA INGESTION] Error:', error.message);
        console.error('Stack trace:', error.stack);
    }
}

// 🛠️ FUNCIÓN AUXILIAR PARA BUSCAR VARIACIONES
function buscarVariacionesSimbolo(qbtcData, symbol) {
    const variaciones = [];
    
    // 🔍 BUSCAR EN SPOT
    if (qbtcData.spot) {
        const spotSymbols = Object.keys(qbtcData.spot);
        const matches = spotSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
        variaciones.push(...matches);
    }
    
    // 🔍 BUSCAR EN FUTURES
    if (qbtcData.futures) {
        const futuresSymbols = Object.keys(qbtcData.futures);
        const matches = futuresSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
        variaciones.push(...matches);
    }
    
    return variaciones;
}

// 🚀 EJECUTAR PRUEBA
testDataIngestion();
