/**
 * ðŸ§ª TEST DATA INGESTION
 * =====================
 * 
 * Script especÃ­fico para probar la data ingestion del sistema
 */

async function testDataIngestion() {
    console.log('ðŸ§ª [TEST DATA INGESTION] Iniciando prueba de data ingestion...');
    
    try {
        // ðŸ“Š 1. VERIFICAR CONECTIVIDAD CON QBTC
        console.log('\nðŸ“Š [TEST] Verificando conectividad con QBTC...');
        
        const response = await fetch('http://localhost:4602/api/market-data');
        if (!response.ok) {
            throw new Error(`Error HTTP: ${response.status}`);
        }
        
        const qbtcData = await response.json();
        console.log('âœ… [TEST] ConexiÃ³n con QBTC establecida');
        
        // ðŸ“Š 2. ANALIZAR ESTRUCTURA DE DATOS
        console.log('\nðŸ“Š [TEST] Analizando estructura de datos QBTC...');
        
        console.log('ðŸ“Š Estructura general:', Object.keys(qbtcData));
        
        // ðŸ” VERIFICAR SI LOS DATOS ESTÃN EN LA PROPIEDAD 'data'
        if (qbtcData.data) {
            console.log('ðŸ“Š Datos encontrados en propiedad "data"');
            console.log('ðŸ“Š Estructura de data:', Object.keys(qbtcData.data));
            
            if (qbtcData.data.spot) {
                const spotSymbols = Object.keys(qbtcData.data.spot);
                console.log(`ðŸ“Š SÃ­mbolos SPOT disponibles: ${spotSymbols.length}`);
                console.log('ðŸ“Š Primeros 10 sÃ­mbolos SPOT:', spotSymbols.slice(0, 10));
            }
            
            if (qbtcData.data.futures) {
                const futuresSymbols = Object.keys(qbtcData.data.futures);
                console.log(`ðŸ“Š SÃ­mbolos FUTURES disponibles: ${futuresSymbols.length}`);
                console.log('ðŸ“Š Primeros 10 sÃ­mbolos FUTURES:', futuresSymbols.slice(0, 10));
            }
        } else {
            // ðŸ” BUSCAR DATOS DIRECTAMENTE
            if (qbtcData.spot) {
                const spotSymbols = Object.keys(qbtcData.spot);
                console.log(`ðŸ“Š SÃ­mbolos SPOT disponibles: ${spotSymbols.length}`);
                console.log('ðŸ“Š Primeros 10 sÃ­mbolos SPOT:', spotSymbols.slice(0, 10));
            }
            
            if (qbtcData.futures) {
                const futuresSymbols = Object.keys(qbtcData.futures);
                console.log(`ðŸ“Š SÃ­mbolos FUTURES disponibles: ${futuresSymbols.length}`);
                console.log('ðŸ“Š Primeros 10 sÃ­mbolos FUTURES:', futuresSymbols.slice(0, 10));
            }
        }
        
        // ðŸŽ¯ 3. VERIFICAR SÃMBOLOS PRINCIPALES
        console.log('\nðŸŽ¯ [TEST] Verificando sÃ­mbolos principales...');
        
        const simbolosPrincipales = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
        
        for (const symbol of simbolosPrincipales) {
            console.log(`\nðŸ” Verificando ${symbol}:`);
            
            // ðŸ” BUSCAR EN SPOT
            if (qbtcData.spot && qbtcData.spot[symbol]) {
                console.log(`  âœ… Encontrado en SPOT`);
                const data = qbtcData.spot[symbol];
                console.log(`  ðŸ“Š Datos disponibles:`, Object.keys(data));
                console.log(`  ðŸ’° Precio: ${data.price || 'N/A'}`);
                console.log(`  ðŸ“Š Volumen: ${data.volume || 'N/A'}`);
                console.log(`  ðŸ’¸ Funding: ${data.funding_rate || 'N/A'}`);
                console.log(`  ðŸ“ˆ Volatilidad: ${data.volatility || 'N/A'}`);
            } else {
                console.log(`  âŒ No encontrado en SPOT`);
            }
            
            // ðŸ” BUSCAR EN FUTURES
            if (qbtcData.futures && qbtcData.futures[symbol]) {
                console.log(`  âœ… Encontrado en FUTURES`);
                const data = qbtcData.futures[symbol];
                console.log(`  ðŸ“Š Datos disponibles:`, Object.keys(data));
                console.log(`  ðŸ’° Precio: ${data.price || 'N/A'}`);
                console.log(`  ðŸ“Š Volumen: ${data.volume || 'N/A'}`);
                console.log(`  ðŸ’¸ Funding: ${data.funding_rate || 'N/A'}`);
                console.log(`  ðŸ“ˆ Volatilidad: ${data.volatility || 'N/A'}`);
            } else {
                console.log(`  âŒ No encontrado en FUTURES`);
            }
            
            // ðŸ” BUSCAR VARIACIONES
            const variaciones = buscarVariacionesSimbolo(qbtcData, symbol);
            if (variaciones.length > 0) {
                console.log(`  ðŸ” Variaciones encontradas:`, variaciones);
            }
        }
        
        // ðŸ“Š 4. ANALIZAR MUESTRA DE DATOS
        console.log('\nðŸ“Š [TEST] Analizando muestra de datos...');
        
        if (qbtcData.spot) {
            const primerSymbol = Object.keys(qbtcData.spot)[0];
            if (primerSymbol) {
                console.log(`ðŸ“Š Muestra de datos para ${primerSymbol}:`);
                const muestra = qbtcData.spot[primerSymbol];
                console.log(JSON.stringify(muestra, null, 2));
            }
        }
        
        // ðŸ§  5. PROBAR NÃšCLEO PSICOLÃ“GICO CON DATOS REALES
        console.log('\nðŸ§  [TEST] Probando nÃºcleo psicolÃ³gico con datos reales...');
        
        const { NucleoPsicologicoTasasCambio } = require('./nucleo-psicologico-tasas-cambio.js');
        const nucleoPsicologico = new NucleoPsicologicoTasasCambio();
        
        // ðŸŽ¯ BUSCAR UN SÃMBOLO CON DATOS COMPLETOS
        let symbolConDatos = null;
        let datosCompletos = null;
        
        if (qbtcData.spot) {
            for (const symbol of Object.keys(qbtcData.spot)) {
                const data = qbtcData.spot[symbol];
                if (data.price && data.volume) {
                    symbolConDatos = symbol;
                    datosCompletos = data;
                    break;
                }
            }
        }
        
        if (symbolConDatos && datosCompletos) {
            console.log(`ðŸ§  Probando anÃ¡lisis psicolÃ³gico con ${symbolConDatos}...`);
            
            const estadoPsicologico = await nucleoPsicologico.analizarEstadoPsicologico(
                symbolConDatos,
                datosCompletos.price,
                datosCompletos
            );
            
            console.log('âœ… AnÃ¡lisis psicolÃ³gico completado:');
            console.log(`  ðŸ§  Estado: ${estadoPsicologico.estado_psicologico.emocion}`);
            console.log(`  ðŸ“Š PuntuaciÃ³n: ${estadoPsicologico.estado_psicologico.puntuacion.toFixed(3)}`);
            console.log(`  ðŸ“ˆ Tasas cambio: ${estadoPsicologico.tasas_cambio.puntuacion_global.toFixed(3)}`);
            console.log(`  âš›ï¸ Quantum enhancement: ${estadoPsicologico.quantum_enhanced.quantum_enhancement.toFixed(3)}`);
        } else {
            console.log('âš ï¸ No se encontrÃ³ ningÃºn sÃ­mbolo con datos completos para probar');
        }
        
        console.log('\nðŸŽ‰ [TEST DATA INGESTION] Prueba completada exitosamente!');
        
    } catch (error) {
        console.error('âŒ [TEST DATA INGESTION] Error:', error.message);
        console.error('Stack trace:', error.stack);
    }
}

// ðŸ› ï¸ FUNCIÃ“N AUXILIAR PARA BUSCAR VARIACIONES
function buscarVariacionesSimbolo(qbtcData, symbol) {
    const variaciones = [];
    
    // ðŸ” BUSCAR EN SPOT
    if (qbtcData.spot) {
        const spotSymbols = Object.keys(qbtcData.spot);
        const matches = spotSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
        variaciones.push(...matches);
    }
    
    // ðŸ” BUSCAR EN FUTURES
    if (qbtcData.futures) {
        const futuresSymbols = Object.keys(qbtcData.futures);
        const matches = futuresSymbols.filter(s => s.includes(symbol.replace('USDT', '')));
        variaciones.push(...matches);
    }
    
    return variaciones;
}

// ðŸš€ EJECUTAR PRUEBA
testDataIngestion();
