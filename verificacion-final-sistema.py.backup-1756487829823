#!/usr/bin/env python3
"""
VERIFICACIÃ“N FINAL - SISTEMA QBTC BANDA 46
Script final para confirmar que el sistema estÃ¡ completamente libre de simulaciones
"""

import requests
import json
import time
import re
from datetime import datetime

def print_banner():
    """Imprime el banner del sistema."""
    print("=" * 80)
    print("ğŸ¯ VERIFICACIÃ“N FINAL - SISTEMA QBTC BANDA 46")
    print("=" * 80)
    print(f"ğŸ“… Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("ğŸ¯ Objetivo: Confirmar sistema 100% libre de simulaciones")
    print("ğŸ” VerificaciÃ³n exhaustiva y precisa")
    print("=" * 80)

def check_qbtc_core_real_data():
    """Verifica que QBTC Core proporcione datos reales de Binance."""
    print("\nğŸ” VERIFICACIÃ“N 1: QBTC CORE - DATOS REALES DE BINANCE")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                print(f"âœ… QBTC Core respondiendo correctamente")
                print(f"ğŸ“Š Cantidad de sÃ­mbolos: {len(futures_data)}")
                
                # Verificar que los datos sean reales
                real_symbols = 0
                simulated_symbols = 0
                
                for item in futures_data[:10]:  # Revisar primeros 10
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    # Verificar que sean sÃ­mbolos reales de Binance
                    if symbol and last_price and price_change:
                        if re.match(r'^[A-Z0-9]+USDT$', symbol):
                            real_symbols += 1
                            print(f"âœ… SÃ­mbolo real: {symbol} - Precio: {last_price}")
                        else:
                            simulated_symbols += 1
                            print(f"âš ï¸ SÃ­mbolo sospechoso: {symbol}")
                
                print(f"\nğŸ“ˆ RESULTADO QBTC CORE:")
                print(f"âœ… SÃ­mbolos reales: {real_symbols}")
                print(f"âš ï¸ SÃ­mbolos sospechosos: {simulated_symbols}")
                
                if real_symbols > 0 and simulated_symbols == 0:
                    print("ğŸ‰ QBTC Core: DATOS REALES CONFIRMADOS")
                    return True
                else:
                    print("âŒ QBTC Core: POSIBLES SIMULACIONES DETECTADAS")
                    return False
            else:
                print("âŒ QBTC Core: Respuesta invÃ¡lida")
                return False
        else:
            print(f"âŒ QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"âŒ QBTC Core: Error de conexiÃ³n - {e}")
        return False

def check_dashboard_no_simulations():
    """Verifica que el Dashboard no contenga simulaciones."""
    print("\nğŸ” VERIFICACIÃ“N 2: DASHBOARD QBTC - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4605/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si estÃ¡ en contexto de simulaciÃ³n
            if "test" in content:
                # Buscar contexto de simulaciÃ³n alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("âœ… Dashboard QBTC: Sin simulaciones detectadas")
                return True
            else:
                print(f"âŒ Dashboard QBTC: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"âŒ Dashboard QBTC: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"âŒ Dashboard QBTC: Error de conexiÃ³n - {e}")
        return False

def check_monitor_no_simulations():
    """Verifica que el Monitor de GrÃ¡ficos no contenga simulaciones."""
    print("\nğŸ” VERIFICACIÃ“N 3: MONITOR DE GRÃFICOS - SIN SIMULACIONES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4606/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones (excluyendo palabras en contexto normal)
            simulation_keywords = ["simulation", "simulated", "fake", "mock"]
            found_keywords = []
            
            for keyword in simulation_keywords:
                if keyword in content:
                    found_keywords.append(keyword)
            
            # Verificar "test" solo si estÃ¡ en contexto de simulaciÃ³n
            if "test" in content:
                # Buscar contexto de simulaciÃ³n alrededor de "test"
                test_context = re.findall(r'[a-zA-Z]*test[a-zA-Z]*', content)
                simulation_test = any(word in test_context for word in ["simulationtest", "testdata", "testmock", "faketest"])
                if simulation_test:
                    found_keywords.append("test")
            
            if not found_keywords:
                print("âœ… Monitor de GrÃ¡ficos: Sin simulaciones detectadas")
                return True
            else:
                print(f"âŒ Monitor de GrÃ¡ficos: Simulaciones detectadas: {found_keywords}")
                return False
        else:
            print(f"âŒ Monitor de GrÃ¡ficos: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"âŒ Monitor de GrÃ¡ficos: Error de conexiÃ³n - {e}")
        return False

def check_all_apis_functional():
    """Verifica que todas las APIs funcionen correctamente."""
    print("\nğŸ” VERIFICACIÃ“N 4: TODAS LAS APIS - FUNCIONALIDAD")
    print("-" * 60)
    
    apis = [
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health")
    ]
    
    working_apis = 0
    total_apis = len(apis)
    
    for name, url in apis:
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                print(f"âœ… {name}: Funcionando correctamente")
                working_apis += 1
            else:
                print(f"âŒ {name}: Error HTTP {response.status_code}")
                
        except Exception as e:
            print(f"âŒ {name}: Error de conexiÃ³n - {e}")
    
    print(f"\nğŸ“Š RESULTADO APIS:")
    print(f"âœ… APIs funcionando: {working_apis}/{total_apis}")
    
    if working_apis == total_apis:
        print("ğŸ‰ Todas las APIs funcionando correctamente")
        return True
    else:
        print("âš ï¸ Algunas APIs no estÃ¡n funcionando")
        return False

def check_data_consistency_real():
    """Verifica consistencia de datos reales."""
    print("\nğŸ” VERIFICACIÃ“N 5: CONSISTENCIA DE DATOS REALES")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                # Verificar que los datos sean consistentes
                valid_data = 0
                invalid_data = 0
                
                for item in futures_data[:5]:  # Revisar primeros 5
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    if symbol and last_price and price_change:
                        try:
                            price_float = float(last_price)
                            change_float = float(price_change)
                            
                            if price_float > 0 and isinstance(change_float, (int, float)):
                                valid_data += 1
                                print(f"âœ… Datos vÃ¡lidos: {symbol} - {last_price}")
                            else:
                                invalid_data += 1
                                print(f"âš ï¸ Datos invÃ¡lidos: {symbol}")
                        except ValueError:
                            invalid_data += 1
                            print(f"âš ï¸ Datos no numÃ©ricos: {symbol}")
                    else:
                        invalid_data += 1
                        print(f"âš ï¸ Datos incompletos: {symbol}")
                
                print(f"\nğŸ“Š CONSISTENCIA DE DATOS:")
                print(f"âœ… Datos vÃ¡lidos: {valid_data}")
                print(f"âš ï¸ Datos invÃ¡lidos: {invalid_data}")
                
                if valid_data > 0 and invalid_data == 0:
                    print("ğŸ‰ Consistencia de datos: EXCELENTE")
                    return True
                elif valid_data > 0:
                    print("âš ï¸ Consistencia de datos: PARCIAL")
                    return True
                else:
                    print("âŒ Consistencia de datos: DEFICIENTE")
                    return False
            else:
                print("âŒ QBTC Core: Respuesta invÃ¡lida")
                return False
        else:
            print(f"âŒ QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"âŒ Error verificando consistencia: {e}")
        return False

def check_system_performance_final():
    """Verifica el rendimiento final del sistema."""
    print("\nğŸ” VERIFICACIÃ“N 6: RENDIMIENTO FINAL DEL SISTEMA")
    print("-" * 60)
    
    services = [
        ("QBTC Core", "http://localhost:4602/api/futures-data"),
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health"),
        ("Dashboard QBTC", "http://localhost:4605/"),
        ("Monitor de GrÃ¡ficos", "http://localhost:4606/")
    ]
    
    total_time = 0
    successful_requests = 0
    
    for name, url in services:
        try:
            start_time = time.time()
            response = requests.get(url, timeout=5)
            end_time = time.time()
            
            response_time = (end_time - start_time) * 1000  # en milisegundos
            
            if response.status_code == 200:
                print(f"âœ… {name}: {response_time:.2f}ms")
                total_time += response_time
                successful_requests += 1
            else:
                print(f"âŒ {name}: Error {response.status_code}")
                
        except Exception as e:
            print(f"âŒ {name}: Error - {e}")
    
    if successful_requests > 0:
        avg_time = total_time / successful_requests
        print(f"\nğŸ“Š RENDIMIENTO FINAL:")
        print(f"âœ… Requests exitosos: {successful_requests}/{len(services)}")
        print(f"â±ï¸ Tiempo promedio: {avg_time:.2f}ms")
        
        if avg_time < 1000:  # menos de 1 segundo
            print("ğŸ‰ Rendimiento: EXCELENTE")
            return True
        elif avg_time < 3000:  # menos de 3 segundos
            print("âœ… Rendimiento: BUENO")
            return True
        else:
            print("âš ï¸ Rendimiento: LENTO")
            return False
    else:
        print("âŒ Rendimiento: NO FUNCIONAL")
        return False

def main():
    """FunciÃ³n principal."""
    print_banner()
    
    tests = [
        ("QBTC Core - Datos Reales", check_qbtc_core_real_data),
        ("Dashboard QBTC - Sin Simulaciones", check_dashboard_no_simulations),
        ("Monitor de GrÃ¡ficos - Sin Simulaciones", check_monitor_no_simulations),
        ("Todas las APIs - Funcionalidad", check_all_apis_functional),
        ("Consistencia de Datos Reales", check_data_consistency_real),
        ("Rendimiento Final del Sistema", check_system_performance_final)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"âŒ Error en {test_name}: {e}")
            results.append((test_name, False))
    
    # Resumen final
    print("\n" + "=" * 80)
    print("ğŸ¯ VERIFICACIÃ“N FINAL COMPLETADA")
    print("=" * 80)
    
    passed_tests = sum(1 for _, result in results if result)
    total_tests = len(results)
    
    print(f"\nâœ… Pruebas exitosas: {passed_tests}/{total_tests}")
    
    for test_name, result in results:
        status = "âœ… PASÃ“" if result else "âŒ FALLÃ“"
        print(f"{status} - {test_name}")
    
    print(f"\nğŸ¯ RESULTADO FINAL:")
    if passed_tests == total_tests:
        print("ğŸ‰ Â¡SISTEMA 100% LIBRE DE SIMULACIONES!")
        print("ğŸš€ Todos los servicios funcionan con datos reales")
        print("âœ… Sistema completamente operativo y listo para producciÃ³n")
        print("ğŸ”’ VerificaciÃ³n de integridad: EXITOSA")
    elif passed_tests >= total_tests * 0.8:
        print("âœ… SISTEMA MAYORMENTE FUNCIONAL")
        print("âš ï¸ Algunas verificaciones fallaron, pero el sistema es usable")
        print("ğŸ”§ Se recomienda revisar los puntos fallidos")
    else:
        print("âŒ SISTEMA CON PROBLEMAS")
        print("ğŸ”§ Se requieren correcciones antes del uso")
    
    print("\n" + "=" * 80)

if __name__ == "__main__":
    main()
