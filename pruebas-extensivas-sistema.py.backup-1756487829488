#!/usr/bin/env python3
"""
PRUEBAS EXTENSIVAS - SISTEMA QBTC BANDA 46
Script para verificar que el sistema funciona sin simulaciones y con datos reales
"""

import requests
import json
import time
import re
from datetime import datetime

def print_banner():
    """Imprime el banner del sistema."""
    print("=" * 80)
    print("üî¨ PRUEBAS EXTENSIVAS - SISTEMA QBTC BANDA 46")
    print("=" * 80)
    print(f"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("üéØ Objetivo: Verificar datos reales sin simulaciones")
    print("üîç An√°lisis profundo del sistema")
    print("=" * 80)

def check_qbtc_core_data():
    """Verifica que QBTC Core proporcione datos reales de Binance."""
    print("\nüîç PRUEBA 1: QBTC CORE - DATOS REALES DE BINANCE")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get("success") and data.get("data"):
                futures_data = data["data"]
                
                print(f"‚úÖ QBTC Core respondiendo correctamente")
                print(f"üìä Cantidad de s√≠mbolos: {len(futures_data)}")
                
                # Verificar que los datos sean reales
                real_symbols = 0
                simulated_symbols = 0
                
                for item in futures_data[:10]:  # Revisar primeros 10
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    # Verificar que sean s√≠mbolos reales de Binance
                    if symbol and last_price and price_change:
                        if re.match(r'^[A-Z0-9]+USDT$', symbol):
                            real_symbols += 1
                            print(f"‚úÖ S√≠mbolo real: {symbol} - Precio: {last_price}")
                        else:
                            simulated_symbols += 1
                            print(f"‚ö†Ô∏è S√≠mbolo sospechoso: {symbol}")
                
                print(f"\nüìà RESULTADO QBTC CORE:")
                print(f"‚úÖ S√≠mbolos reales: {real_symbols}")
                print(f"‚ö†Ô∏è S√≠mbolos sospechosos: {simulated_symbols}")
                
                if real_symbols > 0 and simulated_symbols == 0:
                    print("üéâ QBTC Core: DATOS REALES CONFIRMADOS")
                    return True
                else:
                    print("‚ùå QBTC Core: POSIBLES SIMULACIONES DETECTADAS")
                    return False
            else:
                print("‚ùå QBTC Core: Respuesta inv√°lida")
                return False
        else:
            print(f"‚ùå QBTC Core: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå QBTC Core: Error de conexi√≥n - {e}")
        return False

def check_srona_api_data():
    """Verifica que SRONA API funcione correctamente."""
    print("\nüîç PRUEBA 2: SRONA API - FUNCIONALIDAD")
    print("-" * 60)
    
    try:
        # Verificar health check
        health_response = requests.get("http://localhost:4601/health", timeout=5)
        
        if health_response.status_code == 200:
            health_data = health_response.json()
            print(f"‚úÖ Health check: {health_data}")
            
            # Verificar que no contenga simulaciones
            health_text = json.dumps(health_data).lower()
            simulation_keywords = ["simulation", "simulated", "fake", "mock", "test"]
            
            has_simulation = any(keyword in health_text for keyword in simulation_keywords)
            
            if not has_simulation:
                print("‚úÖ SRONA API: Sin simulaciones detectadas")
                return True
            else:
                print("‚ùå SRONA API: Simulaciones detectadas")
                return False
        else:
            print(f"‚ùå SRONA API: Error HTTP {health_response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå SRONA API: Error de conexi√≥n - {e}")
        return False

def check_frontend_api():
    """Verifica que Frontend API funcione correctamente."""
    print("\nüîç PRUEBA 3: FRONTEND API - FUNCIONALIDAD")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4603/health", timeout=5)
        
        if response.status_code == 200:
            print("‚úÖ Frontend API: Funcionando correctamente")
            return True
        else:
            print(f"‚ùå Frontend API: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Frontend API: Error de conexi√≥n - {e}")
        return False

def check_vigo_futures():
    """Verifica que Vigo Futures funcione correctamente."""
    print("\nüîç PRUEBA 4: VIGO FUTURES - FUNCIONALIDAD")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4604/health", timeout=5)
        
        if response.status_code == 200:
            print("‚úÖ Vigo Futures: Funcionando correctamente")
            return True
        else:
            print(f"‚ùå Vigo Futures: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Vigo Futures: Error de conexi√≥n - {e}")
        return False

def check_dashboard():
    """Verifica que Dashboard funcione correctamente."""
    print("\nüîç PRUEBA 5: DASHBOARD QBTC - FUNCIONALIDAD")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4605/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones
            simulation_keywords = ["simulation", "simulated", "fake", "mock", "test"]
            has_simulation = any(keyword in content for keyword in simulation_keywords)
            
            if not has_simulation:
                print("‚úÖ Dashboard QBTC: Funcionando sin simulaciones")
                return True
            else:
                print("‚ùå Dashboard QBTC: Simulaciones detectadas")
                return False
        else:
            print(f"‚ùå Dashboard QBTC: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Dashboard QBTC: Error de conexi√≥n - {e}")
        return False

def check_monitor_graficos():
    """Verifica que Monitor de Gr√°ficos funcione correctamente."""
    print("\nüîç PRUEBA 6: MONITOR DE GR√ÅFICOS - FUNCIONALIDAD")
    print("-" * 60)
    
    try:
        response = requests.get("http://localhost:4606/", timeout=5)
        
        if response.status_code == 200:
            content = response.text.lower()
            
            # Verificar que no contenga simulaciones
            simulation_keywords = ["simulation", "simulated", "fake", "mock", "test"]
            has_simulation = any(keyword in content for keyword in simulation_keywords)
            
            if not has_simulation:
                print("‚úÖ Monitor de Gr√°ficos: Funcionando sin simulaciones")
                return True
            else:
                print("‚ùå Monitor de Gr√°ficos: Simulaciones detectadas")
                return False
        else:
            print(f"‚ùå Monitor de Gr√°ficos: Error HTTP {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Monitor de Gr√°ficos: Error de conexi√≥n - {e}")
        return False

def check_data_consistency():
    """Verifica consistencia de datos entre servicios."""
    print("\nüîç PRUEBA 7: CONSISTENCIA DE DATOS")
    print("-" * 60)
    
    try:
        # Obtener datos de QBTC Core
        qbtc_response = requests.get("http://localhost:4602/api/futures-data", timeout=10)
        
        if qbtc_response.status_code == 200:
            qbtc_data = qbtc_response.json()
            
            if qbtc_data.get("success") and qbtc_data.get("data"):
                futures_data = qbtc_data["data"]
                
                # Verificar que los datos sean consistentes
                valid_data = 0
                invalid_data = 0
                
                for item in futures_data[:5]:  # Revisar primeros 5
                    symbol = item.get("symbol", "")
                    last_price = item.get("lastPrice", "")
                    price_change = item.get("priceChange", "")
                    
                    if symbol and last_price and price_change:
                        try:
                            price_float = float(last_price)
                            change_float = float(price_change)
                            
                            if price_float > 0 and isinstance(change_float, (int, float)):
                                valid_data += 1
                                print(f"‚úÖ Datos v√°lidos: {symbol} - {last_price}")
                            else:
                                invalid_data += 1
                                print(f"‚ö†Ô∏è Datos inv√°lidos: {symbol}")
                        except ValueError:
                            invalid_data += 1
                            print(f"‚ö†Ô∏è Datos no num√©ricos: {symbol}")
                    else:
                        invalid_data += 1
                        print(f"‚ö†Ô∏è Datos incompletos: {symbol}")
                
                print(f"\nüìä CONSISTENCIA DE DATOS:")
                print(f"‚úÖ Datos v√°lidos: {valid_data}")
                print(f"‚ö†Ô∏è Datos inv√°lidos: {invalid_data}")
                
                if valid_data > 0 and invalid_data == 0:
                    print("üéâ Consistencia de datos: EXCELENTE")
                    return True
                elif valid_data > 0:
                    print("‚ö†Ô∏è Consistencia de datos: PARCIAL")
                    return True
                else:
                    print("‚ùå Consistencia de datos: DEFICIENTE")
                    return False
            else:
                print("‚ùå QBTC Core: Respuesta inv√°lida")
                return False
        else:
            print(f"‚ùå QBTC Core: Error HTTP {qbtc_response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error verificando consistencia: {e}")
        return False

def check_system_performance():
    """Verifica el rendimiento del sistema."""
    print("\nüîç PRUEBA 8: RENDIMIENTO DEL SISTEMA")
    print("-" * 60)
    
    services = [
        ("QBTC Core", "http://localhost:4602/api/futures-data"),
        ("SRONA API", "http://localhost:4601/health"),
        ("Frontend API", "http://localhost:4603/health"),
        ("Vigo Futures", "http://localhost:4604/health")
    ]
    
    total_time = 0
    successful_requests = 0
    
    for name, url in services:
        try:
            start_time = time.time()
            response = requests.get(url, timeout=5)
            end_time = time.time()
            
            response_time = (end_time - start_time) * 1000  # en milisegundos
            
            if response.status_code == 200:
                print(f"‚úÖ {name}: {response_time:.2f}ms")
                total_time += response_time
                successful_requests += 1
            else:
                print(f"‚ùå {name}: Error {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå {name}: Error - {e}")
    
    if successful_requests > 0:
        avg_time = total_time / successful_requests
        print(f"\nüìä RENDIMIENTO:")
        print(f"‚úÖ Requests exitosos: {successful_requests}/{len(services)}")
        print(f"‚è±Ô∏è Tiempo promedio: {avg_time:.2f}ms")
        
        if avg_time < 1000:  # menos de 1 segundo
            print("üéâ Rendimiento: EXCELENTE")
            return True
        elif avg_time < 3000:  # menos de 3 segundos
            print("‚úÖ Rendimiento: BUENO")
            return True
        else:
            print("‚ö†Ô∏è Rendimiento: LENTO")
            return False
    else:
        print("‚ùå Rendimiento: NO FUNCIONAL")
        return False

def main():
    """Funci√≥n principal."""
    print_banner()
    
    tests = [
        ("QBTC Core - Datos Reales", check_qbtc_core_data),
        ("SRONA API - Funcionalidad", check_srona_api_data),
        ("Frontend API - Funcionalidad", check_frontend_api),
        ("Vigo Futures - Funcionalidad", check_vigo_futures),
        ("Dashboard QBTC - Funcionalidad", check_dashboard),
        ("Monitor de Gr√°ficos - Funcionalidad", check_monitor_graficos),
        ("Consistencia de Datos", check_data_consistency),
        ("Rendimiento del Sistema", check_system_performance)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"‚ùå Error en {test_name}: {e}")
            results.append((test_name, False))
    
    # Resumen final
    print("\n" + "=" * 80)
    print("üìä RESUMEN FINAL DE PRUEBAS EXTENSIVAS")
    print("=" * 80)
    
    passed_tests = sum(1 for _, result in results if result)
    total_tests = len(results)
    
    print(f"\n‚úÖ Pruebas exitosas: {passed_tests}/{total_tests}")
    
    for test_name, result in results:
        status = "‚úÖ PAS√ì" if result else "‚ùå FALL√ì"
        print(f"{status} - {test_name}")
    
    print(f"\nüéØ RESULTADO FINAL:")
    if passed_tests == total_tests:
        print("üéâ ¬°SISTEMA COMPLETAMENTE FUNCIONAL SIN SIMULACIONES!")
        print("üöÄ Todos los servicios funcionan con datos reales")
        print("‚úÖ Sistema listo para uso en producci√≥n")
    elif passed_tests >= total_tests * 0.8:
        print("‚úÖ SISTEMA MAYORMENTE FUNCIONAL")
        print("‚ö†Ô∏è Algunas pruebas fallaron, pero el sistema es usable")
    else:
        print("‚ùå SISTEMA CON PROBLEMAS")
        print("üîß Se requieren correcciones antes del uso")
    
    print("\n" + "=" * 80)

if __name__ == "__main__":
    main()
