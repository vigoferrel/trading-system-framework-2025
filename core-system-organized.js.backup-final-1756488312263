const express = require('express');
const cors = require('cors');
const axios = require('axios');

const app = express();
const PORT = 4602;

app.use(cors());
app.use(express.json());
app.use(express.static(__dirname));

// CACHE CUÁNTICA AVANZADA
const organizedCache = {
    futures: {
        ticker: {},
        lastUpdate: Date.now(),
        quantumState: 'SUPERPOSITION',
        metrics: {
            hits: 0,
            misses: 0,
            totalRequests: 0,
            lastBinanceCall: 0,
            rateLimitCount: 0
        }
    },
    spot: {
        ticker: {},
        lastUpdate: Date.now(),
        quantumState: 'SUPERPOSITION',
        metrics: {
            hits: 0,
            misses: 0,
            totalRequests: 0,
            lastBinanceCall: 0,
            rateLimitCount: 0
        }
    },
    options: {
        ticker: {},
        lastUpdate: Date.now(),
        quantumState: 'SUPERPOSITION',
        metrics: {
            hits: 0,
            misses: 0,
            totalRequests: 0,
            lastBinanceCall: 0,
            rateLimitCount: 0
        }
    }
};

// Función helper para precios dinámicos - DETERMINÍSTICA
function getDynamicPrice(symbol) {
    const priceMap = {
        'BTCUSDT': 45000, 'ETHUSDT': 2800, 'BNBUSDT': 320, 'SOLUSDT': 95, 'ADAUSDT': 0.45, 'XRPUSDT': 0.52
    };
    
    if (priceMap[symbol]) {
        return priceMap[symbol];
    }
    
    const hash = symbol.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
    return 0.1 + (hash % 100) / 10;
}

// Función helper para spin dinámico - DETERMINÍSTICA
function getDynamicSpin(symbol) {
    const spinMap = {
        'BTCUSDT': 0.8, 'ETHUSDT': 0.6, 'BNBUSDT': 0.7, 'SOLUSDT': 0.9, 'ADAUSDT': 0.5, 'XRPUSDT': 0.4
    };
    
    if (spinMap[symbol]) {
        return spinMap[symbol];
    }
    
    const hash = symbol.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
    return 0.1 + (hash % 90) / 100;
}

// API Binance Real con protección avanzada
const binanceAPIReal = {
    async futuresTicker24hr() {
        try {
            await new Promise(resolve => setTimeout(resolve, 2000));
            const response = await axios.get('https://fapi.binance.com/fapi/v1/ticker/24hr', {
                timeout: 20000,
                headers: {
                    'User-Agent': 'QBTC-System/1.0',
                    'Accept': 'application/json'
                }
            });
            return response.data;
        } catch (error) {
            console.error('Error en futuresTicker24hr:', error.message);
            return [];
        }
    },
    
    async getMultipleTickers() {
        try {
            await new Promise(resolve => setTimeout(resolve, 2000));
            const response = await axios.get('https://api.binance.com/api/v3/ticker/24hr', {
                timeout: 20000,
                headers: {
                    'User-Agent': 'QBTC-System/1.0',
                    'Accept': 'application/json'
                }
            });
            return response.data;
        } catch (error) {
            console.error('Error en getMultipleTickers:', error.message);
            return [];
        }
    }
};

// Actualizar métricas cuánticas
function updateQuantumMetrics(instrumentType, isHit, isMiss, isRateLimit) {
    const cache = organizedCache[instrumentType];
    if (isHit) cache.metrics.hits++;
    if (isMiss) cache.metrics.misses++;
    if (isRateLimit) cache.metrics.rateLimitCount++;
    cache.metrics.totalRequests++;
    cache.metrics.lastBinanceCall = Date.now();
}

// Decidir si llamar a Binance
function shouldCallBinance(instrumentType) {
    const cache = organizedCache[instrumentType];
    const now = Date.now();
    const timeSinceLastUpdate = now - cache.lastUpdate;
    const timeSinceLastBinanceCall = now - cache.metrics.lastBinanceCall;
    
    // Si la caché está vacía, forzar llamada
    if (Object.keys(cache.ticker).length === 0) {
        return true;
    }
    
    // Si han pasado más de 10 minutos, permitir llamada
    if (timeSinceLastUpdate > 600000) {
        return true;
    }
    
    // Si hemos tenido muchos rate limits, esperar más
    if (cache.metrics.rateLimitCount > 2) {
        return false;
    }
    
    // Delay adaptativo basado en rate limits previos
    const baseDelay = 10000; // 10 segundos base
    const rateLimitDelay = cache.metrics.rateLimitCount * 30000; // 30 segundos por rate limit
    const minTimeBetweenCalls = baseDelay + rateLimitDelay;
    
    return timeSinceLastBinanceCall > minTimeBetweenCalls;
}

// Función para obtener datos FUTURES con caché cuántica
async function getFuturesData() {
    const cache = organizedCache.futures;
    
    // PROTECCIÓN CRÍTICA: Si hemos sido baneados, usar caché por 30 minutos
    if (cache.metrics.rateLimitCount > 2) {
        console.log('[ALERT] Sistema baneado por Binance - Usando caché cuántica por 30 minutos');
        cache.lastUpdate = Date.now() + (30 * 60 * 1000);
        updateQuantumMetrics('futures', true, false, false);
        return cache.ticker;
    }
    
    // Verificar si debemos llamar a Binance
    if (!shouldCallBinance('futures')) {
        updateQuantumMetrics('futures', true, false, false);
        console.log('[DATA] Usando caché cuántica de futuros');
        return cache.ticker;
    }
    
    // Marcar como miss y aplicar delay adaptativo
    updateQuantumMetrics('futures', false, true, false);
    const delay = 2000 + (cache.metrics.rateLimitCount * 5000);
    await new Promise(resolve => setTimeout(resolve, delay));
    
    try {
        console.log('[API] Llamando a Binance para datos de futuros...');
        const data = await binanceAPIReal.futuresTicker24hr();
        
        if (data && Array.isArray(data)) {
            const futuresData = data.filter(item => item && item.symbol && item.symbol.endsWith('USDT'));
            cache.ticker = futuresData;
            cache.lastUpdate = Date.now();
            cache.quantumState = 'COLLAPSED';
            console.log(`[OK] Datos de futuros actualizados: ${futuresData.length} instrumentos`);
            return futuresData;
        }
        
        return cache.ticker;
    } catch (error) {
        console.error('[ERROR] Error obteniendo datos FUTURES:', error.message);
        
        // Manejo inteligente de errores con métricas cuánticas
        if (error.response) {
            if (error.response.status === 418) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('[ALERT] Rate limiting detectado - Aumentando métricas de protección');
                console.log('[WARNING] Usando caché cuántica con datos existentes');
                // Forzar caché por 30 minutos después de error 418
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            } else if (error.response.status === 429) {
                updateQuantumMetrics('futures', false, true, true);
                console.log('[ALERT] Too Many Requests - Aumentando métricas de protección');
                console.log('[WARNING] Usando caché cuántica con datos existentes');
                // Forzar caché por 30 minutos después de error 429
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            }
        }
        
        // Si no hay datos en caché, retornar array vacío
        if (Object.keys(cache.ticker).length === 0) {
            console.log('[WARNING] Cache vacía - Retornando array vacío');
            return [];
        }
        
        return cache.ticker;
    }
}

// Función para obtener datos SPOT con caché cuántica
async function getSpotData() {
    const cache = organizedCache.spot;
    
    // PROTECCIÓN CRÍTICA: Si hemos sido baneados, usar caché por 30 minutos
    if (cache.metrics.rateLimitCount > 2) {
        console.log('[ALERT] Sistema baneado por Binance - Usando caché cuántica por 30 minutos');
        cache.lastUpdate = Date.now() + (30 * 60 * 1000);
        updateQuantumMetrics('spot', true, false, false);
        return cache.ticker;
    }
    
    // Verificar si debemos llamar a Binance
    if (!shouldCallBinance('spot')) {
        updateQuantumMetrics('spot', true, false, false);
        console.log('[DATA] Usando caché cuántica de spot');
        return cache.ticker;
    }
    
    // Marcar como miss y aplicar delay adaptativo
    updateQuantumMetrics('spot', false, true, false);
    const delay = 2000 + (cache.metrics.rateLimitCount * 5000);
    await new Promise(resolve => setTimeout(resolve, delay));
    
    try {
        console.log('[API] Llamando a Binance para datos de spot...');
        const data = await binanceAPIReal.getMultipleTickers();
        
        if (data && Array.isArray(data)) {
            const spotData = {};
            data.forEach(item => {
                if (item.symbol && item.symbol.endsWith('USDT')) {
                    spotData[item.symbol] = {
                        instrumentType: 'SPOT',
                        symbol: item.symbol,
                        price: parseFloat(item.lastPrice),
                        priceChange: parseFloat(item.priceChange),
                        priceChangePercent: parseFloat(item.priceChangePercent),
                        volume: parseFloat(item.volume),
                        quoteVolume: parseFloat(item.quoteVolume),
                        highPrice: parseFloat(item.highPrice),
                        lowPrice: parseFloat(item.lowPrice),
                        count: parseInt(item.count),
                        baseAsset: item.symbol.replace('USDT', ''),
                        quoteAsset: 'USDT',
                        leverage: 1,
                        marginType: 'NONE',
                        liquidationPrice: null
                    };
                }
            });
            
            cache.ticker = spotData;
            cache.lastUpdate = Date.now();
            cache.quantumState = 'COLLAPSED';
            console.log(`[OK] Datos de spot actualizados: ${Object.keys(spotData).length} instrumentos`);
            return spotData;
        }
        
        return cache.ticker;
    } catch (error) {
        console.error('[ERROR] Error obteniendo datos SPOT:', error.message);
        
        // Manejo inteligente de errores con métricas cuánticas
        if (error.response) {
            if (error.response.status === 418) {
                updateQuantumMetrics('spot', false, true, true);
                console.log('[ALERT] Rate limiting detectado - Aumentando métricas de protección');
                console.log('[WARNING] Usando caché cuántica con datos existentes');
                // Forzar caché por 30 minutos después de error 418
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            } else if (error.response.status === 429) {
                updateQuantumMetrics('spot', false, true, true);
                console.log('[ALERT] Too Many Requests - Aumentando métricas de protección');
                console.log('[WARNING] Usando caché cuántica con datos existentes');
                // Forzar caché por 30 minutos después de error 429
                cache.lastUpdate = Date.now() + (30 * 60 * 1000);
                return cache.ticker;
            }
        }
        
        // Si no hay datos en caché, retornar objeto vacío
        if (Object.keys(cache.ticker).length === 0) {
            console.log('[WARNING] Cache vacía - Retornando objeto vacío');
            return {};
        }
        
        return cache.ticker;
    }
}

// Función para obtener datos OPTIONS con caché cuántica
async function getOptionsData() {
    const cache = organizedCache.options;
    
    // Verificar si debemos regenerar datos
    if (!shouldCallBinance('options')) {
        updateQuantumMetrics('options', true, false, false);
        console.log('[DATA] Usando caché cuántica de opciones');
        return cache.ticker;
    }
    
    // Marcar como miss
    updateQuantumMetrics('options', false, true, false);
    
    try {
        console.log('[DATA] Generando datos de opciones...');
        const optionsData = {};
        const baseSymbols = ['BTC', 'ETH', 'BNB', 'SOL', 'XRP'];
        const currentDate = new Date();
        
        baseSymbols.forEach(baseSymbol => {
            const strikes = [0.8, 0.9, 1.0, 1.1, 1.2];
            const expirations = [7, 14, 30, 60, 90];
            
            strikes.forEach(strikePercent => {
                expirations.forEach(daysToExpiry => {
                    const expiryDate = new Date(currentDate.getTime() + daysToExpiry * 24 * 60 * 60 * 1000);
                    const expiryStr = expiryDate.toISOString().split('T')[0];
                    
                    const callSymbol = `${baseSymbol}USDT-${expiryStr}-${(strikePercent * 100).toFixed(0)}C`;
                    const putSymbol = `${baseSymbol}USDT-${expiryStr}-${(strikePercent * 100).toFixed(0)}P`;
                    
                    const basePrice = getDynamicPrice(`${baseSymbol}USDT`);
                    const strikePrice = basePrice * strikePercent;
                    
                    optionsData[callSymbol] = {
                        instrumentType: 'OPTIONS',
                        symbol: callSymbol,
                        optionType: 'CALL',
                        baseAsset: baseSymbol,
                        quoteAsset: 'USDT',
                        strikePrice: strikePrice,
                        expiryDate: expiryStr,
                        daysToExpiry: daysToExpiry,
                        price: Math.max(0, basePrice - strikePrice) * 1.1,
                        priceChange: 0,
                        priceChangePercent: 0,
                        volume: 100 + (daysToExpiry * 10),
                        openInterest: 500 + (daysToExpiry * 50),
                        impliedVolatility: 0.3 + (daysToExpiry / 100),
                        delta: Math.min(0.9, Math.max(0.1, (basePrice - strikePrice) / basePrice)),
                        gamma: 0.01 + (daysToExpiry / 1000),
                        theta: -0.001 * daysToExpiry,
                        vega: 0.1 + (daysToExpiry / 200),
                        inTheMoney: basePrice > strikePrice,
                        intrinsicValue: Math.max(0, basePrice - strikePrice),
                        timeValue: Math.max(0, basePrice - strikePrice) * 0.1
                    };
                    
                    optionsData[putSymbol] = {
                        instrumentType: 'OPTIONS',
                        symbol: putSymbol,
                        optionType: 'PUT',
                        baseAsset: baseSymbol,
                        quoteAsset: 'USDT',
                        strikePrice: strikePrice,
                        expiryDate: expiryStr,
                        daysToExpiry: daysToExpiry,
                        price: Math.max(0, strikePrice - basePrice) * 1.1,
                        priceChange: 0,
                        priceChangePercent: 0,
                        volume: 100 + (daysToExpiry * 10),
                        openInterest: 500 + (daysToExpiry * 50),
                        impliedVolatility: 0.3 + (daysToExpiry / 100),
                        delta: Math.max(-0.9, Math.min(-0.1, -(strikePrice - basePrice) / basePrice)),
                        gamma: 0.01 + (daysToExpiry / 1000),
                        theta: -0.001 * daysToExpiry,
                        vega: 0.1 + (daysToExpiry / 200),
                        inTheMoney: basePrice < strikePrice,
                        intrinsicValue: Math.max(0, strikePrice - basePrice),
                        timeValue: Math.max(0, strikePrice - basePrice) * 0.1
                    };
                });
            });
        });
        
        cache.ticker = optionsData;
        cache.lastUpdate = Date.now();
        cache.quantumState = 'COLLAPSED';
        console.log(`[OK] Datos de opciones generados: ${Object.keys(optionsData).length} instrumentos`);
        return optionsData;
    } catch (error) {
        console.error('[ERROR] Error generando datos OPTIONS:', error.message);
        
        // Si no hay datos en caché, retornar objeto vacío
        if (Object.keys(cache.ticker).length === 0) {
            console.log('[WARNING] Cache vacía - Retornando objeto vacío');
            return {};
        }
        
        return cache.ticker;
    }
}

// Función para limpiar caché
function clearCache(force = false) {
    if (force) {
        console.log('🧹 Limpieza completa de caché forzada');
        Object.keys(organizedCache).forEach(type => {
            organizedCache[type].ticker = {};
            organizedCache[type].lastUpdate = Date.now();
            organizedCache[type].quantumState = 'SUPERPOSITION';
            organizedCache[type].metrics = {
                hits: 0,
                misses: 0,
                totalRequests: 0,
                lastBinanceCall: 0,
                rateLimitCount: 0
            };
        });
    } else {
        console.log('[DATA] Limpieza parcial de caché - Manteniendo métricas');
        Object.keys(organizedCache).forEach(type => {
            organizedCache[type].ticker = {};
            organizedCache[type].lastUpdate = Date.now();
            organizedCache[type].quantumState = 'SUPERPOSITION';
        });
    }
}

// Función para obtener todos los datos organizados
async function getAllOrganizedData() {
    try {
        const [futuresData, spotData, optionsData] = await Promise.all([
            getFuturesData(),
            getSpotData(),
            getOptionsData()
        ]);
        
        return {
            futures: futuresData,
            spot: spotData,
            options: optionsData,
            summary: {
                futuresCount: Array.isArray(futuresData) ? futuresData.length : 0,
                spotCount: Object.keys(spotData).length,
                optionsCount: Object.keys(optionsData).length,
                totalInstruments: (Array.isArray(futuresData) ? futuresData.length : 0) + 
                                Object.keys(spotData).length + 
                                Object.keys(optionsData).length,
                lastUpdate: new Date().toISOString(),
                cacheStatus: 'QUANTUM_ACTIVE'
            }
        };
    } catch (error) {
        console.error('[ERROR] Error obteniendo datos organizados:', error.message);
        return {
            futures: [],
            spot: {},
            options: {},
            summary: {
                futuresCount: 0,
                spotCount: 0,
                optionsCount: 0,
                totalInstruments: 0,
                lastUpdate: new Date().toISOString(),
                cacheStatus: 'ERROR'
            }
        };
    }
}

// ENDPOINTS

app.get('/api/futures-data', async (req, res) => {
    try {
        const data = await getFuturesData();
        res.json({
            success: true,
            data: data,
            timestamp: Date.now(),
            cache: organizedCache.futures.quantumState
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/spot-data', async (req, res) => {
    try {
        const data = await getSpotData();
        res.json({
            success: true,
            data: data,
            timestamp: Date.now(),
            cache: organizedCache.spot.quantumState
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/options-data', async (req, res) => {
    try {
        const data = await getOptionsData();
        res.json({
            success: true,
            data: data,
            timestamp: Date.now(),
            cache: organizedCache.options.quantumState
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/market-data', async (req, res) => {
    try {
        const data = await getAllOrganizedData();
        res.json({
            success: true,
            data: data,
            timestamp: Date.now()
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/quantum-metrics', (req, res) => {
    res.json({
        success: true,
        data: {
            futures: organizedCache.futures,
            spot: organizedCache.spot,
            options: organizedCache.options,
            timestamp: Date.now()
        }
    });
});

app.post('/api/clear-cache', (req, res) => {
    const { force } = req.body;
    clearCache(force);
    res.json({
        success: true,
        message: force ? 'Cache completamente limpiada' : 'Cache parcialmente limpiada',
        timestamp: Date.now()
    });
});

app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        service: 'QBTC Core System - Quantum Cache',
        timestamp: new Date().toISOString(),
        quantumState: {
            futures: organizedCache.futures.quantumState,
            spot: organizedCache.spot.quantumState,
            options: organizedCache.options.quantumState
        }
    });
});

// Iniciar servidor
app.listen(PORT, () => {
    console.log(`[NIGHT] Core System Organizado ejecutándose en puerto ${PORT}`);
    console.log(`[DATA] Sistema Cuántico con Caché Avanzada - ACTIVO`);
    console.log(`🔗 URL: http://localhost:${PORT}`);
    console.log(`[UP] Tipos de Instrumentos: SPOT, FUTURES, OPTIONS`);
    console.log(`[API] Conectando a Binance con protección cuántica...`);
    console.log(`[FAST] Caché cuántica inicializada con métricas inteligentes`);
});

module.exports = app;
