
// Constantes f√≠sicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * Script para cerrar todas las posiciones abiertas de forma controlada
 */

const BinanceConnector = require('./binance-connector');
const config = require('./config');

class PositionCloser {
    constructor() {
        this.binanceConnector = new BinanceConnector(config.binance);
    }

    async closeAllPositions() {
        console.log('üîÑ Cerrando todas las posiciones abiertas...');
        
        try {
            // Obtener posiciones de futuros abiertas
            const futuresPositions = await this.getFuturesPositions();
            console.log(`üìä Encontradas ${futuresPositions.length} posiciones de futuros abiertas`);
            
            // Cerrar posiciones de futuros
            for (const position of futuresPositions) {
                await this.closeFuturesPosition(position);
            }
            
            // Obtener posiciones de opciones abiertas
            const optionsPositions = await this.getOptionsPositions();
            console.log(`üìä Encontradas ${optionsPositions.length} posiciones de opciones abiertas`);
            
            // Mostrar informaci√≥n de posiciones de opciones (no se pueden cerrar autom√°ticamente)
            for (const position of optionsPositions) {
                this.showOptionsPosition(position);
            }
            
            console.log('‚úÖ Proceso de cierre completado');
            
        } catch (error) {
            console.error('‚ùå Error cerrando posiciones:', error.message);
        }
    }
    
    async getFuturesPositions() {
        try {
            const positions = await this.binanceConnector.getFuturesPositions();
            // Filtrar solo posiciones con cantidad > 0
            return positions.filter(pos => Math.abs(parseFloat(pos.positionAmt)) > 0);
        } catch (error) {
            console.error('‚ùå Error obteniendo posiciones de futuros:', error.message);
            return [];
        }
    }
    
    async getOptionsPositions() {
        try {
            const positions = await this.binanceConnector.getOptionsPositions();
            // Filtrar solo posiciones con cantidad > 0
            return positions.filter(pos => parseFloat(pos.quantity) > 0);
        } catch (error) {
            console.error('‚ùå Error obteniendo posiciones de opciones:', error.message);
            return [];
        }
    }
    
    async closeFuturesPosition(position) {
        try {
            const symbol = position.symbol;
            const positionAmt = parseFloat(position.positionAmt);
            const side = positionAmt > 0 ? 'SELL' : 'BUY'; // Opuesto a la posici√≥n actual
            const quantity = Math.abs(positionAmt);
            
            console.log(`üîÑ Cerrando posici√≥n de futuros: ${symbol} ${side} ${quantity}`);
            
            const orderParams = {
                symbol: symbol,
                side: side,
                type: 'MARKET',
                quantity: quantity.toString(),
                reduceOnly: true // Importante: solo cerrar posici√≥n existente
            };
            
            const result = await this.binanceConnector.placeFuturesOrder(orderParams);
            
            if (result && result.orderId) {
                console.log(`‚úÖ Posici√≥n cerrada: ${symbol} - Order ID: ${result.orderId}`);
            } else {
                console.log(`‚ö†Ô∏è No se pudo cerrar la posici√≥n: ${symbol}`);
            }
            
        } catch (error) {
            console.error(`‚ùå Error cerrando posici√≥n ${position.symbol}:`, error.message);
        }
    }
    
    showOptionsPosition(position) {
        console.log(`üìã Posici√≥n de opciones: ${position.symbol}`);
        console.log(`   - Lado: ${position.side}`);
        console.log(`   - Cantidad: ${position.quantity}`);
        console.log(`   - Precio de entrada: ${position.entryPrice}`);
        console.log(`   - PnL no realizado: ${position.unrealizedPNL}`);
        console.log(`   - Precio actual: ${position.markPrice}`);
        console.log(`   ‚ö†Ô∏è Las posiciones de opciones deben cerrarse manualmente desde la interfaz de Binance`);
    }
}

// Ejecutar el script
async function main() {
    const closer = new PositionCloser();
    await closer.closeAllPositions();
    process.exit(0);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = PositionCloser;