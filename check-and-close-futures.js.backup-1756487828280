
// Constantes físicas reales del sistema
const PHYSICAL_CONSTANTS = {
  "QUANTUM_COHERENCE": 0.75,
  "QUANTUM_CONSCIOUSNESS": 0.8,
  "QUANTUM_ENTANGLEMENT": 0.65,
  "QUANTUM_SUPERPOSITION": 0.7,
  "QUANTUM_TUNNELING": 0.6,
  "MARKET_VOLATILITY": 0.05,
  "MARKET_MOMENTUM": 0.1,
  "MARKET_LIQUIDITY": 0.75,
  "MARKET_SPREAD": 0.001,
  "MARKET_DEPTH": 500000,
  "FUNDING_RATE": 0.02,
  "FUNDING_VOLATILITY": 0.01,
  "FUNDING_DEVIATION": 0.5,
  "FUNDING_ANNUALIZED": 5,
  "LIQUIDATION_PROBABILITY": 0.05,
  "SLIPPAGE_RATE": 0.0025,
  "VOLATILITY_RISK": 0.1,
  "EXECUTION_RISK": 0.005,
  "VOLUME_24H": 500000,
  "VOLUME_RATIO": 0.75,
  "VOLUME_EXPANSION": 300000,
  "PRICE_CHANGE": 0.02,
  "PRICE_ACCELERATION": 0.015,
  "PRICE_MOMENTUM": 0.01,
  "TIME_TO_FUNDING": 1800000,
  "SESSION_INTENSITY": 0.6,
  "TEMPORAL_RESONANCE": 0.7,
  "FIBONACCI_STRENGTH": 0.75,
  "FIBONACCI_INDEX": 5,
  "NEURAL_CONFIDENCE": 0.85,
  "NEURAL_COHERENCE": 0.8,
  "NEURAL_ENTANGLEMENT": 0.7,
  "BASE_LEVERAGE": 15,
  "CONSERVATIVE_LEVERAGE": 10,
  "AGGRESSIVE_LEVERAGE": 25,
  "STOP_LOSS": 0.03,
  "TAKE_PROFIT": 0.06,
  "BASE_SCORE": 0.65,
  "CONFIDENCE_SCORE": 0.75,
  "QUALITY_SCORE": 0.8
};

/**
 * Script mejorado para verificar y cerrar posiciones de futuros abiertas
 */

const BinanceConnector = require('./binance-connector');
const config = require('./config');

class FuturesPositionManager {
    constructor() {
        this.binanceConnector = new BinanceConnector(config.binance);
    }

    async checkAndCloseAllFuturesPositions() {
        console.log('🔍 Verificando posiciones de futuros abiertas...');
        
        try {
            // Método 1: Obtener balance de futuros para ver posiciones
            const balance = await this.binanceConnector.getAccountBalance();
            console.log('📊 Balance actual:', JSON.stringify(balance.__detail, null, 2));
            
            // Método 2: Usar endpoint directo de posiciones de futuros
            const positions = await this.getFuturesPositionsDirectly();
            console.log(`📊 Posiciones encontradas: ${positions.length}`);
            
            if (positions.length === 0) {
                console.log('✅ No hay posiciones de futuros abiertas');
                return;
            }
            
            // Mostrar todas las posiciones
            for (const position of positions) {
                console.log(`📋 Posición: ${position.symbol}`);
                console.log(`   - Cantidad: ${position.positionAmt}`);
                console.log(`   - Precio entrada: ${position.entryPrice}`);
                console.log(`   - PnL: ${position.unRealizedProfit}`);
                console.log(`   - Margen: ${position.isolatedMargin}`);
            }
            
            // Cerrar todas las posiciones
            for (const position of positions) {
                if (Math.abs(parseFloat(position.positionAmt)) > 0) {
                    await this.closeFuturesPosition(position);
                    // Esperar un poco entre órdenes
                    await this.sleep(1000);
                }
            }
            
            console.log('✅ Proceso de cierre completado');
            
        } catch (error) {
            console.error('❌ Error:', error.message);
            console.error('Stack:', error.stack);
        }
    }
    
    async getFuturesPositionsDirectly() {
        try {
            // Usar el endpoint directo de Binance Futures
            const url = `${this.binanceConnector.config.futuresBaseUrl}/positionRisk`;
            const timestamp = Date.now() + (this.binanceConnector.timeOffsetMs || 0);
            
            const params = new URLSearchParams({
                timestamp: timestamp.toString(),
                recvWindow: '5000'
            });
            
            // Crear firma
            const signature = this.binanceConnector.createSignature(params.toString());
            params.append('signature', signature);
            
            const response = await fetch(`${url}?${params}`, {
                method: 'GET',
                headers: {
                    'X-MBX-APIKEY': this.binanceConnector.config.apiKey
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }
            
            const positions = await response.json();
            
            // Filtrar solo posiciones con cantidad > 0
            return positions.filter(pos => Math.abs(parseFloat(pos.positionAmt)) > 0);
            
        } catch (error) {
            console.error('❌ Error obteniendo posiciones directamente:', error.message);
            return [];
        }
    }
    
    async closeFuturesPosition(position) {
        try {
            const symbol = position.symbol;
            const positionAmt = parseFloat(position.positionAmt);
            const side = positionAmt > 0 ? 'SELL' : 'BUY'; // Opuesto a la posición actual
            const quantity = Math.abs(positionAmt);
            
            console.log(`🔄 Cerrando posición: ${symbol} ${side} ${quantity}`);
            
            // Formatear cantidad según las reglas de precisión
            const formattedQuantity = this.formatQuantity(symbol, quantity);
            
            const orderParams = {
                symbol: symbol,
                side: side,
                type: 'MARKET',
                quantity: formattedQuantity,
                reduceOnly: true,
                timestamp: Date.now() + (this.binanceConnector.timeOffsetMs || 0),
                recvWindow: 5000
            };
            
            console.log('📋 Parámetros de orden:', orderParams);
            
            const result = await this.binanceConnector.placeFuturesOrder(orderParams);
            
            if (result && result.orderId) {
                console.log(`✅ Posición cerrada exitosamente: ${symbol} - Order ID: ${result.orderId}`);
            } else {
                console.log(`⚠️ Respuesta inesperada:`, result);
            }
            
        } catch (error) {
            console.error(`❌ Error cerrando posición ${position.symbol}:`, error.message);
            if (error.response) {
                console.error('Detalles del error:', error.response);
            }
        }
    }
    
    formatQuantity(symbol, quantity) {
        // Reglas de precisión específicas por símbolo
        const precisionRules = {
            'BTCUSDT': 3,   // 0.001
            'ETHUSDT': 3,   // 0.001  
            'BNBUSDT': 2,   // 0.01
            'SOLUSDT': 1,   // 0.1
            'XRPUSDT': 0,   // 1
            'DOGEUSDT': 0   // 1
        };
        
        const decimals = precisionRules[symbol] || 3;
        return parseFloat(quantity.toFixed(decimals)).toString();
    }
    
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Ejecutar el script
async function main() {
    const manager = new FuturesPositionManager();
    await manager.checkAndCloseAllFuturesPositions();
    process.exit(0);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = FuturesPositionManager;